{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/material1.4.0/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/bg.png","path":"img/bg.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/browserstack_logo.png","path":"img/browserstack_logo.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/upyun_logo.svg","path":"img/upyun_logo.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/disqus-proxy.css","path":"css/disqus-proxy.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/duoshuo.css","path":"css/duoshuo.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/disqus-proxy.min.css","path":"css/disqus-proxy.min.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/fontawesome.min.css","path":"css/fontawesome.min.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/uc.css","path":"css/uc.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/lsloader.min.js","path":"js/lsloader.min.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/lsloader.js","path":"js/lsloader.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/nprogress.js","path":"js/nprogress.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/queue.js","path":"js/queue.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/mathjax.js","path":"js/mathjax.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/queue.min.js","path":"js/queue.min.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/daily_pic.png","path":"img/daily_pic.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/material.min.css","path":"css/material.min.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/js.js","path":"js/js.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/js.min.js","path":"js/js.min.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/avatar_corner.png","path":"img/avatar_corner.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-facebook.svg","path":"img/footer/footer_ico-facebook.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-bilibili.svg","path":"img/footer/footer_ico-bilibili.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-github.svg","path":"img/footer/footer_ico-github.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-gplus.svg","path":"img/footer/footer_ico-gplus.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-instagram.svg","path":"img/footer/footer_ico-instagram.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-linkedin.svg","path":"img/footer/footer_ico-linkedin.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-telegram.svg","path":"img/footer/footer_ico-telegram.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-twitter.svg","path":"img/footer/footer_ico-twitter.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-tumblr.svg","path":"img/footer/footer_ico-tumblr.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-weibo.svg","path":"img/footer/footer_ico-weibo.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-zhihu.svg","path":"img/footer/footer_ico-zhihu.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-10.png","path":"img/random/material-10.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-12.png","path":"img/random/material-12.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-17.png","path":"img/random/material-17.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-19.png","path":"img/random/material-19.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-3.png","path":"img/random/material-3.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-4.png","path":"img/random/material-4.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-9.png","path":"img/random/material-9.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/css/material.css","path":"css/material.css","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-6.png","path":"img/random/material-6.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-8.png","path":"img/random/material-8.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-1.png","path":"img/random/material-1.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-11.png","path":"img/random/material-11.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-13.png","path":"img/random/material-13.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-15.png","path":"img/random/material-15.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-14.png","path":"img/random/material-14.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-16.png","path":"img/random/material-16.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-2.png","path":"img/random/material-2.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-18.png","path":"img/random/material-18.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-5.png","path":"img/random/material-5.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/img/random/material-7.png","path":"img/random/material-7.png","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/material1.4.0/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"30c8bf9a4385a175d81058e9458ba9e605ed5856","modified":1484721535000},{"_id":"source/.DS_Store","hash":"e37bd352ea1e9cd9eebb5907358a0d0550452d1a","modified":1516551402000},{"_id":"themes/material1.4.0/CONTRIBUTING.zh-cn.md","hash":"ef3ccef0451d6ac616b3a35fbfedb6abd35e6b41","modified":1516540192000},{"_id":"themes/material1.4.0/CONTRIBUTING.md","hash":"148f555e47d4725fe1faac775107a4d7b03f7136","modified":1516540192000},{"_id":"themes/material1.4.0/_config.yml","hash":"9f143387f3801eb58846af1d73ae9635c129b5f1","modified":1516549078000},{"_id":"themes/material1.4.0/.DS_Store","hash":"dd4cffe1206c9347a6e9f1d83fc9dd58404c915d","modified":1516551402000},{"_id":"themes/material1.4.0/README.md","hash":"cc7b80f6bce7b910a7ba641abac1ade1311705f8","modified":1516542985000},{"_id":"themes/material1.4.0/contributing.json","hash":"1bc0871b1c7822b82533b614090ac0ab7c55282c","modified":1516540192000},{"_id":"themes/material1.4.0/_config1.yml","hash":"88bb2b320a8dd19c317d39fbe4eeeb7f63e05ed1","modified":1516544451000},{"_id":"themes/material1.4.0/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1516540192000},{"_id":"themes/material1.4.0/package.json","hash":"6b63bbc7e3c8532359dd2a80328f51f4e97474b9","modified":1516542985000},{"_id":"themes/material1.4.0/lint.sh","hash":"49c3a65f8ca65754ec7fefcd2dcb6adc187f3856","modified":1516540192000},{"_id":"source/_posts/Kotlin-KotprefEncryptSupport加密sharepreference.md","hash":"ebacd6d11d37c9cfdb9e4916a2825bca0095d58a","modified":1516509885000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1516540519000},{"_id":"source/_posts/android-Kotlin的Class、反射、泛型.md","hash":"c5f68f6347ba28242e110dd07475fcc05214d1a6","modified":1516541131000},{"_id":"source/_posts/android-OTG-读取usb设备文件并上传（问题解决）.md","hash":"0b4a7ab59fd92312141b2836376b53ccafdecd75","modified":1516511272000},{"_id":"source/_posts/android-MPAndroidChart-自适应Markerview.md","hash":"1ac4ea30231721a934d4408c9d0214261d85f0f5","modified":1516509826000},{"_id":"source/_posts/android-PorterDuffXferMode真正的效果测试集合（对比官方demo）.md","hash":"ef4b32a83f08271c36c97bd0758eddff8a617a4c","modified":1516509826000},{"_id":"source/_posts/android-scheme链接打开本地应用.md","hash":"da8c5923d01198073339f45c936ed02e5146e2e8","modified":1516510305000},{"_id":"source/_posts/android-view的多种移动方式（测试集合）.md","hash":"946fbac4cd05602c102333c75affe8af15d48ddd","modified":1516509885000},{"_id":"source/_posts/android-greendao3.0 多表关联踩坑实践.md","hash":"1ed83ddc33ea30257117c635dce5439e14b82553","modified":1516511108000},{"_id":"source/_posts/android-写文件生成器的时候换行请用/r/n.md","hash":"24b52ba379cc2bbb127303ecce29d8facc7c4ffe","modified":1516509341000},{"_id":"source/_posts/hello.md","hash":"4d6697046dd406f6398e43848f2c06f9106b7957","modified":1516509885000},{"_id":"source/_posts/微信小程序-开发经验总结.md","hash":"82deb1843299ad31259a035e54235c1859ea6099","modified":1487677890000},{"_id":"source/_posts/微信小程序.md","hash":"3f615d4387e7ee3958a8f6caaa5ec86ef591c864","modified":1484790857000},{"_id":"source/_posts/你的三观是什么.md","hash":"b6b63579ae6d046e15d68b8b891e79157faf90a0","modified":1484901441000},{"_id":"source/_posts/解决NestedScrollView包裹横向RecyclerView导致behavior回调方法没有执行及源码分析.md","hash":"d9df0e6d55bb889782dad7d1f058c6933fa1bc13","modified":1516511376000},{"_id":"themes/material1.4.0/languages/ar.yml","hash":"b8ffe10584fe49ed0218e57b27140b134e3022f8","modified":1516542985000},{"_id":"themes/material1.4.0/languages/es.yml","hash":"aaf23ea448489ec01f7c6228e3bf4833e062ec34","modified":1516542985000},{"_id":"themes/material1.4.0/languages/en.yml","hash":"2d538f5b71b2837b75bdcb686f1431a48dcb6eda","modified":1516542985000},{"_id":"themes/material1.4.0/languages/de.yml","hash":"bce37d066ffa82f3e249d41d0ee883c913cc2c5f","modified":1516540192000},{"_id":"themes/material1.4.0/languages/fr.yml","hash":"66a966e8a9a60bfe00829b20c1f5e26cd6390f73","modified":1516542985000},{"_id":"themes/material1.4.0/languages/ja.yml","hash":"af5466576ce9f6cac8529feb57ac8ba5401a318f","modified":1516542985000},{"_id":"themes/material1.4.0/languages/zh-CN.yml","hash":"563671897a5d4d04ddc2f4b8a45e8f2c366a77b9","modified":1516542985000},{"_id":"themes/material1.4.0/languages/pt-BR.yml","hash":"a070c2c4d0d3d54f8ca70513cff73c3f7c306db1","modified":1516540192000},{"_id":"themes/material1.4.0/languages/ms.yml","hash":"237a39bbfcce33e7b918f6c5dc0f01bc79900262","modified":1516540192000},{"_id":"themes/material1.4.0/languages/zh-TW.yml","hash":"516b74e942f849e716098d111c7c3a9f4847cb0a","modified":1516542985000},{"_id":"themes/material1.4.0/scripts/helper.js","hash":"e7111a8b1f0ab5bf3466378c48c260a4f6e527d6","modified":1516540192000},{"_id":"themes/material1.4.0/layout/index.ejs","hash":"aca1abb741f891776913c8ea2e6ff626a0ea5736","modified":1516540192000},{"_id":"themes/material1.4.0/layout/layout.ejs","hash":"94f66850b815a262c0f8ff112a32a0a6f43066e3","modified":1516540192000},{"_id":"themes/material1.4.0/layout/post.ejs","hash":"17bf2e8e65b2d1bdfc85857a25755add8a875b16","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/Isolation-post-info.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516540192000},{"_id":"themes/material1.4.0/scripts/lib/font_lsload.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/Isolation-post_entry.ejs","hash":"45eb5dc723d36e32553038422061cba6828957a1","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/Paradox-post-thumbnail.ejs","hash":"31095a56feaf04a710e8302ccb18e2d4d10b97ba","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/Paradox-post_entry-thumbnail.ejs","hash":"ae949e16cbd20d895ba3c0b64f3992bf28d81e06","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/Paradox-post-info.ejs","hash":"9c6e728a736eaba7edbcaf6862e5dcef8edd2a9e","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/Paradox-search.ejs","hash":"18a6971b04feccd124a096b8c7cecf1fd4bb914e","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/Paradox-post_entry.ejs","hash":"36d3798224bf7dff7c0659876c5ad8a4785198e2","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/config_font.ejs","hash":"f564ba4b36363882154870558091383887fffdf8","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/blog_info.ejs","hash":"1b1a18b49674d2e78672a69c6ced6ff35f1b63e9","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/config_css.ejs","hash":"9956cc20b84b67334dcc80a5d4396f9064d4a804","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/daily_pic.ejs","hash":"22f377c0ba70d930a66dfcc775f216a560746996","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/footer-left.ejs","hash":"c17e2da7d6cb0e4104fc64a541f4c81f4abed095","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/config_footer.ejs","hash":"bd520f4e8a381494c78e3c00905c80a9cd807f97","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/footer-option.ejs","hash":"be20394eaeaf2d20db28946b948962c839da6ea9","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/footer.ejs","hash":"75ecc32a258857424c48a2ebb0b5b9f3b30614a5","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/footer_top.ejs","hash":"9eaace4feb951c96c0033e7271497f3f300d2476","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/isolate_info.ejs","hash":"b8ec76716bfa2e6513b4df6814fe8676536a94c1","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/import_js.ejs","hash":"88c604ae4f70ccf24289bc967f18ada697013304","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/head.ejs","hash":"16a4bc65e631f5d21e7fd204f457adc86ea2af26","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/isolate-sns_list.ejs","hash":"fc5f03ebb847f85975676a9dfee8870e7c908008","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/post-content.ejs","hash":"02374b20989c81031e29257d872624d5195ddcbd","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/post-header.ejs","hash":"e5c1271b94d66597812cdf88057c8690bfe72d55","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/post-nav.ejs","hash":"7b291719414408a9ec0b9167a2c6c834f90905b3","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/post-info-share.ejs","hash":"b6e5af993245a2e3caa6eb66009503ec52c82f5b","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/sidebar-footer.ejs","hash":"6c3486b846473e0d58666f7a8720f5bf4a14e030","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/sidebar-footer_image.ejs","hash":"44aba38692abc609f28b55bff81362a1c03ce36c","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/sidebar-header.ejs","hash":"d18344f05712f66e0385839e4d83d5a3a515c140","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/sidebar.ejs","hash":"c5ce6136e82895cb80dab8a918a7cdf2fe820fea","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/sidebar-navigation.ejs","hash":"ff44901fdfdd952174b0d22e86df7163d7fba9ba","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_partial/structured-data.ejs","hash":"f3ed6673a774cd5a27c94dfe174e8f7344f4ebbe","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_partial/toc_button.ejs","hash":"1c0773c3b2cf33aad0e0373540e11540e5137c75","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/leancloud-like.ejs","hash":"e4780fe3bbb049db38d694fc18dee13d799bd51d","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/leancloud-views.ejs","hash":"211dc183b8e84f71b2c25b3ac6659d162d81662b","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/leancloud-views_num.ejs","hash":"e27baba6a2de406463735d276606b15fb40f5eba","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/mathjax.ejs","hash":"843818bffeaebe5e3fa07c90d260bb912555cb3b","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/nprogress.ejs","hash":"52fcfe5b70c25378e48bb67daf85d952b32d34b2","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/page-gallery.ejs","hash":"f03bc95a0c9b4905413b8fdfefc1af463b51e828","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/page-links.ejs","hash":"ed636c70c24a9265f386102d8735dead797d94c2","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/page-tagcloud.ejs","hash":"e71de74e4067cc4e6aef1e09ac429c92bcd178b3","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/qrcode.ejs","hash":"ab544bc337a48bdd30f9cb146db6a287bb36a10f","modified":1516542985000},{"_id":"themes/material1.4.0/scripts/lib/css_lsload.js","hash":"c52bbfe62863cd141925747b2575a6a6858444d1","modified":1516542985000},{"_id":"themes/material1.4.0/scripts/lib/get_file_hex.js","hash":"eb3b9a45f8ca45ef40d5421baef7d4484023982c","modified":1516540192000},{"_id":"themes/material1.4.0/scripts/lib/js_hex.js","hash":"2704583aa036d538544ce31c2e924c0c125309dd","modified":1516540192000},{"_id":"themes/material1.4.0/scripts/lib/js_lsload.js","hash":"c604f337d219bccf3f315e984cf12a6658dbd7a2","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/page-timeline.ejs","hash":"9fa0195e08d9fd40aa0333e9279c98bc65acf604","modified":1516540192000},{"_id":"themes/material1.4.0/scripts/lib/path_for.js","hash":"f944e3b53a468962121aa3357cc0bc18ac27a34c","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/search-swiftype-js.ejs","hash":"7ad1e843e620ccd9b3c041dccfdcee97921247a1","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/search-local-js.ejs","hash":"146bfb6952f17c0afbd26ac16a15c4d0d73c83d9","modified":1516542985000},{"_id":"themes/material1.4.0/source/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/disqus-proxy.css","hash":"770776d8cec27cd5661bdfd59eff9af263439989","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/style.css","hash":"52a827e62695ed758b5e5102e63f78a532c0311c","modified":1516542985000},{"_id":"themes/material1.4.0/source/css/style.min.css","hash":"2e9f8420f0047e7639df4be5619bf279b4ecb94f","modified":1516542985000},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/lsloader.min.js","hash":"089ffda1dbc3ec5e5168331121ce6daaa241c132","modified":1516542985000},{"_id":"themes/material1.4.0/source/js/lsloader.js","hash":"890f196c276aded83e40a60c516e4408d42a3c7d","modified":1516542985000},{"_id":"themes/material1.4.0/source/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/mathjax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1516542985000},{"_id":"themes/material1.4.0/source/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/material.min.css","hash":"f3c8e6a9d94e6cad30c6628e1d732e6ee00d5fce","modified":1516542985000},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/js.js","hash":"15ab2a8a59623db0faaea3c50e0f347cc0dc810e","modified":1516542985000},{"_id":"themes/material1.4.0/source/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/js.min.js","hash":"2d0e6569a2bb608bfd37f395945ac449d3924d84","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/analytics/cnzz-analytics.ejs","hash":"61a891acb13e71289f360c91cb27fb88f81848ec","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/analytics/baidu-analytics.ejs","hash":"c24af97754140f221d20323a3e5aac9dd02889d4","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/analytics/google-analytics.ejs","hash":"8bff3b1bd066eef693319b82400c353b2d6736e7","modified":1516542985000},{"_id":"themes/material1.4.0/source/img/avatar_corner.png","hash":"9e8e6d0fc945854b15ace16ed7d0ad11279f7b64","modified":1479711863000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1516540192000},{"_id":"themes/material1.4.0/source/css/material.css","hash":"19818d637ecb3bae73d16ee90444c42fe4458b54","modified":1516542985000},{"_id":"themes/material1.4.0/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1516540192000},{"_id":"themes/material1.4.0/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1516540192000},{"_id":"themes/material1.4.0/source/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/163gentie/common.ejs","hash":"ac56d01746ef2f72d54bff4b61e0ca0089c5c164","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/comment/163gentie/enter.ejs","hash":"6e057829fa926cc02e3e2ebfdee7c244a9b31dd7","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/comment/163gentie/main.ejs","hash":"e84afb44929f4dab8cf279b958d472955bc5f034","modified":1516542985000},{"_id":"themes/material1.4.0/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/disqus/enter.ejs","hash":"39192034766349e47967da63184f9104fdded2ab","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/disqus/main.ejs","hash":"21e0eeff664191b818d7a0071ae7edcdfc270442","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1516540192000},{"_id":"themes/material1.4.0/layout/_widget/comment/disqus_click/main.ejs","hash":"fa89d225dafa4a6b0f6be6fe395ada0be172c4ae","modified":1516542985000},{"_id":"themes/material1.4.0/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1516540192000},{"_id":"themes/material1.4.0/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1516540192000},{"_id":"public/2018/01/21/Kotlin-KotprefEncryptSupport加密sharepreference/index.html","hash":"ed0959c768b6007054321dd63d0c2447a39d009c","modified":1516551720538},{"_id":"public/2018/01/21/android-Kotlin的Class、反射、泛型/index.html","hash":"de2817b543abc8dd202a54acd03778093d50454d","modified":1516551720538},{"_id":"public/2018/01/21/android-写文件生成器的时候换行请用/r/n/index.html","hash":"d5977eb0fad9061206ce5f841ed57bf229aeb3aa","modified":1516551720539},{"_id":"public/2018/01/21/解决NestedScrollView包裹横向RecyclerView导致behavior回调方法没有执行及源码分析/index.html","hash":"caf74a601aa4065b1f70485d4eea55ff6254f269","modified":1516551720539},{"_id":"public/2018/01/21/android-MPAndroidChart-自适应Markerview/index.html","hash":"8a2a965816c2f302d8744b2cbe6135e7b10aa68b","modified":1516551720539},{"_id":"public/2018/01/21/android-OTG-读取usb设备文件并上传（问题解决）/index.html","hash":"fb59f784972e5b1340ff52d99c0c5ef3782a39ab","modified":1516551720539},{"_id":"public/2018/01/21/android-greendao3.0 多表关联踩坑实践/index.html","hash":"9d3601d3dbddc7173ebedff4b99d92743b0256a6","modified":1516551720539},{"_id":"public/2018/01/21/android-scheme链接打开本地应用/index.html","hash":"b9b53e6edc475b20ae5c0608500c7ee90190fceb","modified":1516551720539},{"_id":"public/2018/01/21/android-view的多种移动方式（测试集合）/index.html","hash":"40aa20f3f3dcc57ad31096c5ad3ab415a9d62e34","modified":1516551720540},{"_id":"public/2018/01/21/android-PorterDuffXferMode真正的效果测试集合（对比官方demo）/index.html","hash":"05ce9585ecd754c27be14ae673d9feb41d8309cb","modified":1516551720540},{"_id":"public/2017/02/21/微信小程序-开发经验总结/index.html","hash":"c376a10107d75bd3214003e39bfa1f4ed6126ce0","modified":1516551720540},{"_id":"public/2017/01/20/你的三观是什么/index.html","hash":"1467c62a322cf09e258577da89ef816a58e4ae9c","modified":1516551720540},{"_id":"public/2017/01/19/微信小程序/index.html","hash":"14cbf9acbb58c6ebcf16e073b0d2345796bda3b0","modified":1516551720540},{"_id":"public/2017/01/18/hello/index.html","hash":"a3b702b0432e6f07f285bfaa8c28c9d9e2793e07","modified":1516551720540},{"_id":"public/archives/index.html","hash":"c3e22c397d13c36f0ddc3d752cdab4efc7fa39c3","modified":1516551720540},{"_id":"public/archives/page/2/index.html","hash":"801479133d7748a8c1457801222320b453ffcfea","modified":1516551720540},{"_id":"public/archives/2017/index.html","hash":"a8eff7d65654b10b2522f4a7d78379606fbaaa5b","modified":1516551720540},{"_id":"public/archives/2017/01/index.html","hash":"55cfcd07e64cceec4744b67b6be377712b5dff6f","modified":1516551720540},{"_id":"public/archives/2017/02/index.html","hash":"aab316fefda66b57ef0bf265ffa639bfdddcdb5d","modified":1516551720540},{"_id":"public/archives/2018/index.html","hash":"82a085e3f18a0dedd071b5a370c765b1fd0c3aa0","modified":1516551720540},{"_id":"public/archives/2018/01/index.html","hash":"dc43c59bb4d0bfb2dcbeac8c141bfda45a3137e7","modified":1516551720540},{"_id":"public/index.html","hash":"2cd26579b93909be555d18021598f3eeb38a1fad","modified":1516551720540},{"_id":"public/page/2/index.html","hash":"96bc7742ec1218e99103f4936ad0a46aa6271410","modified":1516551720540},{"_id":"public/tags/kotlin/index.html","hash":"b30051494ff5ebf95cd6e166d5e6bc18f48f6229","modified":1516551720540},{"_id":"public/tags/android/index.html","hash":"5166f720d425c4e63c7c228ae4077aff517fd2a2","modified":1516551720540},{"_id":"public/CNAME","hash":"30c8bf9a4385a175d81058e9458ba9e605ed5856","modified":1516551720566},{"_id":"public/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1516551720566},{"_id":"public/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1516551720566},{"_id":"public/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1516551720566},{"_id":"public/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1516551720566},{"_id":"public/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1516551720566},{"_id":"public/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1516551720566},{"_id":"public/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1516551720566},{"_id":"public/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1516551720566},{"_id":"public/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1516551720566},{"_id":"public/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1516551720566},{"_id":"public/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1516551720566},{"_id":"public/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1516551720566},{"_id":"public/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1516551720566},{"_id":"public/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1516551720566},{"_id":"public/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1516551720566},{"_id":"public/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1516551720566},{"_id":"public/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1516551720566},{"_id":"public/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1516551720566},{"_id":"public/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1516551720566},{"_id":"public/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1516551720566},{"_id":"public/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1516551720566},{"_id":"public/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1516551720566},{"_id":"public/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1516551720566},{"_id":"public/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1516551720566},{"_id":"public/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1516551720567},{"_id":"public/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1516551720567},{"_id":"public/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1516551720567},{"_id":"public/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1516551720567},{"_id":"public/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1516551720567},{"_id":"public/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1516551720567},{"_id":"public/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1516551720567},{"_id":"public/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1516551720567},{"_id":"public/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1516551720576},{"_id":"public/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1516551720578},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1516551720580},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1516551720580},{"_id":"public/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1516551720580},{"_id":"public/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1516551720580},{"_id":"public/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1516551720580},{"_id":"public/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1516551720580},{"_id":"public/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1516551720580},{"_id":"public/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1516551720580},{"_id":"public/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1516551720580},{"_id":"public/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1516551720580},{"_id":"public/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1516551720581},{"_id":"public/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1516551720581},{"_id":"public/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1516551720591},{"_id":"public/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1516551720591},{"_id":"public/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1516551720591},{"_id":"public/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1516551720591},{"_id":"public/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1516551720591},{"_id":"public/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1516551720591},{"_id":"public/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1516551720591},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1516551720591},{"_id":"public/js/lsloader.min.js","hash":"089ffda1dbc3ec5e5168331121ce6daaa241c132","modified":1516551720591},{"_id":"public/js/lsloader.js","hash":"890f196c276aded83e40a60c516e4408d42a3c7d","modified":1516551720591},{"_id":"public/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1516551720591},{"_id":"public/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1516551720591},{"_id":"public/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1516551720591},{"_id":"public/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1516551720591},{"_id":"public/css/disqus-proxy.css","hash":"d5086cda8aaae20b8d3f9dd50f0be5ccb717e42a","modified":1516551720591},{"_id":"public/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1516551720591},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1516551720591},{"_id":"public/css/style.css","hash":"52a827e62695ed758b5e5102e63f78a532c0311c","modified":1516551720592},{"_id":"public/css/style.min.css","hash":"2e9f8420f0047e7639df4be5619bf279b4ecb94f","modified":1516551720592},{"_id":"public/js/mathjax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1516551720592},{"_id":"public/css/material.min.css","hash":"f3c8e6a9d94e6cad30c6628e1d732e6ee00d5fce","modified":1516551720592},{"_id":"public/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1516551720592},{"_id":"public/js/js.js","hash":"15ab2a8a59623db0faaea3c50e0f347cc0dc810e","modified":1516551720592},{"_id":"public/js/js.min.js","hash":"2d0e6569a2bb608bfd37f395945ac449d3924d84","modified":1516551720592},{"_id":"public/css/material.css","hash":"19818d637ecb3bae73d16ee90444c42fe4458b54","modified":1516551720592},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1516551720592},{"_id":"public/img/avatar_corner.png","hash":"9e8e6d0fc945854b15ace16ed7d0ad11279f7b64","modified":1516551720592},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1516551720593},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1516551720593},{"_id":"public/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1516551720593},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1516551720593},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1516551720607},{"_id":"public/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1516551720609},{"_id":"public/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1516551720609},{"_id":"public/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1516551720609},{"_id":"public/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1516551720609},{"_id":"public/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1516551720610},{"_id":"public/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1516551720610}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Kotlin KotprefEncryptSupport加密sharepreference","date":"2018-01-21T04:38:51.000Z","_content":"### 前言\n最近在学习kotlin，发现一个比较不错的sharepreference库[kotpref](https://github.com/chibatching/Kotpref)。\n它是利用kotlin的扩展和代理来实现的，使用起来也方便快捷。\n但是，就是还差一个想要的功能，就是加密。\n然后自己写了个[KotprefEncryptSupport](https://github.com/fly7632785/KotprefEncryptSupport)来支持一下。\n\n### 安装\n\n```groovy\nallprojects {\n\t\trepositories {\n\t\t\tmaven { url 'https://jitpack.io' }\n\t\t}\n\t}\n```\n```groovy\ndependencies {\n    compile 'com.github.fly7632785:KotprefEncryptSupport:1.0.1'\n}\n```\n\n### 初始化\n\n它已经包含了gson-support，所以，如果使用了这个库，就不用再接入gson-support了\n```kotlin\nclass SampleApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        Kotpref.init(applicationContext)\n        // add Encrypt Support \n        Kotpref.gson = Gson()\n        Kotpref.cipherAdapter = SharedPrefCipherAdapter(applicationContext)\n    }\n}\n```\n### 申明使用\n```\n    var password by ecStringPref(\"jafirPass\")\n    var code1 by ecNullableStringPref()\n    var isMan by ecBooleanPref(true)\n    var age1 by ecIntPref(23)\n    var highScore1 by ecLongPref(1111111111L)\n    var rate1 by ecFloatPref(0.5555f)\n    var person1 by ecGsonPref(Person(\"g jafir\", 21))\n    var avatar21 by ecGsonPref(Avatar())\n    var avatar22 by ecGsonNullablePref(Avatar())\n```\n支持 Int,String,Boolean,Long,Float,Gson\n###  高级\n\n如果你想自定义加密规则，也是可以的。\n只需要自己实现一下CipherAdapter，然后实现一下encrypt和decrypt两个方法就可以了。例如\n\n```\nclass SharedPrefCipherAdapter @Throws(Exception::class)\nconstructor(context: Context) : CipherAdapter {\n    private val secretKey: SecretKey\n\n    init {\n        this.secretKey = AESUtil.generateKey(context)\n    }\n\n    override fun encrypt(raw: String): String {\n        return AESUtil.execEncrypted(secretKey, raw)\n    }\n\n    override fun decrypt(encode: String): String {\n        return AESUtil.execDecrypted(secretKey, encode)\n    }\n}\n```\n更多的细节可以看源码\n\n\n#### 默认的加密\n库中已经集成了一个默认的加密adapter：SharedPrefCipherAdapter\n采用的是AES、PBE混合的加密方式，AES加密内容，然后PBE加密secret key\n#### Xml\n```xml\n<map>\n    <long name=\"highScore\" value=\"3901\" />\n    <float name=\"rate\" value=\"0.4\" />\n    <string name=\"password\">WUb7wV8SS18d9hEvUt8kPg==&#10;    </string>\n    <string name=\"age1\">vELsGwmt5Bhz1WkAuasEHA==&#10;    </string>\n    <string name=\"avatar22\">rN29eRFNgIlf6yIAV9cptoyabAkqmDqDtf6S4ElzPWIVS1YRMXw2avvYbyJseOZEOBqVE9kAAARV&#10;T4MpZ31fAw==&#10;    </string>\n    <string name=\"avatar1\">null</string>\n    <string name=\"avatar21\">rN29eRFNgIlf6yIAV9cpttcgywAfWQ9P21mqhkpLjhty0xyusdIZtGLibaD5gzdExLQhyLF2BbIR&#10;Vz7hM0a0KA==&#10;    </string>\n    <string name=\"avatar\">{&quot;icon&quot;:&quot;lion&quot;,&quot;updated_at&quot;:&quot;Dec 19, 2017 11:13:28 PM&quot;}</string>\n    <string name=\"person1\">gA4aAC4rCqoo9Vz3VCBgVtnerDMep/WhMsoUK736qJ4=&#10;    </string>\n    <string name=\"code\">451B65F6-EF95-4C2C-AE76-D34535F51B3B</string>\n    <string name=\"isMan\">gi8S6qu7Sklcx0oiYDGnsw==&#10;    </string>\n    <set name=\"prizes\">\n        <string>New Born</string>\n    </set>\n    <int name=\"age\" value=\"2\" />\n    <string name=\"highScore1\">L5E9zu5NO5AQGFVZBmmHTA==&#10;    </string>\n    <string name=\"name\">chibatching Jr</string>\n    <string name=\"rate1\">Pa0WPZj6Of7DV8S4LYfp2g==&#10;    </string>\n    <string name=\"code1\">FZbcxuspUwL0HUdYvuQ6ltT/nWL+e5d3ZXtfTfPXGcccThyKavFb+7iB1bR8PGF6&#10;    </string>\n    <string name=\"gameLevel\">EASY</string>\n</map>\n\n```\n","source":"_posts/Kotlin-KotprefEncryptSupport加密sharepreference.md","raw":"---\ntitle: Kotlin KotprefEncryptSupport加密sharepreference\ndate: 2018-01-21 12:38:51\ntags: kotlin\n---\n### 前言\n最近在学习kotlin，发现一个比较不错的sharepreference库[kotpref](https://github.com/chibatching/Kotpref)。\n它是利用kotlin的扩展和代理来实现的，使用起来也方便快捷。\n但是，就是还差一个想要的功能，就是加密。\n然后自己写了个[KotprefEncryptSupport](https://github.com/fly7632785/KotprefEncryptSupport)来支持一下。\n\n### 安装\n\n```groovy\nallprojects {\n\t\trepositories {\n\t\t\tmaven { url 'https://jitpack.io' }\n\t\t}\n\t}\n```\n```groovy\ndependencies {\n    compile 'com.github.fly7632785:KotprefEncryptSupport:1.0.1'\n}\n```\n\n### 初始化\n\n它已经包含了gson-support，所以，如果使用了这个库，就不用再接入gson-support了\n```kotlin\nclass SampleApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        Kotpref.init(applicationContext)\n        // add Encrypt Support \n        Kotpref.gson = Gson()\n        Kotpref.cipherAdapter = SharedPrefCipherAdapter(applicationContext)\n    }\n}\n```\n### 申明使用\n```\n    var password by ecStringPref(\"jafirPass\")\n    var code1 by ecNullableStringPref()\n    var isMan by ecBooleanPref(true)\n    var age1 by ecIntPref(23)\n    var highScore1 by ecLongPref(1111111111L)\n    var rate1 by ecFloatPref(0.5555f)\n    var person1 by ecGsonPref(Person(\"g jafir\", 21))\n    var avatar21 by ecGsonPref(Avatar())\n    var avatar22 by ecGsonNullablePref(Avatar())\n```\n支持 Int,String,Boolean,Long,Float,Gson\n###  高级\n\n如果你想自定义加密规则，也是可以的。\n只需要自己实现一下CipherAdapter，然后实现一下encrypt和decrypt两个方法就可以了。例如\n\n```\nclass SharedPrefCipherAdapter @Throws(Exception::class)\nconstructor(context: Context) : CipherAdapter {\n    private val secretKey: SecretKey\n\n    init {\n        this.secretKey = AESUtil.generateKey(context)\n    }\n\n    override fun encrypt(raw: String): String {\n        return AESUtil.execEncrypted(secretKey, raw)\n    }\n\n    override fun decrypt(encode: String): String {\n        return AESUtil.execDecrypted(secretKey, encode)\n    }\n}\n```\n更多的细节可以看源码\n\n\n#### 默认的加密\n库中已经集成了一个默认的加密adapter：SharedPrefCipherAdapter\n采用的是AES、PBE混合的加密方式，AES加密内容，然后PBE加密secret key\n#### Xml\n```xml\n<map>\n    <long name=\"highScore\" value=\"3901\" />\n    <float name=\"rate\" value=\"0.4\" />\n    <string name=\"password\">WUb7wV8SS18d9hEvUt8kPg==&#10;    </string>\n    <string name=\"age1\">vELsGwmt5Bhz1WkAuasEHA==&#10;    </string>\n    <string name=\"avatar22\">rN29eRFNgIlf6yIAV9cptoyabAkqmDqDtf6S4ElzPWIVS1YRMXw2avvYbyJseOZEOBqVE9kAAARV&#10;T4MpZ31fAw==&#10;    </string>\n    <string name=\"avatar1\">null</string>\n    <string name=\"avatar21\">rN29eRFNgIlf6yIAV9cpttcgywAfWQ9P21mqhkpLjhty0xyusdIZtGLibaD5gzdExLQhyLF2BbIR&#10;Vz7hM0a0KA==&#10;    </string>\n    <string name=\"avatar\">{&quot;icon&quot;:&quot;lion&quot;,&quot;updated_at&quot;:&quot;Dec 19, 2017 11:13:28 PM&quot;}</string>\n    <string name=\"person1\">gA4aAC4rCqoo9Vz3VCBgVtnerDMep/WhMsoUK736qJ4=&#10;    </string>\n    <string name=\"code\">451B65F6-EF95-4C2C-AE76-D34535F51B3B</string>\n    <string name=\"isMan\">gi8S6qu7Sklcx0oiYDGnsw==&#10;    </string>\n    <set name=\"prizes\">\n        <string>New Born</string>\n    </set>\n    <int name=\"age\" value=\"2\" />\n    <string name=\"highScore1\">L5E9zu5NO5AQGFVZBmmHTA==&#10;    </string>\n    <string name=\"name\">chibatching Jr</string>\n    <string name=\"rate1\">Pa0WPZj6Of7DV8S4LYfp2g==&#10;    </string>\n    <string name=\"code1\">FZbcxuspUwL0HUdYvuQ6ltT/nWL+e5d3ZXtfTfPXGcccThyKavFb+7iB1bR8PGF6&#10;    </string>\n    <string name=\"gameLevel\">EASY</string>\n</map>\n\n```\n","slug":"Kotlin-KotprefEncryptSupport加密sharepreference","published":1,"updated":"2018-01-21T04:44:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcozqjuc00000cuskfuux868","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在学习kotlin，发现一个比较不错的sharepreference库<a href=\"https://github.com/chibatching/Kotpref\" target=\"_blank\" rel=\"noopener\">kotpref</a>。<br>它是利用kotlin的扩展和代理来实现的，使用起来也方便快捷。<br>但是，就是还差一个想要的功能，就是加密。<br>然后自己写了个<a href=\"https://github.com/fly7632785/KotprefEncryptSupport\" target=\"_blank\" rel=\"noopener\">KotprefEncryptSupport</a>来支持一下。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">\t\trepositories &#123;</span><br><span class=\"line\">\t\t\tmaven &#123; url <span class=\"string\">'https://jitpack.io'</span> &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">'com.github.fly7632785:KotprefEncryptSupport:1.0.1'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>它已经包含了gson-support，所以，如果使用了这个库，就不用再接入gson-support了<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> : <span class=\"type\">Application</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate()</span><br><span class=\"line\">        Kotpref.init(applicationContext)</span><br><span class=\"line\">        <span class=\"comment\">// add Encrypt Support </span></span><br><span class=\"line\">        Kotpref.gson = Gson()</span><br><span class=\"line\">        Kotpref.cipherAdapter = SharedPrefCipherAdapter(applicationContext)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"申明使用\"><a href=\"#申明使用\" class=\"headerlink\" title=\"申明使用\"></a>申明使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var password by ecStringPref(&quot;jafirPass&quot;)</span><br><span class=\"line\">var code1 by ecNullableStringPref()</span><br><span class=\"line\">var isMan by ecBooleanPref(true)</span><br><span class=\"line\">var age1 by ecIntPref(23)</span><br><span class=\"line\">var highScore1 by ecLongPref(1111111111L)</span><br><span class=\"line\">var rate1 by ecFloatPref(0.5555f)</span><br><span class=\"line\">var person1 by ecGsonPref(Person(&quot;g jafir&quot;, 21))</span><br><span class=\"line\">var avatar21 by ecGsonPref(Avatar())</span><br><span class=\"line\">var avatar22 by ecGsonNullablePref(Avatar())</span><br></pre></td></tr></table></figure>\n<p>支持 Int,String,Boolean,Long,Float,Gson</p>\n<h3 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h3><p>如果你想自定义加密规则，也是可以的。<br>只需要自己实现一下CipherAdapter，然后实现一下encrypt和decrypt两个方法就可以了。例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SharedPrefCipherAdapter @Throws(Exception::class)</span><br><span class=\"line\">constructor(context: Context) : CipherAdapter &#123;</span><br><span class=\"line\">    private val secretKey: SecretKey</span><br><span class=\"line\"></span><br><span class=\"line\">    init &#123;</span><br><span class=\"line\">        this.secretKey = AESUtil.generateKey(context)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun encrypt(raw: String): String &#123;</span><br><span class=\"line\">        return AESUtil.execEncrypted(secretKey, raw)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun decrypt(encode: String): String &#123;</span><br><span class=\"line\">        return AESUtil.execDecrypted(secretKey, encode)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多的细节可以看源码</p>\n<h4 id=\"默认的加密\"><a href=\"#默认的加密\" class=\"headerlink\" title=\"默认的加密\"></a>默认的加密</h4><p>库中已经集成了一个默认的加密adapter：SharedPrefCipherAdapter<br>采用的是AES、PBE混合的加密方式，AES加密内容，然后PBE加密secret key</p>\n<h4 id=\"Xml\"><a href=\"#Xml\" class=\"headerlink\" title=\"Xml\"></a>Xml</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">long</span> <span class=\"attr\">name</span>=<span class=\"string\">\"highScore\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"3901\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">float</span> <span class=\"attr\">name</span>=<span class=\"string\">\"rate\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"0.4\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span>WUb7wV8SS18d9hEvUt8kPg==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age1\"</span>&gt;</span>vELsGwmt5Bhz1WkAuasEHA==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar22\"</span>&gt;</span>rN29eRFNgIlf6yIAV9cptoyabAkqmDqDtf6S4ElzPWIVS1YRMXw2avvYbyJseOZEOBqVE9kAAARV&amp;#10;T4MpZ31fAw==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar1\"</span>&gt;</span>null<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar21\"</span>&gt;</span>rN29eRFNgIlf6yIAV9cpttcgywAfWQ9P21mqhkpLjhty0xyusdIZtGLibaD5gzdExLQhyLF2BbIR&amp;#10;Vz7hM0a0KA==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar\"</span>&gt;</span>&#123;&amp;quot;icon&amp;quot;:&amp;quot;lion&amp;quot;,&amp;quot;updated_at&amp;quot;:&amp;quot;Dec 19, 2017 11:13:28 PM&amp;quot;&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"person1\"</span>&gt;</span>gA4aAC4rCqoo9Vz3VCBgVtnerDMep/WhMsoUK736qJ4=&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"code\"</span>&gt;</span>451B65F6-EF95-4C2C-AE76-D34535F51B3B<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"isMan\"</span>&gt;</span>gi8S6qu7Sklcx0oiYDGnsw==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">set</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prizes\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>New Born<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"highScore1\"</span>&gt;</span>L5E9zu5NO5AQGFVZBmmHTA==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span>&gt;</span>chibatching Jr<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"rate1\"</span>&gt;</span>Pa0WPZj6Of7DV8S4LYfp2g==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"code1\"</span>&gt;</span>FZbcxuspUwL0HUdYvuQ6ltT/nWL+e5d3ZXtfTfPXGcccThyKavFb+7iB1bR8PGF6&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"gameLevel\"</span>&gt;</span>EASY<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在学习kotlin，发现一个比较不错的sharepreference库<a href=\"https://github.com/chibatching/Kotpref\" target=\"_blank\" rel=\"noopener\">kotpref</a>。<br>它是利用kotlin的扩展和代理来实现的，使用起来也方便快捷。<br>但是，就是还差一个想要的功能，就是加密。<br>然后自己写了个<a href=\"https://github.com/fly7632785/KotprefEncryptSupport\" target=\"_blank\" rel=\"noopener\">KotprefEncryptSupport</a>来支持一下。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">\t\trepositories &#123;</span><br><span class=\"line\">\t\t\tmaven &#123; url <span class=\"string\">'https://jitpack.io'</span> &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">'com.github.fly7632785:KotprefEncryptSupport:1.0.1'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>它已经包含了gson-support，所以，如果使用了这个库，就不用再接入gson-support了<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApplication</span> : <span class=\"type\">Application</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate()</span><br><span class=\"line\">        Kotpref.init(applicationContext)</span><br><span class=\"line\">        <span class=\"comment\">// add Encrypt Support </span></span><br><span class=\"line\">        Kotpref.gson = Gson()</span><br><span class=\"line\">        Kotpref.cipherAdapter = SharedPrefCipherAdapter(applicationContext)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"申明使用\"><a href=\"#申明使用\" class=\"headerlink\" title=\"申明使用\"></a>申明使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var password by ecStringPref(&quot;jafirPass&quot;)</span><br><span class=\"line\">var code1 by ecNullableStringPref()</span><br><span class=\"line\">var isMan by ecBooleanPref(true)</span><br><span class=\"line\">var age1 by ecIntPref(23)</span><br><span class=\"line\">var highScore1 by ecLongPref(1111111111L)</span><br><span class=\"line\">var rate1 by ecFloatPref(0.5555f)</span><br><span class=\"line\">var person1 by ecGsonPref(Person(&quot;g jafir&quot;, 21))</span><br><span class=\"line\">var avatar21 by ecGsonPref(Avatar())</span><br><span class=\"line\">var avatar22 by ecGsonNullablePref(Avatar())</span><br></pre></td></tr></table></figure>\n<p>支持 Int,String,Boolean,Long,Float,Gson</p>\n<h3 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h3><p>如果你想自定义加密规则，也是可以的。<br>只需要自己实现一下CipherAdapter，然后实现一下encrypt和decrypt两个方法就可以了。例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SharedPrefCipherAdapter @Throws(Exception::class)</span><br><span class=\"line\">constructor(context: Context) : CipherAdapter &#123;</span><br><span class=\"line\">    private val secretKey: SecretKey</span><br><span class=\"line\"></span><br><span class=\"line\">    init &#123;</span><br><span class=\"line\">        this.secretKey = AESUtil.generateKey(context)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun encrypt(raw: String): String &#123;</span><br><span class=\"line\">        return AESUtil.execEncrypted(secretKey, raw)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override fun decrypt(encode: String): String &#123;</span><br><span class=\"line\">        return AESUtil.execDecrypted(secretKey, encode)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多的细节可以看源码</p>\n<h4 id=\"默认的加密\"><a href=\"#默认的加密\" class=\"headerlink\" title=\"默认的加密\"></a>默认的加密</h4><p>库中已经集成了一个默认的加密adapter：SharedPrefCipherAdapter<br>采用的是AES、PBE混合的加密方式，AES加密内容，然后PBE加密secret key</p>\n<h4 id=\"Xml\"><a href=\"#Xml\" class=\"headerlink\" title=\"Xml\"></a>Xml</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">long</span> <span class=\"attr\">name</span>=<span class=\"string\">\"highScore\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"3901\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">float</span> <span class=\"attr\">name</span>=<span class=\"string\">\"rate\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"0.4\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span>WUb7wV8SS18d9hEvUt8kPg==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age1\"</span>&gt;</span>vELsGwmt5Bhz1WkAuasEHA==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar22\"</span>&gt;</span>rN29eRFNgIlf6yIAV9cptoyabAkqmDqDtf6S4ElzPWIVS1YRMXw2avvYbyJseOZEOBqVE9kAAARV&amp;#10;T4MpZ31fAw==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar1\"</span>&gt;</span>null<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar21\"</span>&gt;</span>rN29eRFNgIlf6yIAV9cpttcgywAfWQ9P21mqhkpLjhty0xyusdIZtGLibaD5gzdExLQhyLF2BbIR&amp;#10;Vz7hM0a0KA==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"avatar\"</span>&gt;</span>&#123;&amp;quot;icon&amp;quot;:&amp;quot;lion&amp;quot;,&amp;quot;updated_at&amp;quot;:&amp;quot;Dec 19, 2017 11:13:28 PM&amp;quot;&#125;<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"person1\"</span>&gt;</span>gA4aAC4rCqoo9Vz3VCBgVtnerDMep/WhMsoUK736qJ4=&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"code\"</span>&gt;</span>451B65F6-EF95-4C2C-AE76-D34535F51B3B<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"isMan\"</span>&gt;</span>gi8S6qu7Sklcx0oiYDGnsw==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">set</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prizes\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>New Born<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"highScore1\"</span>&gt;</span>L5E9zu5NO5AQGFVZBmmHTA==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span>&gt;</span>chibatching Jr<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"rate1\"</span>&gt;</span>Pa0WPZj6Of7DV8S4LYfp2g==&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"code1\"</span>&gt;</span>FZbcxuspUwL0HUdYvuQ6ltT/nWL+e5d3ZXtfTfPXGcccThyKavFb+7iB1bR8PGF6&amp;#10;    <span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">\"gameLevel\"</span>&gt;</span>EASY<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br></pre></td></tr></table></figure>\n"},{"layout":"android","title":"android OTG 读取usb设备文件并上传（问题解决）","date":"2018-01-21T04:31:46.000Z","_content":"### 前言\n有一个需求：**Android otg连接usb设备（一个带SD卡的可穿戴相机），并读取其内存中的文件上传到网络**\n\n### 问题\n这个需求最大的难点在于读取usb设备中的文件，并且由于我们上传的API接口要求是以File为参数上传文件。而Android提供的是很低级别的API，以bulk transfer的方式来传输数据字节流的。\n\n### 知识要点\n###### OTG \nOn the Go ，主要用于usb和不同的移动设备之间的连接和数据交换，就是用于连接类似手机等移动设备和USB设备的。\n###### 文件系统类型\n常见的文件系统类型有fat12 、fat16、fat32、ntfs 、hfs(苹果的)等，fat16只支持2GB一下的存储，fat32支持最多32G，但是单个文件不能超过4G，ntfs就可以支持单个文件4G以上\n###### MBR\n主引导记录，就是相当于磁盘的一个信息梗概，包含了有多少个分区，分区的文件系统类型是啥，有大大，逻辑地址区间是多少等等，512字节，446之后的每16个为一个分区表项，每个分区表项的第5位就是表明分区的文件系统类型\n\n![MBR组织](http://upload-images.jianshu.io/upload_images/1311457-9c5b3a11bd46d113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n\n![文件系统标志位](http://upload-images.jianshu.io/upload_images/1311457-d2cf549ae7d4939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n###### GPT\n比MBR高级的一个分区表，主要是由于MBR最大支持2TB磁盘，4个分区，而GPT就支持更多，且兼容MBR。现在多数电脑硬盘都是GPT的\n\n### 探索\n我们需要一个文件系统的支持，于是在GitHub上面搜罗了一遍，最终找到一个框架[Libaums](https://github.com/magnusja/libaums)。\n\n###### Libaums\n- 这是一个超级棒的库，并且作者也是非常棒，很有耐心和我一起测试调查问题\n- 支持otg连接手机读取USB mass storage devices , 并且是在Android Usb Host API的基础上增加了对于FAT32文件系统类型设备的支持，这才使得我们可以通过访问类似文件树的文件路径来访问其文件目录。\n- 以UsbFile来表明一个文件，但是没有办法从UsbFile直接获取一个实际的挂载路径（**因为Android为了各自应用的文件安全，希望我们使用FileProvider来进行应用间文件共享。并且，虽然Android是基于linux内核的，但是Android不支持直接读取挂载的usb的文件**）\n- Libaums 也是基于Android Api基础写的，所以符合Android的系统要求，所以集成的时候也需要在Manifest中配置<provider>\n- UsbFile 不可以直接获取文件路径来让我们操作File，而是提供一个UsbFileInputStream类来读取UsbFile的输出流，我们可以通过流来获取文件对象。\n\n\n### 开发\n由于Libaums和Android自身系统不支持，我们只好把Usb设备里面的文件以流的形式读取，并且写入到手机中保存为File文件（copy到手机中），然后再上传。最后，删除手机中的copy文件。\n\n### 问题来了\n一切在U盘上测试都是好好的，但是一到了Usb设备上测试，就出现问题了。\n代码中表示getPartition为空，所以没法读取到设备文件。为什么partition为空呢？\n\n### 解决\n在issue上跟作者交流了很久，并且自己也不断的测试。\n最后才弄明白怎么回事。\nUsb设备是一个科涵公司的相机，带SD卡，拍了照也就存储到了SD卡里面了。\npartition是分区的意思，Libaums支持带有MBR分区和文件系统类型为FAT32的设备读取。\n此命令``` diskutil list```可以查看一下电脑上挂在的usb设备的路径\n\n```\nbin-no-MBP:Volumes bingao$ diskutil list\n/dev/disk0 (internal, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *251.0 GB   disk0\n   1:                        EFI EFI                     209.7 MB   disk0s1\n   2:          Apple_CoreStorage Macintosh HD            250.1 GB   disk0s2\n   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3\n\n/dev/disk1 (internal, virtual):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:                  Apple_HFS Macintosh HD           +249.8 GB   disk1\n                                 Logical Volume on disk0s2\n                                 8ABB2546-043F-4E17-A20A-8EECAB36BE00\n                                 Unlocked Encrypted\n\n/dev/disk2 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:                            NO NAME                *31.9 GB    disk2\n\n```\n而经过测试这个设备MBR分区有问题，利用linux命令 \n```hexdump -C -s 446 -n 64 /dev/disk2```发现都是0\n\n```\nbin-no-MBP:Volumes bingao$ sudo hexdump -C -s 446 -n 64 /dev/disk2\n000001be  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001fe\n```\n\n**原来**：现在有很多SD卡或者储存设备为了节约内存，所以连512的MBR sector都给去掉了。\n\n![网上资料](http://upload-images.jianshu.io/upload_images/1311457-1c5850838685198b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n 最后在磁盘工具中擦除之后重新format才得以解决。\n![利用磁盘工具擦除数据重新format](http://upload-images.jianshu.io/upload_images/1311457-36772f6052e2d7ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n详情可见\n[Libaums Uri to file path or usbFile to File](https://github.com/magnusja/libaums/issues/70)\n[Libaums Investigate on SD card issues](https://github.com/magnusja/libaums/issues/86)\n\n\n### PS\n\n![分区表项中的第5位代表其文件系统类型\n这是文件类型对照表\n](http://upload-images.jianshu.io/upload_images/1311457-08be5fae058040a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n另外mac上面的第三方磁盘工具很多都是收费的，在网上搜罗了半天，找到一个很不错的工具[Hard DIsk Manager](https://www.paragon-software.com/home/hdm-mac/)，最主要是因为它可以10天免费trial，有很多的功能\n\n![[Hard DIsk Manager](https://www.paragon-software.com/home/hdm-mac/)](http://upload-images.jianshu.io/upload_images/1311457-c6e5564b344b4b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 总结\n此篇文章旨在整理记录我所遇到的问题，及其在调查解决问题期间收获的东西，也顺便给一些有类似需求的朋友提供一些思路。\n","source":"_posts/android-OTG-读取usb设备文件并上传（问题解决）.md","raw":"layout: android\ntitle: android OTG 读取usb设备文件并上传（问题解决）\ndate: 2018-01-21 12:31:46\ntags: android\n---\n### 前言\n有一个需求：**Android otg连接usb设备（一个带SD卡的可穿戴相机），并读取其内存中的文件上传到网络**\n\n### 问题\n这个需求最大的难点在于读取usb设备中的文件，并且由于我们上传的API接口要求是以File为参数上传文件。而Android提供的是很低级别的API，以bulk transfer的方式来传输数据字节流的。\n\n### 知识要点\n###### OTG \nOn the Go ，主要用于usb和不同的移动设备之间的连接和数据交换，就是用于连接类似手机等移动设备和USB设备的。\n###### 文件系统类型\n常见的文件系统类型有fat12 、fat16、fat32、ntfs 、hfs(苹果的)等，fat16只支持2GB一下的存储，fat32支持最多32G，但是单个文件不能超过4G，ntfs就可以支持单个文件4G以上\n###### MBR\n主引导记录，就是相当于磁盘的一个信息梗概，包含了有多少个分区，分区的文件系统类型是啥，有大大，逻辑地址区间是多少等等，512字节，446之后的每16个为一个分区表项，每个分区表项的第5位就是表明分区的文件系统类型\n\n![MBR组织](http://upload-images.jianshu.io/upload_images/1311457-9c5b3a11bd46d113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n\n![文件系统标志位](http://upload-images.jianshu.io/upload_images/1311457-d2cf549ae7d4939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n###### GPT\n比MBR高级的一个分区表，主要是由于MBR最大支持2TB磁盘，4个分区，而GPT就支持更多，且兼容MBR。现在多数电脑硬盘都是GPT的\n\n### 探索\n我们需要一个文件系统的支持，于是在GitHub上面搜罗了一遍，最终找到一个框架[Libaums](https://github.com/magnusja/libaums)。\n\n###### Libaums\n- 这是一个超级棒的库，并且作者也是非常棒，很有耐心和我一起测试调查问题\n- 支持otg连接手机读取USB mass storage devices , 并且是在Android Usb Host API的基础上增加了对于FAT32文件系统类型设备的支持，这才使得我们可以通过访问类似文件树的文件路径来访问其文件目录。\n- 以UsbFile来表明一个文件，但是没有办法从UsbFile直接获取一个实际的挂载路径（**因为Android为了各自应用的文件安全，希望我们使用FileProvider来进行应用间文件共享。并且，虽然Android是基于linux内核的，但是Android不支持直接读取挂载的usb的文件**）\n- Libaums 也是基于Android Api基础写的，所以符合Android的系统要求，所以集成的时候也需要在Manifest中配置<provider>\n- UsbFile 不可以直接获取文件路径来让我们操作File，而是提供一个UsbFileInputStream类来读取UsbFile的输出流，我们可以通过流来获取文件对象。\n\n\n### 开发\n由于Libaums和Android自身系统不支持，我们只好把Usb设备里面的文件以流的形式读取，并且写入到手机中保存为File文件（copy到手机中），然后再上传。最后，删除手机中的copy文件。\n\n### 问题来了\n一切在U盘上测试都是好好的，但是一到了Usb设备上测试，就出现问题了。\n代码中表示getPartition为空，所以没法读取到设备文件。为什么partition为空呢？\n\n### 解决\n在issue上跟作者交流了很久，并且自己也不断的测试。\n最后才弄明白怎么回事。\nUsb设备是一个科涵公司的相机，带SD卡，拍了照也就存储到了SD卡里面了。\npartition是分区的意思，Libaums支持带有MBR分区和文件系统类型为FAT32的设备读取。\n此命令``` diskutil list```可以查看一下电脑上挂在的usb设备的路径\n\n```\nbin-no-MBP:Volumes bingao$ diskutil list\n/dev/disk0 (internal, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *251.0 GB   disk0\n   1:                        EFI EFI                     209.7 MB   disk0s1\n   2:          Apple_CoreStorage Macintosh HD            250.1 GB   disk0s2\n   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3\n\n/dev/disk1 (internal, virtual):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:                  Apple_HFS Macintosh HD           +249.8 GB   disk1\n                                 Logical Volume on disk0s2\n                                 8ABB2546-043F-4E17-A20A-8EECAB36BE00\n                                 Unlocked Encrypted\n\n/dev/disk2 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:                            NO NAME                *31.9 GB    disk2\n\n```\n而经过测试这个设备MBR分区有问题，利用linux命令 \n```hexdump -C -s 446 -n 64 /dev/disk2```发现都是0\n\n```\nbin-no-MBP:Volumes bingao$ sudo hexdump -C -s 446 -n 64 /dev/disk2\n000001be  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001fe\n```\n\n**原来**：现在有很多SD卡或者储存设备为了节约内存，所以连512的MBR sector都给去掉了。\n\n![网上资料](http://upload-images.jianshu.io/upload_images/1311457-1c5850838685198b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n 最后在磁盘工具中擦除之后重新format才得以解决。\n![利用磁盘工具擦除数据重新format](http://upload-images.jianshu.io/upload_images/1311457-36772f6052e2d7ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n详情可见\n[Libaums Uri to file path or usbFile to File](https://github.com/magnusja/libaums/issues/70)\n[Libaums Investigate on SD card issues](https://github.com/magnusja/libaums/issues/86)\n\n\n### PS\n\n![分区表项中的第5位代表其文件系统类型\n这是文件类型对照表\n](http://upload-images.jianshu.io/upload_images/1311457-08be5fae058040a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n另外mac上面的第三方磁盘工具很多都是收费的，在网上搜罗了半天，找到一个很不错的工具[Hard DIsk Manager](https://www.paragon-software.com/home/hdm-mac/)，最主要是因为它可以10天免费trial，有很多的功能\n\n![[Hard DIsk Manager](https://www.paragon-software.com/home/hdm-mac/)](http://upload-images.jianshu.io/upload_images/1311457-c6e5564b344b4b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 总结\n此篇文章旨在整理记录我所遇到的问题，及其在调查解决问题期间收获的东西，也顺便给一些有类似需求的朋友提供一些思路。\n","slug":"android-OTG-读取usb设备文件并上传（问题解决）","published":1,"updated":"2018-01-21T05:07:52.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjui00010cusc98wy1za","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>有一个需求：<strong>Android otg连接usb设备（一个带SD卡的可穿戴相机），并读取其内存中的文件上传到网络</strong></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>这个需求最大的难点在于读取usb设备中的文件，并且由于我们上传的API接口要求是以File为参数上传文件。而Android提供的是很低级别的API，以bulk transfer的方式来传输数据字节流的。</p>\n<h3 id=\"知识要点\"><a href=\"#知识要点\" class=\"headerlink\" title=\"知识要点\"></a>知识要点</h3><h6 id=\"OTG\"><a href=\"#OTG\" class=\"headerlink\" title=\"OTG\"></a>OTG</h6><p>On the Go ，主要用于usb和不同的移动设备之间的连接和数据交换，就是用于连接类似手机等移动设备和USB设备的。</p>\n<h6 id=\"文件系统类型\"><a href=\"#文件系统类型\" class=\"headerlink\" title=\"文件系统类型\"></a>文件系统类型</h6><p>常见的文件系统类型有fat12 、fat16、fat32、ntfs 、hfs(苹果的)等，fat16只支持2GB一下的存储，fat32支持最多32G，但是单个文件不能超过4G，ntfs就可以支持单个文件4G以上</p>\n<h6 id=\"MBR\"><a href=\"#MBR\" class=\"headerlink\" title=\"MBR\"></a>MBR</h6><p>主引导记录，就是相当于磁盘的一个信息梗概，包含了有多少个分区，分区的文件系统类型是啥，有大大，逻辑地址区间是多少等等，512字节，446之后的每16个为一个分区表项，每个分区表项的第5位就是表明分区的文件系统类型</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9c5b3a11bd46d113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"MBR组织\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d2cf549ae7d4939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件系统标志位\"></p>\n<h6 id=\"GPT\"><a href=\"#GPT\" class=\"headerlink\" title=\"GPT\"></a>GPT</h6><p>比MBR高级的一个分区表，主要是由于MBR最大支持2TB磁盘，4个分区，而GPT就支持更多，且兼容MBR。现在多数电脑硬盘都是GPT的</p>\n<h3 id=\"探索\"><a href=\"#探索\" class=\"headerlink\" title=\"探索\"></a>探索</h3><p>我们需要一个文件系统的支持，于是在GitHub上面搜罗了一遍，最终找到一个框架<a href=\"https://github.com/magnusja/libaums\" target=\"_blank\" rel=\"noopener\">Libaums</a>。</p>\n<h6 id=\"Libaums\"><a href=\"#Libaums\" class=\"headerlink\" title=\"Libaums\"></a>Libaums</h6><ul>\n<li>这是一个超级棒的库，并且作者也是非常棒，很有耐心和我一起测试调查问题</li>\n<li>支持otg连接手机读取USB mass storage devices , 并且是在Android Usb Host API的基础上增加了对于FAT32文件系统类型设备的支持，这才使得我们可以通过访问类似文件树的文件路径来访问其文件目录。</li>\n<li>以UsbFile来表明一个文件，但是没有办法从UsbFile直接获取一个实际的挂载路径（<strong>因为Android为了各自应用的文件安全，希望我们使用FileProvider来进行应用间文件共享。并且，虽然Android是基于linux内核的，但是Android不支持直接读取挂载的usb的文件</strong>）</li>\n<li>Libaums 也是基于Android Api基础写的，所以符合Android的系统要求，所以集成的时候也需要在Manifest中配置<provider></provider></li>\n<li>UsbFile 不可以直接获取文件路径来让我们操作File，而是提供一个UsbFileInputStream类来读取UsbFile的输出流，我们可以通过流来获取文件对象。</li>\n</ul>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>由于Libaums和Android自身系统不支持，我们只好把Usb设备里面的文件以流的形式读取，并且写入到手机中保存为File文件（copy到手机中），然后再上传。最后，删除手机中的copy文件。</p>\n<h3 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h3><p>一切在U盘上测试都是好好的，但是一到了Usb设备上测试，就出现问题了。<br>代码中表示getPartition为空，所以没法读取到设备文件。为什么partition为空呢？</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>在issue上跟作者交流了很久，并且自己也不断的测试。<br>最后才弄明白怎么回事。<br>Usb设备是一个科涵公司的相机，带SD卡，拍了照也就存储到了SD卡里面了。<br>partition是分区的意思，Libaums支持带有MBR分区和文件系统类型为FAT32的设备读取。<br>此命令<figure class=\"highlight plain\"><figcaption><span>list```可以查看一下电脑上挂在的usb设备的路径</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>bin-no-MBP:Volumes bingao$ diskutil list<br>/dev/disk0 (internal, physical):</p>\n<p>   #:                       TYPE NAME                    SIZE       IDENTIFIER<br>   0:      GUID_partition_scheme                        *251.0 GB   disk0<br>   1:                        EFI EFI                     209.7 MB   disk0s1<br>   2:          Apple_CoreStorage Macintosh HD            250.1 GB   disk0s2<br>   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3</p>\n<p>/dev/disk1 (internal, virtual):</p>\n<p>   #:                       TYPE NAME                    SIZE       IDENTIFIER<br>   0:                  Apple_HFS Macintosh HD           +249.8 GB   disk1<br>                                 Logical Volume on disk0s2<br>                                 8ABB2546-043F-4E17-A20A-8EECAB36BE00<br>                                 Unlocked Encrypted</p>\n<p>/dev/disk2 (external, physical):</p>\n<p>   #:                       TYPE NAME                    SIZE       IDENTIFIER<br>   0:                            NO NAME                *31.9 GB    disk2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">而经过测试这个设备MBR分区有问题，利用linux命令 </span><br><span class=\"line\">```hexdump -C -s 446 -n 64 /dev/disk2```发现都是0</span><br></pre></td></tr></table></figure>\n<p>bin-no-MBP:Volumes bingao$ sudo hexdump -C -s 446 -n 64 /dev/disk2<br>000001be  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |…………….|<br>*<br>000001fe<br>```</p>\n<p><strong>原来</strong>：现在有很多SD卡或者储存设备为了节约内存，所以连512的MBR sector都给去掉了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1c5850838685198b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"网上资料\"></p>\n<p> 最后在磁盘工具中擦除之后重新format才得以解决。<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-36772f6052e2d7ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"利用磁盘工具擦除数据重新format\"></p>\n<p>详情可见<br><a href=\"https://github.com/magnusja/libaums/issues/70\" target=\"_blank\" rel=\"noopener\">Libaums Uri to file path or usbFile to File</a><br><a href=\"https://github.com/magnusja/libaums/issues/86\" target=\"_blank\" rel=\"noopener\">Libaums Investigate on SD card issues</a></p>\n<h3 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-08be5fae058040a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"分区表项中的第5位代表其文件系统类型\n这是文件类型对照表\n\"></p>\n<p>另外mac上面的第三方磁盘工具很多都是收费的，在网上搜罗了半天，找到一个很不错的工具<a href=\"https://www.paragon-software.com/home/hdm-mac/\" target=\"_blank\" rel=\"noopener\">Hard DIsk Manager</a>，最主要是因为它可以10天免费trial，有很多的功能</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-c6e5564b344b4b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"[Hard DIsk Manager](https://www.paragon-software.com/home/hdm-mac/)\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>此篇文章旨在整理记录我所遇到的问题，及其在调查解决问题期间收获的东西，也顺便给一些有类似需求的朋友提供一些思路。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>有一个需求：<strong>Android otg连接usb设备（一个带SD卡的可穿戴相机），并读取其内存中的文件上传到网络</strong></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>这个需求最大的难点在于读取usb设备中的文件，并且由于我们上传的API接口要求是以File为参数上传文件。而Android提供的是很低级别的API，以bulk transfer的方式来传输数据字节流的。</p>\n<h3 id=\"知识要点\"><a href=\"#知识要点\" class=\"headerlink\" title=\"知识要点\"></a>知识要点</h3><h6 id=\"OTG\"><a href=\"#OTG\" class=\"headerlink\" title=\"OTG\"></a>OTG</h6><p>On the Go ，主要用于usb和不同的移动设备之间的连接和数据交换，就是用于连接类似手机等移动设备和USB设备的。</p>\n<h6 id=\"文件系统类型\"><a href=\"#文件系统类型\" class=\"headerlink\" title=\"文件系统类型\"></a>文件系统类型</h6><p>常见的文件系统类型有fat12 、fat16、fat32、ntfs 、hfs(苹果的)等，fat16只支持2GB一下的存储，fat32支持最多32G，但是单个文件不能超过4G，ntfs就可以支持单个文件4G以上</p>\n<h6 id=\"MBR\"><a href=\"#MBR\" class=\"headerlink\" title=\"MBR\"></a>MBR</h6><p>主引导记录，就是相当于磁盘的一个信息梗概，包含了有多少个分区，分区的文件系统类型是啥，有大大，逻辑地址区间是多少等等，512字节，446之后的每16个为一个分区表项，每个分区表项的第5位就是表明分区的文件系统类型</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9c5b3a11bd46d113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"MBR组织\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d2cf549ae7d4939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件系统标志位\"></p>\n<h6 id=\"GPT\"><a href=\"#GPT\" class=\"headerlink\" title=\"GPT\"></a>GPT</h6><p>比MBR高级的一个分区表，主要是由于MBR最大支持2TB磁盘，4个分区，而GPT就支持更多，且兼容MBR。现在多数电脑硬盘都是GPT的</p>\n<h3 id=\"探索\"><a href=\"#探索\" class=\"headerlink\" title=\"探索\"></a>探索</h3><p>我们需要一个文件系统的支持，于是在GitHub上面搜罗了一遍，最终找到一个框架<a href=\"https://github.com/magnusja/libaums\" target=\"_blank\" rel=\"noopener\">Libaums</a>。</p>\n<h6 id=\"Libaums\"><a href=\"#Libaums\" class=\"headerlink\" title=\"Libaums\"></a>Libaums</h6><ul>\n<li>这是一个超级棒的库，并且作者也是非常棒，很有耐心和我一起测试调查问题</li>\n<li>支持otg连接手机读取USB mass storage devices , 并且是在Android Usb Host API的基础上增加了对于FAT32文件系统类型设备的支持，这才使得我们可以通过访问类似文件树的文件路径来访问其文件目录。</li>\n<li>以UsbFile来表明一个文件，但是没有办法从UsbFile直接获取一个实际的挂载路径（<strong>因为Android为了各自应用的文件安全，希望我们使用FileProvider来进行应用间文件共享。并且，虽然Android是基于linux内核的，但是Android不支持直接读取挂载的usb的文件</strong>）</li>\n<li>Libaums 也是基于Android Api基础写的，所以符合Android的系统要求，所以集成的时候也需要在Manifest中配置<provider></provider></li>\n<li>UsbFile 不可以直接获取文件路径来让我们操作File，而是提供一个UsbFileInputStream类来读取UsbFile的输出流，我们可以通过流来获取文件对象。</li>\n</ul>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>由于Libaums和Android自身系统不支持，我们只好把Usb设备里面的文件以流的形式读取，并且写入到手机中保存为File文件（copy到手机中），然后再上传。最后，删除手机中的copy文件。</p>\n<h3 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h3><p>一切在U盘上测试都是好好的，但是一到了Usb设备上测试，就出现问题了。<br>代码中表示getPartition为空，所以没法读取到设备文件。为什么partition为空呢？</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>在issue上跟作者交流了很久，并且自己也不断的测试。<br>最后才弄明白怎么回事。<br>Usb设备是一个科涵公司的相机，带SD卡，拍了照也就存储到了SD卡里面了。<br>partition是分区的意思，Libaums支持带有MBR分区和文件系统类型为FAT32的设备读取。<br>此命令<figure class=\"highlight plain\"><figcaption><span>list```可以查看一下电脑上挂在的usb设备的路径</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>bin-no-MBP:Volumes bingao$ diskutil list<br>/dev/disk0 (internal, physical):</p>\n<p>   #:                       TYPE NAME                    SIZE       IDENTIFIER<br>   0:      GUID_partition_scheme                        *251.0 GB   disk0<br>   1:                        EFI EFI                     209.7 MB   disk0s1<br>   2:          Apple_CoreStorage Macintosh HD            250.1 GB   disk0s2<br>   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3</p>\n<p>/dev/disk1 (internal, virtual):</p>\n<p>   #:                       TYPE NAME                    SIZE       IDENTIFIER<br>   0:                  Apple_HFS Macintosh HD           +249.8 GB   disk1<br>                                 Logical Volume on disk0s2<br>                                 8ABB2546-043F-4E17-A20A-8EECAB36BE00<br>                                 Unlocked Encrypted</p>\n<p>/dev/disk2 (external, physical):</p>\n<p>   #:                       TYPE NAME                    SIZE       IDENTIFIER<br>   0:                            NO NAME                *31.9 GB    disk2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">而经过测试这个设备MBR分区有问题，利用linux命令 </span><br><span class=\"line\">```hexdump -C -s 446 -n 64 /dev/disk2```发现都是0</span><br></pre></td></tr></table></figure>\n<p>bin-no-MBP:Volumes bingao$ sudo hexdump -C -s 446 -n 64 /dev/disk2<br>000001be  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |…………….|<br>*<br>000001fe<br>```</p>\n<p><strong>原来</strong>：现在有很多SD卡或者储存设备为了节约内存，所以连512的MBR sector都给去掉了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1c5850838685198b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"网上资料\"></p>\n<p> 最后在磁盘工具中擦除之后重新format才得以解决。<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-36772f6052e2d7ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"利用磁盘工具擦除数据重新format\"></p>\n<p>详情可见<br><a href=\"https://github.com/magnusja/libaums/issues/70\" target=\"_blank\" rel=\"noopener\">Libaums Uri to file path or usbFile to File</a><br><a href=\"https://github.com/magnusja/libaums/issues/86\" target=\"_blank\" rel=\"noopener\">Libaums Investigate on SD card issues</a></p>\n<h3 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-08be5fae058040a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"分区表项中的第5位代表其文件系统类型\n这是文件类型对照表\n\"></p>\n<p>另外mac上面的第三方磁盘工具很多都是收费的，在网上搜罗了半天，找到一个很不错的工具<a href=\"https://www.paragon-software.com/home/hdm-mac/\" target=\"_blank\" rel=\"noopener\">Hard DIsk Manager</a>，最主要是因为它可以10天免费trial，有很多的功能</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-c6e5564b344b4b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"[Hard DIsk Manager](https://www.paragon-software.com/home/hdm-mac/)\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>此篇文章旨在整理记录我所遇到的问题，及其在调查解决问题期间收获的东西，也顺便给一些有类似需求的朋友提供一些思路。</p>\n"},{"layout":"android","title":"Kotlin的Class、反射、泛型","date":"2018-01-21T04:36:14.000Z","_content":"### 前言\n最近在学习kotlin的反射的时候遇到了一些问题，特地记录一下。\n### 正题\n在Java中使用Class很常见的就是，xxx类.class，比如我们在startActivity的时候\n```java\nstartActivity(new Intent(this, OtherActivity.class));\n```\n这里接收的就是CLass<?> cls参数。\n那么在java中获取Class的方法有哪些呢？\n```\n1、Class c = person.getClass(); //对象获取\n2、Class cc =Person.class;//类获取\n```\n\n而我们来看看kotlin\n```\n//对象获取\nperson.javaClass// javaClass\nperson::class.java // javaClass\n//类获取\nPerson::class// kClass\n person.javaClass.kotlin// kClass\n(Person::class as Any).javaClass// javaClass\nPerson::class.java // javaClass\n```\n哇，这么多种，他们是不是一样的，有没有什么区别？\nlog看看他们到底是不是相同的Class\n```\nprintln(person.javaClass == person::class.java) //true\nprintln(person.javaClass == Person::class.java)//true\nprintln(person::class.java == Person::class.java)//true\n //person.javaClass == person::class.java == Person::class.java\nprintln(person.javaClass == Person::class)//false\nprintln(person.javaClass.kotlin == Person::class)//true\nprintln(person::class == Person::class)//true\n```\n从log来看，\n```\nperson.javaClass == person::class.java == Person::class.java\n```\n\n三者是相同的。但是\n```\nperson.javaClass == Person::class\n```\n却是不同的。为什么呢？\n\n原因是在kotlin中的Class与Java不同，kotlin中有一个自己的Class叫做KClass, ```person::class``` 和```Person::class```都是获取kotlin的KClass，所以```println(person::class == Person::class)``` 为true。\n我们可以从kotlin的KClass获取到java的Class,```person::class.java```就是如此，先获取到kotlin的KClass然后再获取javaClass。\n**object/class->kClass->Class**\n同样也可以通过java的Class获取kotlin的KClass，```person.javaClass.kotlin```就是先获取javaClass然后再获取kotlin的KClass\n**object/class->Class->KClass**\n那么KClass都有些什么用呢？Find Usages 可以看到\n![](http://upload-images.jianshu.io/upload_images/1311457-001add4c4ed4964f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n几乎多数跟Reflect相关，而用的最多的也是在**KClasses**里面\nKClasses扩展了许多跟反射相关的方法，算的上是kotlin的反射中类主力输出。\n![](http://upload-images.jianshu.io/upload_images/1311457-c3f64f8dac28f56e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果要使用kotlin的反射类的话，要加入\n```\n  compile \"org.jetbrains.kotlin:kotlin-reflect:$kotlin_version\"\n```\n![](http://upload-images.jianshu.io/upload_images/1311457-e7500755a2a391e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 举个例子\n我们要把一个类的所有字段通过反射给打印出来，调用java的方法来实现是这样\n```\n println (Person::class.java.declaredFields.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n我们通过Person::class拿到KClass，然后.java拿到java的Class<?>，再获取declaredFields，最后通过map，然后把获取的Field获取到值打印出来\n\n##### 问题\n而使用kotlin，我们还有别的做法\n```\n println (Person::class.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n通过Person::class拿到KClass，直接调用KClass的memberProperties来拿到KProperty的Collection集合，然后进行操作。当然，这里KProperty也是kotlin的反射类中的，也类似于Java的Field。\n那么既然可以这样，理论上这样也应该是可以的\n```\n//person是对象不是Person类\n println (person::class.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n这下却出错了，真的奇怪！\n```\nError:(73, 31) Out-projected type 'KProperty1<out OtherActivity.Person, Any?>' prohibits the use of 'public abstract fun get(receiver: T): R defined in kotlin.reflect.KProperty1'\n```\n为什么会这样？\n查看it发现\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2db8ddb0a9a501e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nkotlin的property的Person为out逆变的，R只能作为输出，不能作为get的参数传入，所报错了。\n这里的kotlin泛型还是有点小坑的需要你踩一踩，[网上有一篇文章解释说明了一番](https://www.qcloud.com/community/article/704805)\n\n\n那么怎么改呢？\n三种办法：\n-\n```\n//扩展KProperty的get方法为getUnsafed，其实就是去掉了out\n   fun <T, R> KProperty1<T, R>.getUnsafed(receiver: Any): R {\n        return get(receiver as T)\n    }\n//然后\nprintln(person::class.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.getUnsafed(person)}\"\n        }.joinToString(\",\"))\n```\n-\n```\n//强转一下\n println(person::class.memberProperties.map {\n            it.isAccessible = true\n            it as KProperty1<Person, Any>\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n-\n```\n//这一种就涉及到kotlin中的获取KClass的方式, 先获取java的Class再获取kotlin的KClass\n//神奇的是，这种获取到的it的类型没有out，而是我们期望的 KProperty1<Person, Any>\n println(person.javaClass.kotlin.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n\n### 最后\n在kotlin学习和探索的过程中发现了这些问题，非常地好奇，想要探知其原理。所以摸索着前进，希望能带给其他人一些学习的思路和兴趣。\n另外，还有一个问题就是：\n为什么有时候map的it是带out的有时候不带？这个跟class是java的class还是kotlin的class是否有关系？其间的原理和过程是怎么样的，我还在继续探索，希望明白的同学可以分享一下。","source":"_posts/android-Kotlin的Class、反射、泛型.md","raw":"layout: android\ntitle: Kotlin的Class、反射、泛型\ndate: 2018-01-21 12:36:14\ntags: kotlin\n---\n### 前言\n最近在学习kotlin的反射的时候遇到了一些问题，特地记录一下。\n### 正题\n在Java中使用Class很常见的就是，xxx类.class，比如我们在startActivity的时候\n```java\nstartActivity(new Intent(this, OtherActivity.class));\n```\n这里接收的就是CLass<?> cls参数。\n那么在java中获取Class的方法有哪些呢？\n```\n1、Class c = person.getClass(); //对象获取\n2、Class cc =Person.class;//类获取\n```\n\n而我们来看看kotlin\n```\n//对象获取\nperson.javaClass// javaClass\nperson::class.java // javaClass\n//类获取\nPerson::class// kClass\n person.javaClass.kotlin// kClass\n(Person::class as Any).javaClass// javaClass\nPerson::class.java // javaClass\n```\n哇，这么多种，他们是不是一样的，有没有什么区别？\nlog看看他们到底是不是相同的Class\n```\nprintln(person.javaClass == person::class.java) //true\nprintln(person.javaClass == Person::class.java)//true\nprintln(person::class.java == Person::class.java)//true\n //person.javaClass == person::class.java == Person::class.java\nprintln(person.javaClass == Person::class)//false\nprintln(person.javaClass.kotlin == Person::class)//true\nprintln(person::class == Person::class)//true\n```\n从log来看，\n```\nperson.javaClass == person::class.java == Person::class.java\n```\n\n三者是相同的。但是\n```\nperson.javaClass == Person::class\n```\n却是不同的。为什么呢？\n\n原因是在kotlin中的Class与Java不同，kotlin中有一个自己的Class叫做KClass, ```person::class``` 和```Person::class```都是获取kotlin的KClass，所以```println(person::class == Person::class)``` 为true。\n我们可以从kotlin的KClass获取到java的Class,```person::class.java```就是如此，先获取到kotlin的KClass然后再获取javaClass。\n**object/class->kClass->Class**\n同样也可以通过java的Class获取kotlin的KClass，```person.javaClass.kotlin```就是先获取javaClass然后再获取kotlin的KClass\n**object/class->Class->KClass**\n那么KClass都有些什么用呢？Find Usages 可以看到\n![](http://upload-images.jianshu.io/upload_images/1311457-001add4c4ed4964f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n几乎多数跟Reflect相关，而用的最多的也是在**KClasses**里面\nKClasses扩展了许多跟反射相关的方法，算的上是kotlin的反射中类主力输出。\n![](http://upload-images.jianshu.io/upload_images/1311457-c3f64f8dac28f56e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果要使用kotlin的反射类的话，要加入\n```\n  compile \"org.jetbrains.kotlin:kotlin-reflect:$kotlin_version\"\n```\n![](http://upload-images.jianshu.io/upload_images/1311457-e7500755a2a391e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 举个例子\n我们要把一个类的所有字段通过反射给打印出来，调用java的方法来实现是这样\n```\n println (Person::class.java.declaredFields.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n我们通过Person::class拿到KClass，然后.java拿到java的Class<?>，再获取declaredFields，最后通过map，然后把获取的Field获取到值打印出来\n\n##### 问题\n而使用kotlin，我们还有别的做法\n```\n println (Person::class.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n通过Person::class拿到KClass，直接调用KClass的memberProperties来拿到KProperty的Collection集合，然后进行操作。当然，这里KProperty也是kotlin的反射类中的，也类似于Java的Field。\n那么既然可以这样，理论上这样也应该是可以的\n```\n//person是对象不是Person类\n println (person::class.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n这下却出错了，真的奇怪！\n```\nError:(73, 31) Out-projected type 'KProperty1<out OtherActivity.Person, Any?>' prohibits the use of 'public abstract fun get(receiver: T): R defined in kotlin.reflect.KProperty1'\n```\n为什么会这样？\n查看it发现\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2db8ddb0a9a501e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nkotlin的property的Person为out逆变的，R只能作为输出，不能作为get的参数传入，所报错了。\n这里的kotlin泛型还是有点小坑的需要你踩一踩，[网上有一篇文章解释说明了一番](https://www.qcloud.com/community/article/704805)\n\n\n那么怎么改呢？\n三种办法：\n-\n```\n//扩展KProperty的get方法为getUnsafed，其实就是去掉了out\n   fun <T, R> KProperty1<T, R>.getUnsafed(receiver: Any): R {\n        return get(receiver as T)\n    }\n//然后\nprintln(person::class.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.getUnsafed(person)}\"\n        }.joinToString(\",\"))\n```\n-\n```\n//强转一下\n println(person::class.memberProperties.map {\n            it.isAccessible = true\n            it as KProperty1<Person, Any>\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n-\n```\n//这一种就涉及到kotlin中的获取KClass的方式, 先获取java的Class再获取kotlin的KClass\n//神奇的是，这种获取到的it的类型没有out，而是我们期望的 KProperty1<Person, Any>\n println(person.javaClass.kotlin.memberProperties.map {\n            it.isAccessible = true\n            \"${it.name}: ${it.get(person)}\"\n        }.joinToString(\",\"))\n```\n\n### 最后\n在kotlin学习和探索的过程中发现了这些问题，非常地好奇，想要探知其原理。所以摸索着前进，希望能带给其他人一些学习的思路和兴趣。\n另外，还有一个问题就是：\n为什么有时候map的it是带out的有时候不带？这个跟class是java的class还是kotlin的class是否有关系？其间的原理和过程是怎么样的，我还在继续探索，希望明白的同学可以分享一下。","slug":"android-Kotlin的Class、反射、泛型","published":1,"updated":"2018-01-21T13:25:31.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjur00030cusjcvbh5jk","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在学习kotlin的反射的时候遇到了一些问题，特地记录一下。</p>\n<h3 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h3><p>在Java中使用Class很常见的就是，xxx类.class，比如我们在startActivity的时候<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startActivity(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, OtherActivity.class));</span><br></pre></td></tr></table></figure></p>\n<p>这里接收的就是CLass&lt;?&gt; cls参数。<br>那么在java中获取Class的方法有哪些呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、Class c = person.getClass(); //对象获取</span><br><span class=\"line\">2、Class cc =Person.class;//类获取</span><br></pre></td></tr></table></figure></p>\n<p>而我们来看看kotlin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//对象获取</span><br><span class=\"line\">person.javaClass// javaClass</span><br><span class=\"line\">person::class.java // javaClass</span><br><span class=\"line\">//类获取</span><br><span class=\"line\">Person::class// kClass</span><br><span class=\"line\"> person.javaClass.kotlin// kClass</span><br><span class=\"line\">(Person::class as Any).javaClass// javaClass</span><br><span class=\"line\">Person::class.java // javaClass</span><br></pre></td></tr></table></figure></p>\n<p>哇，这么多种，他们是不是一样的，有没有什么区别？<br>log看看他们到底是不是相同的Class<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(person.javaClass == person::class.java) //true</span><br><span class=\"line\">println(person.javaClass == Person::class.java)//true</span><br><span class=\"line\">println(person::class.java == Person::class.java)//true</span><br><span class=\"line\"> //person.javaClass == person::class.java == Person::class.java</span><br><span class=\"line\">println(person.javaClass == Person::class)//false</span><br><span class=\"line\">println(person.javaClass.kotlin == Person::class)//true</span><br><span class=\"line\">println(person::class == Person::class)//true</span><br></pre></td></tr></table></figure></p>\n<p>从log来看，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.javaClass == person::class.java == Person::class.java</span><br></pre></td></tr></table></figure></p>\n<p>三者是相同的。但是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.javaClass == Person::class</span><br></pre></td></tr></table></figure></p>\n<p>却是不同的。为什么呢？</p>\n<p>原因是在kotlin中的Class与Java不同，kotlin中有一个自己的Class叫做KClass, <figure class=\"highlight plain\"><figcaption><span>和```Person::class```都是获取kotlin的KClass，所以```println(person::class </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们可以从kotlin的KClass获取到java的Class,```person::class.java```就是如此，先获取到kotlin的KClass然后再获取javaClass。</span><br><span class=\"line\">**object/class-&gt;kClass-&gt;Class**</span><br><span class=\"line\">同样也可以通过java的Class获取kotlin的KClass，```person.javaClass.kotlin```就是先获取javaClass然后再获取kotlin的KClass</span><br><span class=\"line\">**object/class-&gt;Class-&gt;KClass**</span><br><span class=\"line\">那么KClass都有些什么用呢？Find Usages 可以看到</span><br><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-001add4c4ed4964f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">几乎多数跟Reflect相关，而用的最多的也是在**KClasses**里面</span><br><span class=\"line\">KClasses扩展了许多跟反射相关的方法，算的上是kotlin的反射中类主力输出。</span><br><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-c3f64f8dac28f56e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">如果要使用kotlin的反射类的话，要加入</span><br></pre></td></tr></table></figure></p>\n<p>  compile “org.jetbrains.kotlin:kotlin-reflect:$kotlin_version”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-e7500755a2a391e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">##### 举个例子</span><br><span class=\"line\">我们要把一个类的所有字段通过反射给打印出来，调用java的方法来实现是这样</span><br></pre></td></tr></table></figure></p>\n<p> println (Person::class.java.declaredFields.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们通过Person::class拿到KClass，然后.java拿到java的Class&lt;?&gt;，再获取declaredFields，最后通过map，然后把获取的Field获取到值打印出来</span><br><span class=\"line\"></span><br><span class=\"line\">##### 问题</span><br><span class=\"line\">而使用kotlin，我们还有别的做法</span><br></pre></td></tr></table></figure></p>\n<p> println (Person::class.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过Person::class拿到KClass，直接调用KClass的memberProperties来拿到KProperty的Collection集合，然后进行操作。当然，这里KProperty也是kotlin的反射类中的，也类似于Java的Field。</span><br><span class=\"line\">那么既然可以这样，理论上这样也应该是可以的</span><br></pre></td></tr></table></figure></p>\n<p>//person是对象不是Person类<br> println (person::class.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这下却出错了，真的奇怪！</span><br></pre></td></tr></table></figure></p>\n<p>Error:(73, 31) Out-projected type ‘KProperty1<out otheractivity.person,=\"\" any?=\"\">‘ prohibits the use of ‘public abstract fun get(receiver: T): R defined in kotlin.reflect.KProperty1’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么会这样？</span><br><span class=\"line\">查看it发现</span><br><span class=\"line\"></span><br><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-2db8ddb0a9a501e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">kotlin的property的Person为out逆变的，R只能作为输出，不能作为get的参数传入，所报错了。</span><br><span class=\"line\">这里的kotlin泛型还是有点小坑的需要你踩一踩，[网上有一篇文章解释说明了一番](https://www.qcloud.com/community/article/704805)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">那么怎么改呢？</span><br><span class=\"line\">三种办法：</span><br><span class=\"line\">-</span><br></pre></td></tr></table></figure></out></p>\n<p>//扩展KProperty的get方法为getUnsafed，其实就是去掉了out<br>   fun <t, r=\"\"> KProperty1<t, r=\"\">.getUnsafed(receiver: Any): R {<br>        return get(receiver as T)<br>    }<br>//然后<br>println(person::class.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.getUnsafed(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-</span><br></pre></td></tr></table></figure></t,></t,></p>\n<p>//强转一下<br> println(person::class.memberProperties.map {<br>            it.isAccessible = true<br>            it as KProperty1<person, any=\"\"><br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-</span><br></pre></td></tr></table></figure></person,></p>\n<p>//这一种就涉及到kotlin中的获取KClass的方式, 先获取java的Class再获取kotlin的KClass<br>//神奇的是，这种获取到的it的类型没有out，而是我们期望的 KProperty1<person, any=\"\"><br> println(person.javaClass.kotlin.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br>```</person,></p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>在kotlin学习和探索的过程中发现了这些问题，非常地好奇，想要探知其原理。所以摸索着前进，希望能带给其他人一些学习的思路和兴趣。<br>另外，还有一个问题就是：<br>为什么有时候map的it是带out的有时候不带？这个跟class是java的class还是kotlin的class是否有关系？其间的原理和过程是怎么样的，我还在继续探索，希望明白的同学可以分享一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在学习kotlin的反射的时候遇到了一些问题，特地记录一下。</p>\n<h3 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h3><p>在Java中使用Class很常见的就是，xxx类.class，比如我们在startActivity的时候<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startActivity(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, OtherActivity.class));</span><br></pre></td></tr></table></figure></p>\n<p>这里接收的就是CLass&lt;?&gt; cls参数。<br>那么在java中获取Class的方法有哪些呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、Class c = person.getClass(); //对象获取</span><br><span class=\"line\">2、Class cc =Person.class;//类获取</span><br></pre></td></tr></table></figure></p>\n<p>而我们来看看kotlin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//对象获取</span><br><span class=\"line\">person.javaClass// javaClass</span><br><span class=\"line\">person::class.java // javaClass</span><br><span class=\"line\">//类获取</span><br><span class=\"line\">Person::class// kClass</span><br><span class=\"line\"> person.javaClass.kotlin// kClass</span><br><span class=\"line\">(Person::class as Any).javaClass// javaClass</span><br><span class=\"line\">Person::class.java // javaClass</span><br></pre></td></tr></table></figure></p>\n<p>哇，这么多种，他们是不是一样的，有没有什么区别？<br>log看看他们到底是不是相同的Class<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(person.javaClass == person::class.java) //true</span><br><span class=\"line\">println(person.javaClass == Person::class.java)//true</span><br><span class=\"line\">println(person::class.java == Person::class.java)//true</span><br><span class=\"line\"> //person.javaClass == person::class.java == Person::class.java</span><br><span class=\"line\">println(person.javaClass == Person::class)//false</span><br><span class=\"line\">println(person.javaClass.kotlin == Person::class)//true</span><br><span class=\"line\">println(person::class == Person::class)//true</span><br></pre></td></tr></table></figure></p>\n<p>从log来看，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.javaClass == person::class.java == Person::class.java</span><br></pre></td></tr></table></figure></p>\n<p>三者是相同的。但是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.javaClass == Person::class</span><br></pre></td></tr></table></figure></p>\n<p>却是不同的。为什么呢？</p>\n<p>原因是在kotlin中的Class与Java不同，kotlin中有一个自己的Class叫做KClass, <figure class=\"highlight plain\"><figcaption><span>和```Person::class```都是获取kotlin的KClass，所以```println(person::class </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们可以从kotlin的KClass获取到java的Class,```person::class.java```就是如此，先获取到kotlin的KClass然后再获取javaClass。</span><br><span class=\"line\">**object/class-&gt;kClass-&gt;Class**</span><br><span class=\"line\">同样也可以通过java的Class获取kotlin的KClass，```person.javaClass.kotlin```就是先获取javaClass然后再获取kotlin的KClass</span><br><span class=\"line\">**object/class-&gt;Class-&gt;KClass**</span><br><span class=\"line\">那么KClass都有些什么用呢？Find Usages 可以看到</span><br><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-001add4c4ed4964f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">几乎多数跟Reflect相关，而用的最多的也是在**KClasses**里面</span><br><span class=\"line\">KClasses扩展了许多跟反射相关的方法，算的上是kotlin的反射中类主力输出。</span><br><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-c3f64f8dac28f56e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">如果要使用kotlin的反射类的话，要加入</span><br></pre></td></tr></table></figure></p>\n<p>  compile “org.jetbrains.kotlin:kotlin-reflect:$kotlin_version”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-e7500755a2a391e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">##### 举个例子</span><br><span class=\"line\">我们要把一个类的所有字段通过反射给打印出来，调用java的方法来实现是这样</span><br></pre></td></tr></table></figure></p>\n<p> println (Person::class.java.declaredFields.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们通过Person::class拿到KClass，然后.java拿到java的Class&lt;?&gt;，再获取declaredFields，最后通过map，然后把获取的Field获取到值打印出来</span><br><span class=\"line\"></span><br><span class=\"line\">##### 问题</span><br><span class=\"line\">而使用kotlin，我们还有别的做法</span><br></pre></td></tr></table></figure></p>\n<p> println (Person::class.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过Person::class拿到KClass，直接调用KClass的memberProperties来拿到KProperty的Collection集合，然后进行操作。当然，这里KProperty也是kotlin的反射类中的，也类似于Java的Field。</span><br><span class=\"line\">那么既然可以这样，理论上这样也应该是可以的</span><br></pre></td></tr></table></figure></p>\n<p>//person是对象不是Person类<br> println (person::class.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这下却出错了，真的奇怪！</span><br></pre></td></tr></table></figure></p>\n<p>Error:(73, 31) Out-projected type ‘KProperty1<out otheractivity.person,=\"\" any?=\"\">‘ prohibits the use of ‘public abstract fun get(receiver: T): R defined in kotlin.reflect.KProperty1’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么会这样？</span><br><span class=\"line\">查看it发现</span><br><span class=\"line\"></span><br><span class=\"line\">![](http://upload-images.jianshu.io/upload_images/1311457-2db8ddb0a9a501e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">kotlin的property的Person为out逆变的，R只能作为输出，不能作为get的参数传入，所报错了。</span><br><span class=\"line\">这里的kotlin泛型还是有点小坑的需要你踩一踩，[网上有一篇文章解释说明了一番](https://www.qcloud.com/community/article/704805)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">那么怎么改呢？</span><br><span class=\"line\">三种办法：</span><br><span class=\"line\">-</span><br></pre></td></tr></table></figure></out></p>\n<p>//扩展KProperty的get方法为getUnsafed，其实就是去掉了out<br>   fun <t, r=\"\"> KProperty1<t, r=\"\">.getUnsafed(receiver: Any): R {<br>        return get(receiver as T)<br>    }<br>//然后<br>println(person::class.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.getUnsafed(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-</span><br></pre></td></tr></table></figure></t,></t,></p>\n<p>//强转一下<br> println(person::class.memberProperties.map {<br>            it.isAccessible = true<br>            it as KProperty1<person, any=\"\"><br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-</span><br></pre></td></tr></table></figure></person,></p>\n<p>//这一种就涉及到kotlin中的获取KClass的方式, 先获取java的Class再获取kotlin的KClass<br>//神奇的是，这种获取到的it的类型没有out，而是我们期望的 KProperty1<person, any=\"\"><br> println(person.javaClass.kotlin.memberProperties.map {<br>            it.isAccessible = true<br>            “${it.name}: ${it.get(person)}”<br>        }.joinToString(“,”))<br>```</person,></p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>在kotlin学习和探索的过程中发现了这些问题，非常地好奇，想要探知其原理。所以摸索着前进，希望能带给其他人一些学习的思路和兴趣。<br>另外，还有一个问题就是：<br>为什么有时候map的it是带out的有时候不带？这个跟class是java的class还是kotlin的class是否有关系？其间的原理和过程是怎么样的，我还在继续探索，希望明白的同学可以分享一下。</p>\n"},{"title":"Android MPAndroidChart 自适应Markerview","date":"2018-01-21T04:32:52.000Z","_content":"### 前言\nAndroid里面只要用过图表的应该都知道[MPAndroidChart](https://github.com/PhilJay/MPAndroidChart)这个库。这个库在iOS里面也有对应[Charts](https://github.com/danielgindi/Charts)，所以一般移动端做图表，Android和iOS两端都要实现同样的效果，他们是不错的一个选择。\n但是，对于图表这种包含的情况非常复杂的东西，很难满足大家各种各样的需求，所以很多都需要自定义。下面就是给大家分享一下自己写的自适应MarkerView。\n#### 先上图\n\n![正常居中显示](http://upload-images.jianshu.io/upload_images/1311457-d5d185af3b7037e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过左边界](http://upload-images.jianshu.io/upload_images/1311457-84f1f978ac4211b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过上边界](http://upload-images.jianshu.io/upload_images/1311457-faa4dd3a11715f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过右边界](http://upload-images.jianshu.io/upload_images/1311457-e2e240b518251db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过上边界和右边界](http://upload-images.jianshu.io/upload_images/1311457-6dcbf615e7957d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 正文\n要实现这样的效果，大家先想想怎么做？\n这里的逻辑步骤分为：\n1、创建新类继承自MarkerView\n2、inflate layout进去\n3、重写getOffsetForDrawingAtPoint ，分别处理各种边界情况的偏移\n4、重写draw，绘制底色，根据不同的情况，绘制带箭头的对话框\n\n##### 直接上代码\n```\npublic class XYMarkerView extends MarkerView {\n    public static final int ARROW_SIZE = 40; // 箭头的大小\n    private static final float CIRCLE_OFFSET = 10;//因为我这里的折点是圆圈，所以要偏移，防止直接指向了圆心\n    private static final float STOKE_WIDTH = 5;//这里对于stroke_width的宽度也要做一定偏移\n    private final TextView tvContent;\n    private final RoundImageView avatar;\n    private final TextView name;\n    private final List<StepListModel> stepListModels;\n    private int index;\n    private int oldIndex = -1;\n\n    public XYMarkerView(Context context, List<StepListModel> stepListModels) {\n        super(context, R.layout.custom_marker_view);\n        tvContent = (TextView) findViewById(R.id.tvContent);\n        avatar = (RoundImageView) findViewById(R.id.avatar);\n        name = (TextView) findViewById(R.id.name);\n        this.stepListModels = stepListModels;\n    }\n\n    @Override\n    public void refreshContent(Entry e, Highlight highlight) {\n        super.refreshContent(e, highlight);\n        index = highlight.getDataSetIndex();//这个方法用于获得折线是哪根\n        tvContent.setText((int) e.getY() + \"\");\n//            StepListModel stepListModel = stepListModels.get(highlight.getDataSetIndex() % Constants.battleUsersCount);\n//            name.setText(stepListModel.getNickNm());\n//            Glide.with(getContext())\n//                    .load(GlideUtil.getGlideUrl(stepListModel.getIconUrl()))\n//                    .into(avatar);\n        Glide.with(getContext())\n                .asBitmap()\n                .load(avatars[index % avatars.length])\n                .listener(new RequestListener<Bitmap>() {\n                    @Override\n                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Bitmap> target, boolean isFirstResource) {\n                        return false;\n                    }\n\n                    @Override\n                    public boolean onResourceReady(Bitmap resource, Object model, Target<Bitmap> target, DataSource dataSource, boolean isFirstResource) {\n                        if (resource != null) {\n                            if (oldIndex != index) {\n                                XYMarkerView.this.getChartView().invalidate();\n                                oldIndex = index;\n                            }\n                            avatar.setImageBitmap(resource);\n                        }\n                        return false;\n                    }\n                })\n                .into(avatar);\n        name.setText(highlight.getDataSetIndex() + \"\");\n        tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));\n        LogUtil.m(\"getDataSetIndex\" + highlight.getDataSetIndex());\n\n    }\n\n    @Override\n    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) {\n        MPPointF offset = getOffset();\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n// posY \\posX 指的是markerView左上角点在图表上面的位置\n//处理Y方向\n        if (posY <= height + ARROW_SIZE) {// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小\n            offset.y = ARROW_SIZE;\n        } else {//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框\n            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width\n        }\n//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边\n//\n        if (posX > chart.getWidth() - width) {//如果超过右边界，则向左偏移markerView的宽度\n            offset.x = -width;\n        } else {//默认情况，不偏移（因为是点是在左上角）\n            offset.x = 0;\n            if (posX > width / 2) {//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度\n                offset.x = -(width / 2);\n            }\n        }\n        return offset;\n    }\n\n    @Override\n    public void draw(Canvas canvas, float posX, float posY) {\n        Paint paint = new Paint();//绘制边框的画笔\n        paint.setStrokeWidth(STOKE_WIDTH);\n        paint.setStyle(Paint.Style.STROKE);\n        paint.setStrokeJoin(Paint.Join.ROUND);\n        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));\n\n        Paint whitePaint = new Paint();//绘制底色白色的画笔\n        whitePaint.setStyle(Paint.Style.FILL);\n        whitePaint.setColor(Color.WHITE);\n\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n\n        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n        int saveId = canvas.save();\n\n        Path path = new Path();\n        if (posY < height + ARROW_SIZE) {//处理超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            if (posX > chart.getWidth() - width) {//超过右边界\n                path.lineTo(width - ARROW_SIZE, 0);\n                path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);\n                path.lineTo(width, 0);\n            } else {\n                if (posX > width / 2) {//在图表中间\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0);\n                    path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0);\n                } else {//超过左边界\n                    path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(0 + ARROW_SIZE, 0);\n                }\n            }\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            path.lineTo(0, 0 + height);\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        } else {//没有超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            if (posX > chart.getWidth() - width) {\n                path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);\n                path.lineTo(width - ARROW_SIZE, 0 + height);\n                path.lineTo(0, 0 + height);\n            } else {\n                if (posX > width / 2) {\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(0, 0 + height);\n                } else {\n                    path.lineTo(0 + ARROW_SIZE, 0 + height);\n                    path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(0, 0 + height);\n                }\n            }\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        }\n\n        // translate to the correct position and draw\n        canvas.drawPath(path, whitePaint);\n        canvas.drawPath(path, paint);\n        canvas.translate(posX + offset.x, posY + offset.y);\n        draw(canvas);\n        canvas.restoreToCount(saveId);\n    }\n}\n```\n\n\n### 详细\n\n#####  不同颜色、头像等处理\n我这里的需求是根据不同的折线，显示不同的人物头像、名字和对应的值，并且对话框的颜色、字体都要对应折线的颜色。\n所以，我这里根据```highlight.getDataSetIndex() ```就能处理不同颜色、头像等信息的情况。\n```\n//类似这个\n name.setText(highlight.getDataSetIndex() + \"\");\n tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));\n```\n注意：\n这里有个地方要注意一下，这里如果你使用Glide来加载图片到ImageView里去，会出现第一次加载不出来头像，第二次点击的时候就加载出来了。\n原因 ：是因为其实glide已经加载出来了，然后只是异步加载出来之后，已经是在layout绘制完成之后了，并没有进行invalidate的刷新。所以直到第二次的时候，其实glide已经加载过了，有缓存，所以直接就显示了，发生在draw方法之前，因为refreshContent就在draw之前调用\n```\n\n            // callbacks to update the content\n            mMarker.refreshContent(e, highlight);\n\n            // draw the marker\n            mMarker.draw(canvas, pos[0], pos[1]);\n```\n我这里是直接在glide的onResourceReady里面调用chart的invalidate，但是这样的话会一直循环刷新了，卡死！\n所以，这里使用了一个oldIndex是否等于index来判断是否是已经invalidate，这样的话就只有点击不同的折线的时候会invalidate一次，之后就不会了。\n```\n  private int index;\n  private int oldIndex = -1;\n  ...\n  Glide.with(getContext())\n                .asBitmap()\n                .load(avatars[index % avatars.length])\n                .listener(new RequestListener<Bitmap>() {\n                    @Override\n                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Bitmap> target, boolean isFirstResource) {\n                        return false;\n                    }\n\n                    @Override\n                    public boolean onResourceReady(Bitmap resource, Object model, Target<Bitmap> target, DataSource dataSource, boolean isFirstResource) {\n                        if (resource != null) {\n                            if (oldIndex != index) {\n                                XYMarkerView.this.getChartView().invalidate();\n                                oldIndex = index;\n                            }\n                            avatar.setImageBitmap(resource);\n                        }\n                        return false;\n                    }\n                })\n                .into(avatar);\n```\n\n##### 边界情况的处理\nMarkerView的draw方法，里面有posX、posY，这个点坐标代表的是markerView的左上角的坐标（如果不偏移的情况下，官方的默认也是做了偏移处理的，但是还有不够完善）。\n\n\n![默认是在左上角的，像这样](http://upload-images.jianshu.io/upload_images/1311457-0fb26dedb2ee3beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```getOffsetForDrawingAtPoint```就是处理偏移的方法，最终应用是在draw里面，进行canvas的translate变换\n```\n @Override\n    public void draw(Canvas canvas, float posX, float posY) {\n\n        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n\n        int saveId = canvas.save();\n        // translate to the correct position and draw\n        canvas.translate(posX + offset.x, posY + offset.y);\n        draw(canvas);\n        canvas.restoreToCount(saveId);\n    }\n```\n下面是我对各种边界情况的处理\n```\n     @Override\n    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) {\n        MPPointF offset = getOffset();\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n// posY \\posX 指的是markerView左上角点在图表上面的位置\n//处理Y方向\n        if (posY <= height + ARROW_SIZE) {// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小\n            offset.y = ARROW_SIZE;\n        } else {//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框\n            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width\n        }\n//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边\n//\n        if (posX > chart.getWidth() - width) {//如果超过右边界，则向左偏移markerView的宽度\n            offset.x = -width;\n        } else {//默认情况，不偏移（因为是点是在左上角）\n            offset.x = 0;\n            if (posX > width / 2) {//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度\n                offset.x = -(width / 2);\n            }\n        }\n        return offset;\n    }\n```\n\n![处理左边界](http://upload-images.jianshu.io/upload_images/1311457-a9f533f780593dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![处理一般情况](http://upload-images.jianshu.io/upload_images/1311457-c786c8d1e97c52ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![处理上边界](http://upload-images.jianshu.io/upload_images/1311457-ca258b7c1f605dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![处理右边界](http://upload-images.jianshu.io/upload_images/1311457-61b9d9ab08f5a30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 对于各个箭头的处理\n实现这个对话框，主要是通过绘制path来实现的，箭头的处理也是根据不同的情况，进行不同的path绘制实现的。\n```\n @Override\n    public void draw(Canvas canvas, float posX, float posY) {\n        Paint paint = new Paint();//绘制边框的画笔\n        paint.setStrokeWidth(STOKE_WIDTH);\n        paint.setStyle(Paint.Style.STROKE);\n        paint.setStrokeJoin(Paint.Join.ROUND);\n        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));\n\n        Paint whitePaint = new Paint();//绘制底色白色的画笔\n        whitePaint.setStyle(Paint.Style.FILL);\n        whitePaint.setColor(Color.WHITE);\n\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n\n        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n        int saveId = canvas.save();\n\n        Path path = new Path();\n        if (posY < height + ARROW_SIZE) {//处理超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            if (posX > chart.getWidth() - width) {//超过右边界\n                path.lineTo(width - ARROW_SIZE, 0);\n                path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);\n                path.lineTo(width, 0);\n            } else {\n                if (posX > width / 2) {//在图表中间\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0);\n                    path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0);\n                } else {//超过左边界\n                    path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(0 + ARROW_SIZE, 0);\n                }\n            }\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            path.lineTo(0, 0 + height);\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        } else {//没有超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            if (posX > chart.getWidth() - width) {\n                path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);\n                path.lineTo(width - ARROW_SIZE, 0 + height);\n                path.lineTo(0, 0 + height);\n            } else {\n                if (posX > width / 2) {\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(0, 0 + height);\n                } else {\n                    path.lineTo(0 + ARROW_SIZE, 0 + height);\n                    path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(0, 0 + height);\n                }\n            }\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        }\n\n        // translate to the correct position and draw\n        canvas.drawPath(path, whitePaint);\n        canvas.drawPath(path, paint);\n        canvas.translate(posX + offset.x, posY + offset.y);\n        draw(canvas);\n        canvas.restoreToCount(saveId);\n    }\n```\n绘制MarkerView分为两部分，一部分是绘制对话框，一部分是绘制传入的R.layout.xx的view。\n\n\n![类似这样](http://upload-images.jianshu.io/upload_images/1311457-6955c8a84ac1ddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这里有一个问题，就是需要填充对话框白色，并且还要有边框。\n一个画笔是不够的，所以这里有两个画笔，一个是填充的，一个是画边框的。\n并且，是必须要先绘制对话框的底色，绘制对话框，再绘制传入的view\n```\n   Paint paint = new Paint();//绘制边框的画笔\n        paint.setStrokeWidth(STOKE_WIDTH);\n        paint.setStyle(Paint.Style.STROKE);\n        paint.setStrokeJoin(Paint.Join.ROUND);\n        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));\n\n        Paint whitePaint = new Paint();//绘制底色白色的画笔\n        whitePaint.setStyle(Paint.Style.FILL);\n        whitePaint.setColor(Color.WHITE);\n```\n```\n// 第一步        canvas.drawPath(path, whitePaint); \n// 第二步        canvas.drawPath(path, paint); \n                canvas.translate(posX + offset.x, posY + offset.y); \n// 第三步        draw(canvas);\n```\n因为我们的markerView偏移是对于canvas的偏移，但是我们的对话框的path并没有偏移，所以我们也要对path进行同样的偏移处理。很简单，直接获取偏移值，然后偏移就好。\n```\n   MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n  path.offset(posX + offset.x, posY + offset.y);\n```\n### 最后\n\n这样的最终效果就是传入的layout 被对话框包裹在里面了。\n\n![](http://upload-images.jianshu.io/upload_images/1311457-bfbfff71ab2aeb8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n箭头的绘制处理也比较简单，就是根据不同的情况来进行绘制就好，看代码吧。","source":"_posts/android-MPAndroidChart-自适应Markerview.md","raw":"---\ntitle: Android MPAndroidChart 自适应Markerview\ndate: 2018-01-21 12:32:52\ntags: android\n---\n### 前言\nAndroid里面只要用过图表的应该都知道[MPAndroidChart](https://github.com/PhilJay/MPAndroidChart)这个库。这个库在iOS里面也有对应[Charts](https://github.com/danielgindi/Charts)，所以一般移动端做图表，Android和iOS两端都要实现同样的效果，他们是不错的一个选择。\n但是，对于图表这种包含的情况非常复杂的东西，很难满足大家各种各样的需求，所以很多都需要自定义。下面就是给大家分享一下自己写的自适应MarkerView。\n#### 先上图\n\n![正常居中显示](http://upload-images.jianshu.io/upload_images/1311457-d5d185af3b7037e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过左边界](http://upload-images.jianshu.io/upload_images/1311457-84f1f978ac4211b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过上边界](http://upload-images.jianshu.io/upload_images/1311457-faa4dd3a11715f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过右边界](http://upload-images.jianshu.io/upload_images/1311457-e2e240b518251db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![超过上边界和右边界](http://upload-images.jianshu.io/upload_images/1311457-6dcbf615e7957d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 正文\n要实现这样的效果，大家先想想怎么做？\n这里的逻辑步骤分为：\n1、创建新类继承自MarkerView\n2、inflate layout进去\n3、重写getOffsetForDrawingAtPoint ，分别处理各种边界情况的偏移\n4、重写draw，绘制底色，根据不同的情况，绘制带箭头的对话框\n\n##### 直接上代码\n```\npublic class XYMarkerView extends MarkerView {\n    public static final int ARROW_SIZE = 40; // 箭头的大小\n    private static final float CIRCLE_OFFSET = 10;//因为我这里的折点是圆圈，所以要偏移，防止直接指向了圆心\n    private static final float STOKE_WIDTH = 5;//这里对于stroke_width的宽度也要做一定偏移\n    private final TextView tvContent;\n    private final RoundImageView avatar;\n    private final TextView name;\n    private final List<StepListModel> stepListModels;\n    private int index;\n    private int oldIndex = -1;\n\n    public XYMarkerView(Context context, List<StepListModel> stepListModels) {\n        super(context, R.layout.custom_marker_view);\n        tvContent = (TextView) findViewById(R.id.tvContent);\n        avatar = (RoundImageView) findViewById(R.id.avatar);\n        name = (TextView) findViewById(R.id.name);\n        this.stepListModels = stepListModels;\n    }\n\n    @Override\n    public void refreshContent(Entry e, Highlight highlight) {\n        super.refreshContent(e, highlight);\n        index = highlight.getDataSetIndex();//这个方法用于获得折线是哪根\n        tvContent.setText((int) e.getY() + \"\");\n//            StepListModel stepListModel = stepListModels.get(highlight.getDataSetIndex() % Constants.battleUsersCount);\n//            name.setText(stepListModel.getNickNm());\n//            Glide.with(getContext())\n//                    .load(GlideUtil.getGlideUrl(stepListModel.getIconUrl()))\n//                    .into(avatar);\n        Glide.with(getContext())\n                .asBitmap()\n                .load(avatars[index % avatars.length])\n                .listener(new RequestListener<Bitmap>() {\n                    @Override\n                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Bitmap> target, boolean isFirstResource) {\n                        return false;\n                    }\n\n                    @Override\n                    public boolean onResourceReady(Bitmap resource, Object model, Target<Bitmap> target, DataSource dataSource, boolean isFirstResource) {\n                        if (resource != null) {\n                            if (oldIndex != index) {\n                                XYMarkerView.this.getChartView().invalidate();\n                                oldIndex = index;\n                            }\n                            avatar.setImageBitmap(resource);\n                        }\n                        return false;\n                    }\n                })\n                .into(avatar);\n        name.setText(highlight.getDataSetIndex() + \"\");\n        tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));\n        LogUtil.m(\"getDataSetIndex\" + highlight.getDataSetIndex());\n\n    }\n\n    @Override\n    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) {\n        MPPointF offset = getOffset();\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n// posY \\posX 指的是markerView左上角点在图表上面的位置\n//处理Y方向\n        if (posY <= height + ARROW_SIZE) {// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小\n            offset.y = ARROW_SIZE;\n        } else {//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框\n            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width\n        }\n//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边\n//\n        if (posX > chart.getWidth() - width) {//如果超过右边界，则向左偏移markerView的宽度\n            offset.x = -width;\n        } else {//默认情况，不偏移（因为是点是在左上角）\n            offset.x = 0;\n            if (posX > width / 2) {//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度\n                offset.x = -(width / 2);\n            }\n        }\n        return offset;\n    }\n\n    @Override\n    public void draw(Canvas canvas, float posX, float posY) {\n        Paint paint = new Paint();//绘制边框的画笔\n        paint.setStrokeWidth(STOKE_WIDTH);\n        paint.setStyle(Paint.Style.STROKE);\n        paint.setStrokeJoin(Paint.Join.ROUND);\n        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));\n\n        Paint whitePaint = new Paint();//绘制底色白色的画笔\n        whitePaint.setStyle(Paint.Style.FILL);\n        whitePaint.setColor(Color.WHITE);\n\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n\n        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n        int saveId = canvas.save();\n\n        Path path = new Path();\n        if (posY < height + ARROW_SIZE) {//处理超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            if (posX > chart.getWidth() - width) {//超过右边界\n                path.lineTo(width - ARROW_SIZE, 0);\n                path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);\n                path.lineTo(width, 0);\n            } else {\n                if (posX > width / 2) {//在图表中间\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0);\n                    path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0);\n                } else {//超过左边界\n                    path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(0 + ARROW_SIZE, 0);\n                }\n            }\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            path.lineTo(0, 0 + height);\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        } else {//没有超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            if (posX > chart.getWidth() - width) {\n                path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);\n                path.lineTo(width - ARROW_SIZE, 0 + height);\n                path.lineTo(0, 0 + height);\n            } else {\n                if (posX > width / 2) {\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(0, 0 + height);\n                } else {\n                    path.lineTo(0 + ARROW_SIZE, 0 + height);\n                    path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(0, 0 + height);\n                }\n            }\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        }\n\n        // translate to the correct position and draw\n        canvas.drawPath(path, whitePaint);\n        canvas.drawPath(path, paint);\n        canvas.translate(posX + offset.x, posY + offset.y);\n        draw(canvas);\n        canvas.restoreToCount(saveId);\n    }\n}\n```\n\n\n### 详细\n\n#####  不同颜色、头像等处理\n我这里的需求是根据不同的折线，显示不同的人物头像、名字和对应的值，并且对话框的颜色、字体都要对应折线的颜色。\n所以，我这里根据```highlight.getDataSetIndex() ```就能处理不同颜色、头像等信息的情况。\n```\n//类似这个\n name.setText(highlight.getDataSetIndex() + \"\");\n tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));\n```\n注意：\n这里有个地方要注意一下，这里如果你使用Glide来加载图片到ImageView里去，会出现第一次加载不出来头像，第二次点击的时候就加载出来了。\n原因 ：是因为其实glide已经加载出来了，然后只是异步加载出来之后，已经是在layout绘制完成之后了，并没有进行invalidate的刷新。所以直到第二次的时候，其实glide已经加载过了，有缓存，所以直接就显示了，发生在draw方法之前，因为refreshContent就在draw之前调用\n```\n\n            // callbacks to update the content\n            mMarker.refreshContent(e, highlight);\n\n            // draw the marker\n            mMarker.draw(canvas, pos[0], pos[1]);\n```\n我这里是直接在glide的onResourceReady里面调用chart的invalidate，但是这样的话会一直循环刷新了，卡死！\n所以，这里使用了一个oldIndex是否等于index来判断是否是已经invalidate，这样的话就只有点击不同的折线的时候会invalidate一次，之后就不会了。\n```\n  private int index;\n  private int oldIndex = -1;\n  ...\n  Glide.with(getContext())\n                .asBitmap()\n                .load(avatars[index % avatars.length])\n                .listener(new RequestListener<Bitmap>() {\n                    @Override\n                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Bitmap> target, boolean isFirstResource) {\n                        return false;\n                    }\n\n                    @Override\n                    public boolean onResourceReady(Bitmap resource, Object model, Target<Bitmap> target, DataSource dataSource, boolean isFirstResource) {\n                        if (resource != null) {\n                            if (oldIndex != index) {\n                                XYMarkerView.this.getChartView().invalidate();\n                                oldIndex = index;\n                            }\n                            avatar.setImageBitmap(resource);\n                        }\n                        return false;\n                    }\n                })\n                .into(avatar);\n```\n\n##### 边界情况的处理\nMarkerView的draw方法，里面有posX、posY，这个点坐标代表的是markerView的左上角的坐标（如果不偏移的情况下，官方的默认也是做了偏移处理的，但是还有不够完善）。\n\n\n![默认是在左上角的，像这样](http://upload-images.jianshu.io/upload_images/1311457-0fb26dedb2ee3beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```getOffsetForDrawingAtPoint```就是处理偏移的方法，最终应用是在draw里面，进行canvas的translate变换\n```\n @Override\n    public void draw(Canvas canvas, float posX, float posY) {\n\n        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n\n        int saveId = canvas.save();\n        // translate to the correct position and draw\n        canvas.translate(posX + offset.x, posY + offset.y);\n        draw(canvas);\n        canvas.restoreToCount(saveId);\n    }\n```\n下面是我对各种边界情况的处理\n```\n     @Override\n    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) {\n        MPPointF offset = getOffset();\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n// posY \\posX 指的是markerView左上角点在图表上面的位置\n//处理Y方向\n        if (posY <= height + ARROW_SIZE) {// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小\n            offset.y = ARROW_SIZE;\n        } else {//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框\n            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width\n        }\n//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边\n//\n        if (posX > chart.getWidth() - width) {//如果超过右边界，则向左偏移markerView的宽度\n            offset.x = -width;\n        } else {//默认情况，不偏移（因为是点是在左上角）\n            offset.x = 0;\n            if (posX > width / 2) {//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度\n                offset.x = -(width / 2);\n            }\n        }\n        return offset;\n    }\n```\n\n![处理左边界](http://upload-images.jianshu.io/upload_images/1311457-a9f533f780593dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![处理一般情况](http://upload-images.jianshu.io/upload_images/1311457-c786c8d1e97c52ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![处理上边界](http://upload-images.jianshu.io/upload_images/1311457-ca258b7c1f605dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![处理右边界](http://upload-images.jianshu.io/upload_images/1311457-61b9d9ab08f5a30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 对于各个箭头的处理\n实现这个对话框，主要是通过绘制path来实现的，箭头的处理也是根据不同的情况，进行不同的path绘制实现的。\n```\n @Override\n    public void draw(Canvas canvas, float posX, float posY) {\n        Paint paint = new Paint();//绘制边框的画笔\n        paint.setStrokeWidth(STOKE_WIDTH);\n        paint.setStyle(Paint.Style.STROKE);\n        paint.setStrokeJoin(Paint.Join.ROUND);\n        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));\n\n        Paint whitePaint = new Paint();//绘制底色白色的画笔\n        whitePaint.setStyle(Paint.Style.FILL);\n        whitePaint.setColor(Color.WHITE);\n\n        Chart chart = getChartView();\n        float width = getWidth();\n        float height = getHeight();\n\n        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n        int saveId = canvas.save();\n\n        Path path = new Path();\n        if (posY < height + ARROW_SIZE) {//处理超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            if (posX > chart.getWidth() - width) {//超过右边界\n                path.lineTo(width - ARROW_SIZE, 0);\n                path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);\n                path.lineTo(width, 0);\n            } else {\n                if (posX > width / 2) {//在图表中间\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0);\n                    path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0);\n                } else {//超过左边界\n                    path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);\n                    path.lineTo(0 + ARROW_SIZE, 0);\n                }\n            }\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            path.lineTo(0, 0 + height);\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        } else {//没有超过上边界\n            path = new Path();\n            path.moveTo(0, 0);\n            path.lineTo(0 + width, 0);\n            path.lineTo(0 + width, 0 + height);\n            if (posX > chart.getWidth() - width) {\n                path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);\n                path.lineTo(width - ARROW_SIZE, 0 + height);\n                path.lineTo(0, 0 + height);\n            } else {\n                if (posX > width / 2) {\n                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);\n                    path.lineTo(0, 0 + height);\n                } else {\n                    path.lineTo(0 + ARROW_SIZE, 0 + height);\n                    path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);\n                    path.lineTo(0, 0 + height);\n                }\n            }\n            path.lineTo(0, 0);\n            path.offset(posX + offset.x, posY + offset.y);\n        }\n\n        // translate to the correct position and draw\n        canvas.drawPath(path, whitePaint);\n        canvas.drawPath(path, paint);\n        canvas.translate(posX + offset.x, posY + offset.y);\n        draw(canvas);\n        canvas.restoreToCount(saveId);\n    }\n```\n绘制MarkerView分为两部分，一部分是绘制对话框，一部分是绘制传入的R.layout.xx的view。\n\n\n![类似这样](http://upload-images.jianshu.io/upload_images/1311457-6955c8a84ac1ddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这里有一个问题，就是需要填充对话框白色，并且还要有边框。\n一个画笔是不够的，所以这里有两个画笔，一个是填充的，一个是画边框的。\n并且，是必须要先绘制对话框的底色，绘制对话框，再绘制传入的view\n```\n   Paint paint = new Paint();//绘制边框的画笔\n        paint.setStrokeWidth(STOKE_WIDTH);\n        paint.setStyle(Paint.Style.STROKE);\n        paint.setStrokeJoin(Paint.Join.ROUND);\n        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));\n\n        Paint whitePaint = new Paint();//绘制底色白色的画笔\n        whitePaint.setStyle(Paint.Style.FILL);\n        whitePaint.setColor(Color.WHITE);\n```\n```\n// 第一步        canvas.drawPath(path, whitePaint); \n// 第二步        canvas.drawPath(path, paint); \n                canvas.translate(posX + offset.x, posY + offset.y); \n// 第三步        draw(canvas);\n```\n因为我们的markerView偏移是对于canvas的偏移，但是我们的对话框的path并没有偏移，所以我们也要对path进行同样的偏移处理。很简单，直接获取偏移值，然后偏移就好。\n```\n   MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);\n  path.offset(posX + offset.x, posY + offset.y);\n```\n### 最后\n\n这样的最终效果就是传入的layout 被对话框包裹在里面了。\n\n![](http://upload-images.jianshu.io/upload_images/1311457-bfbfff71ab2aeb8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n箭头的绘制处理也比较简单，就是根据不同的情况来进行绘制就好，看代码吧。","slug":"android-MPAndroidChart-自适应Markerview","published":1,"updated":"2018-01-21T04:43:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcozqjuv00040cusq25worfg","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Android里面只要用过图表的应该都知道<a href=\"https://github.com/PhilJay/MPAndroidChart\" target=\"_blank\" rel=\"noopener\">MPAndroidChart</a>这个库。这个库在iOS里面也有对应<a href=\"https://github.com/danielgindi/Charts\" target=\"_blank\" rel=\"noopener\">Charts</a>，所以一般移动端做图表，Android和iOS两端都要实现同样的效果，他们是不错的一个选择。<br>但是，对于图表这种包含的情况非常复杂的东西，很难满足大家各种各样的需求，所以很多都需要自定义。下面就是给大家分享一下自己写的自适应MarkerView。</p>\n<h4 id=\"先上图\"><a href=\"#先上图\" class=\"headerlink\" title=\"先上图\"></a>先上图</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d5d185af3b7037e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"正常居中显示\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-84f1f978ac4211b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过左边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-faa4dd3a11715f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过上边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e2e240b518251db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过右边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6dcbf615e7957d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过上边界和右边界\"></p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>要实现这样的效果，大家先想想怎么做？<br>这里的逻辑步骤分为：<br>1、创建新类继承自MarkerView<br>2、inflate layout进去<br>3、重写getOffsetForDrawingAtPoint ，分别处理各种边界情况的偏移<br>4、重写draw，绘制底色，根据不同的情况，绘制带箭头的对话框</p>\n<h5 id=\"直接上代码\"><a href=\"#直接上代码\" class=\"headerlink\" title=\"直接上代码\"></a>直接上代码</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class XYMarkerView extends MarkerView &#123;</span><br><span class=\"line\">    public static final int ARROW_SIZE = 40; // 箭头的大小</span><br><span class=\"line\">    private static final float CIRCLE_OFFSET = 10;//因为我这里的折点是圆圈，所以要偏移，防止直接指向了圆心</span><br><span class=\"line\">    private static final float STOKE_WIDTH = 5;//这里对于stroke_width的宽度也要做一定偏移</span><br><span class=\"line\">    private final TextView tvContent;</span><br><span class=\"line\">    private final RoundImageView avatar;</span><br><span class=\"line\">    private final TextView name;</span><br><span class=\"line\">    private final List&lt;StepListModel&gt; stepListModels;</span><br><span class=\"line\">    private int index;</span><br><span class=\"line\">    private int oldIndex = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">    public XYMarkerView(Context context, List&lt;StepListModel&gt; stepListModels) &#123;</span><br><span class=\"line\">        super(context, R.layout.custom_marker_view);</span><br><span class=\"line\">        tvContent = (TextView) findViewById(R.id.tvContent);</span><br><span class=\"line\">        avatar = (RoundImageView) findViewById(R.id.avatar);</span><br><span class=\"line\">        name = (TextView) findViewById(R.id.name);</span><br><span class=\"line\">        this.stepListModels = stepListModels;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void refreshContent(Entry e, Highlight highlight) &#123;</span><br><span class=\"line\">        super.refreshContent(e, highlight);</span><br><span class=\"line\">        index = highlight.getDataSetIndex();//这个方法用于获得折线是哪根</span><br><span class=\"line\">        tvContent.setText((int) e.getY() + &quot;&quot;);</span><br><span class=\"line\">//            StepListModel stepListModel = stepListModels.get(highlight.getDataSetIndex() % Constants.battleUsersCount);</span><br><span class=\"line\">//            name.setText(stepListModel.getNickNm());</span><br><span class=\"line\">//            Glide.with(getContext())</span><br><span class=\"line\">//                    .load(GlideUtil.getGlideUrl(stepListModel.getIconUrl()))</span><br><span class=\"line\">//                    .into(avatar);</span><br><span class=\"line\">        Glide.with(getContext())</span><br><span class=\"line\">                .asBitmap()</span><br><span class=\"line\">                .load(avatars[index % avatars.length])</span><br><span class=\"line\">                .listener(new RequestListener&lt;Bitmap&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) &#123;</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class=\"line\">                        if (resource != null) &#123;</span><br><span class=\"line\">                            if (oldIndex != index) &#123;</span><br><span class=\"line\">                                XYMarkerView.this.getChartView().invalidate();</span><br><span class=\"line\">                                oldIndex = index;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            avatar.setImageBitmap(resource);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .into(avatar);</span><br><span class=\"line\">        name.setText(highlight.getDataSetIndex() + &quot;&quot;);</span><br><span class=\"line\">        tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));</span><br><span class=\"line\">        LogUtil.m(&quot;getDataSetIndex&quot; + highlight.getDataSetIndex());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) &#123;</span><br><span class=\"line\">        MPPointF offset = getOffset();</span><br><span class=\"line\">        Chart chart = getChartView();</span><br><span class=\"line\">        float width = getWidth();</span><br><span class=\"line\">        float height = getHeight();</span><br><span class=\"line\">// posY \\posX 指的是markerView左上角点在图表上面的位置</span><br><span class=\"line\">//处理Y方向</span><br><span class=\"line\">        if (posY &lt;= height + ARROW_SIZE) &#123;// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小</span><br><span class=\"line\">            offset.y = ARROW_SIZE;</span><br><span class=\"line\">        &#125; else &#123;//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框</span><br><span class=\"line\">            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边</span><br><span class=\"line\">//</span><br><span class=\"line\">        if (posX &gt; chart.getWidth() - width) &#123;//如果超过右边界，则向左偏移markerView的宽度</span><br><span class=\"line\">            offset.x = -width;</span><br><span class=\"line\">        &#125; else &#123;//默认情况，不偏移（因为是点是在左上角）</span><br><span class=\"line\">            offset.x = 0;</span><br><span class=\"line\">            if (posX &gt; width / 2) &#123;//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度</span><br><span class=\"line\">                offset.x = -(width / 2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void draw(Canvas canvas, float posX, float posY) &#123;</span><br><span class=\"line\">        Paint paint = new Paint();//绘制边框的画笔</span><br><span class=\"line\">        paint.setStrokeWidth(STOKE_WIDTH);</span><br><span class=\"line\">        paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class=\"line\">        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));</span><br><span class=\"line\"></span><br><span class=\"line\">        Paint whitePaint = new Paint();//绘制底色白色的画笔</span><br><span class=\"line\">        whitePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        whitePaint.setColor(Color.WHITE);</span><br><span class=\"line\"></span><br><span class=\"line\">        Chart chart = getChartView();</span><br><span class=\"line\">        float width = getWidth();</span><br><span class=\"line\">        float height = getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\">        int saveId = canvas.save();</span><br><span class=\"line\"></span><br><span class=\"line\">        Path path = new Path();</span><br><span class=\"line\">        if (posY &lt; height + ARROW_SIZE) &#123;//处理超过上边界</span><br><span class=\"line\">            path = new Path();</span><br><span class=\"line\">            path.moveTo(0, 0);</span><br><span class=\"line\">            if (posX &gt; chart.getWidth() - width) &#123;//超过右边界</span><br><span class=\"line\">                path.lineTo(width - ARROW_SIZE, 0);</span><br><span class=\"line\">                path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                path.lineTo(width, 0);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (posX &gt; width / 2) &#123;//在图表中间</span><br><span class=\"line\">                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0);</span><br><span class=\"line\">                    path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0);</span><br><span class=\"line\">                &#125; else &#123;//超过左边界</span><br><span class=\"line\">                    path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(0 + ARROW_SIZE, 0);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.lineTo(0 + width, 0);</span><br><span class=\"line\">            path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">            path.lineTo(0, 0 + height);</span><br><span class=\"line\">            path.lineTo(0, 0);</span><br><span class=\"line\">            path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        &#125; else &#123;//没有超过上边界</span><br><span class=\"line\">            path = new Path();</span><br><span class=\"line\">            path.moveTo(0, 0);</span><br><span class=\"line\">            path.lineTo(0 + width, 0);</span><br><span class=\"line\">            path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">            if (posX &gt; chart.getWidth() - width) &#123;</span><br><span class=\"line\">                path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                path.lineTo(width - ARROW_SIZE, 0 + height);</span><br><span class=\"line\">                path.lineTo(0, 0 + height);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (posX &gt; width / 2) &#123;</span><br><span class=\"line\">                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                    path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                    path.lineTo(0, 0 + height);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    path.lineTo(0 + ARROW_SIZE, 0 + height);</span><br><span class=\"line\">                    path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(0, 0 + height);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.lineTo(0, 0);</span><br><span class=\"line\">            path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // translate to the correct position and draw</span><br><span class=\"line\">        canvas.drawPath(path, whitePaint);</span><br><span class=\"line\">        canvas.drawPath(path, paint);</span><br><span class=\"line\">        canvas.translate(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        draw(canvas);</span><br><span class=\"line\">        canvas.restoreToCount(saveId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"详细\"><a href=\"#详细\" class=\"headerlink\" title=\"详细\"></a>详细</h3><h5 id=\"不同颜色、头像等处理\"><a href=\"#不同颜色、头像等处理\" class=\"headerlink\" title=\"不同颜色、头像等处理\"></a>不同颜色、头像等处理</h5><p>我这里的需求是根据不同的折线，显示不同的人物头像、名字和对应的值，并且对话框的颜色、字体都要对应折线的颜色。<br>所以，我这里根据<figure class=\"highlight plain\"><figcaption><span>```就能处理不同颜色、头像等信息的情况。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">//类似这个</span><br><span class=\"line\"> name.setText(highlight.getDataSetIndex() + &quot;&quot;);</span><br><span class=\"line\"> tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));</span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>这里有个地方要注意一下，这里如果你使用Glide来加载图片到ImageView里去，会出现第一次加载不出来头像，第二次点击的时候就加载出来了。<br>原因 ：是因为其实glide已经加载出来了，然后只是异步加载出来之后，已经是在layout绘制完成之后了，并没有进行invalidate的刷新。所以直到第二次的时候，其实glide已经加载过了，有缓存，所以直接就显示了，发生在draw方法之前，因为refreshContent就在draw之前调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// callbacks to update the content</span><br><span class=\"line\">mMarker.refreshContent(e, highlight);</span><br><span class=\"line\"></span><br><span class=\"line\">// draw the marker</span><br><span class=\"line\">mMarker.draw(canvas, pos[0], pos[1]);</span><br></pre></td></tr></table></figure></p>\n<p>我这里是直接在glide的onResourceReady里面调用chart的invalidate，但是这样的话会一直循环刷新了，卡死！<br>所以，这里使用了一个oldIndex是否等于index来判断是否是已经invalidate，这样的话就只有点击不同的折线的时候会invalidate一次，之后就不会了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int index;</span><br><span class=\"line\">private int oldIndex = -1;</span><br><span class=\"line\">...</span><br><span class=\"line\">Glide.with(getContext())</span><br><span class=\"line\">              .asBitmap()</span><br><span class=\"line\">              .load(avatars[index % avatars.length])</span><br><span class=\"line\">              .listener(new RequestListener&lt;Bitmap&gt;() &#123;</span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) &#123;</span><br><span class=\"line\">                      return false;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class=\"line\">                      if (resource != null) &#123;</span><br><span class=\"line\">                          if (oldIndex != index) &#123;</span><br><span class=\"line\">                              XYMarkerView.this.getChartView().invalidate();</span><br><span class=\"line\">                              oldIndex = index;</span><br><span class=\"line\">                          &#125;</span><br><span class=\"line\">                          avatar.setImageBitmap(resource);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      return false;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">              .into(avatar);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"边界情况的处理\"><a href=\"#边界情况的处理\" class=\"headerlink\" title=\"边界情况的处理\"></a>边界情况的处理</h5><p>MarkerView的draw方法，里面有posX、posY，这个点坐标代表的是markerView的左上角的坐标（如果不偏移的情况下，官方的默认也是做了偏移处理的，但是还有不够完善）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0fb26dedb2ee3beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"默认是在左上角的，像这样\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"> @Override</span><br><span class=\"line\">    public void draw(Canvas canvas, float posX, float posY) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\"></span><br><span class=\"line\">        int saveId = canvas.save();</span><br><span class=\"line\">        // translate to the correct position and draw</span><br><span class=\"line\">        canvas.translate(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        draw(canvas);</span><br><span class=\"line\">        canvas.restoreToCount(saveId);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是我对各种边界情况的处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     @Override</span><br><span class=\"line\">    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) &#123;</span><br><span class=\"line\">        MPPointF offset = getOffset();</span><br><span class=\"line\">        Chart chart = getChartView();</span><br><span class=\"line\">        float width = getWidth();</span><br><span class=\"line\">        float height = getHeight();</span><br><span class=\"line\">// posY \\posX 指的是markerView左上角点在图表上面的位置</span><br><span class=\"line\">//处理Y方向</span><br><span class=\"line\">        if (posY &lt;= height + ARROW_SIZE) &#123;// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小</span><br><span class=\"line\">            offset.y = ARROW_SIZE;</span><br><span class=\"line\">        &#125; else &#123;//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框</span><br><span class=\"line\">            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边</span><br><span class=\"line\">//</span><br><span class=\"line\">        if (posX &gt; chart.getWidth() - width) &#123;//如果超过右边界，则向左偏移markerView的宽度</span><br><span class=\"line\">            offset.x = -width;</span><br><span class=\"line\">        &#125; else &#123;//默认情况，不偏移（因为是点是在左上角）</span><br><span class=\"line\">            offset.x = 0;</span><br><span class=\"line\">            if (posX &gt; width / 2) &#123;//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度</span><br><span class=\"line\">                offset.x = -(width / 2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return offset;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a9f533f780593dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理左边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-c786c8d1e97c52ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理一般情况\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ca258b7c1f605dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理上边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-61b9d9ab08f5a30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理右边界\"></p>\n<h4 id=\"对于各个箭头的处理\"><a href=\"#对于各个箭头的处理\" class=\"headerlink\" title=\"对于各个箭头的处理\"></a>对于各个箭头的处理</h4><p>实现这个对话框，主要是通过绘制path来实现的，箭头的处理也是根据不同的情况，进行不同的path绘制实现的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public void draw(Canvas canvas, float posX, float posY) &#123;</span><br><span class=\"line\">       Paint paint = new Paint();//绘制边框的画笔</span><br><span class=\"line\">       paint.setStrokeWidth(STOKE_WIDTH);</span><br><span class=\"line\">       paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">       paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class=\"line\">       paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));</span><br><span class=\"line\"></span><br><span class=\"line\">       Paint whitePaint = new Paint();//绘制底色白色的画笔</span><br><span class=\"line\">       whitePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">       whitePaint.setColor(Color.WHITE);</span><br><span class=\"line\"></span><br><span class=\"line\">       Chart chart = getChartView();</span><br><span class=\"line\">       float width = getWidth();</span><br><span class=\"line\">       float height = getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">       MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\">       int saveId = canvas.save();</span><br><span class=\"line\"></span><br><span class=\"line\">       Path path = new Path();</span><br><span class=\"line\">       if (posY &lt; height + ARROW_SIZE) &#123;//处理超过上边界</span><br><span class=\"line\">           path = new Path();</span><br><span class=\"line\">           path.moveTo(0, 0);</span><br><span class=\"line\">           if (posX &gt; chart.getWidth() - width) &#123;//超过右边界</span><br><span class=\"line\">               path.lineTo(width - ARROW_SIZE, 0);</span><br><span class=\"line\">               path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">               path.lineTo(width, 0);</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               if (posX &gt; width / 2) &#123;//在图表中间</span><br><span class=\"line\">                   path.lineTo(width / 2 - ARROW_SIZE / 2, 0);</span><br><span class=\"line\">                   path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(width / 2 + ARROW_SIZE / 2, 0);</span><br><span class=\"line\">               &#125; else &#123;//超过左边界</span><br><span class=\"line\">                   path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(0 + ARROW_SIZE, 0);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           path.lineTo(0 + width, 0);</span><br><span class=\"line\">           path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">           path.lineTo(0, 0 + height);</span><br><span class=\"line\">           path.lineTo(0, 0);</span><br><span class=\"line\">           path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">       &#125; else &#123;//没有超过上边界</span><br><span class=\"line\">           path = new Path();</span><br><span class=\"line\">           path.moveTo(0, 0);</span><br><span class=\"line\">           path.lineTo(0 + width, 0);</span><br><span class=\"line\">           path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">           if (posX &gt; chart.getWidth() - width) &#123;</span><br><span class=\"line\">               path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">               path.lineTo(width - ARROW_SIZE, 0 + height);</span><br><span class=\"line\">               path.lineTo(0, 0 + height);</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               if (posX &gt; width / 2) &#123;</span><br><span class=\"line\">                   path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                   path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                   path.lineTo(0, 0 + height);</span><br><span class=\"line\">               &#125; else &#123;</span><br><span class=\"line\">                   path.lineTo(0 + ARROW_SIZE, 0 + height);</span><br><span class=\"line\">                   path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(0, 0 + height);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           path.lineTo(0, 0);</span><br><span class=\"line\">           path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // translate to the correct position and draw</span><br><span class=\"line\">       canvas.drawPath(path, whitePaint);</span><br><span class=\"line\">       canvas.drawPath(path, paint);</span><br><span class=\"line\">       canvas.translate(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">       draw(canvas);</span><br><span class=\"line\">       canvas.restoreToCount(saveId);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>绘制MarkerView分为两部分，一部分是绘制对话框，一部分是绘制传入的R.layout.xx的view。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6955c8a84ac1ddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"类似这样\"></p>\n<p>这里有一个问题，就是需要填充对话框白色，并且还要有边框。<br>一个画笔是不够的，所以这里有两个画笔，一个是填充的，一个是画边框的。<br>并且，是必须要先绘制对话框的底色，绘制对话框，再绘制传入的view<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Paint paint = new Paint();//绘制边框的画笔</span><br><span class=\"line\">     paint.setStrokeWidth(STOKE_WIDTH);</span><br><span class=\"line\">     paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">     paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class=\"line\">     paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));</span><br><span class=\"line\"></span><br><span class=\"line\">     Paint whitePaint = new Paint();//绘制底色白色的画笔</span><br><span class=\"line\">     whitePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">     whitePaint.setColor(Color.WHITE);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一步        canvas.drawPath(path, whitePaint); </span><br><span class=\"line\">// 第二步        canvas.drawPath(path, paint); </span><br><span class=\"line\">                canvas.translate(posX + offset.x, posY + offset.y); </span><br><span class=\"line\">// 第三步        draw(canvas);</span><br></pre></td></tr></table></figure>\n<p>因为我们的markerView偏移是对于canvas的偏移，但是我们的对话框的path并没有偏移，所以我们也要对path进行同样的偏移处理。很简单，直接获取偏移值，然后偏移就好。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\">path.offset(posX + offset.x, posY + offset.y);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>这样的最终效果就是传入的layout 被对话框包裹在里面了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-bfbfff71ab2aeb8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>箭头的绘制处理也比较简单，就是根据不同的情况来进行绘制就好，看代码吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Android里面只要用过图表的应该都知道<a href=\"https://github.com/PhilJay/MPAndroidChart\" target=\"_blank\" rel=\"noopener\">MPAndroidChart</a>这个库。这个库在iOS里面也有对应<a href=\"https://github.com/danielgindi/Charts\" target=\"_blank\" rel=\"noopener\">Charts</a>，所以一般移动端做图表，Android和iOS两端都要实现同样的效果，他们是不错的一个选择。<br>但是，对于图表这种包含的情况非常复杂的东西，很难满足大家各种各样的需求，所以很多都需要自定义。下面就是给大家分享一下自己写的自适应MarkerView。</p>\n<h4 id=\"先上图\"><a href=\"#先上图\" class=\"headerlink\" title=\"先上图\"></a>先上图</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d5d185af3b7037e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"正常居中显示\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-84f1f978ac4211b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过左边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-faa4dd3a11715f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过上边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e2e240b518251db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过右边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6dcbf615e7957d05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"超过上边界和右边界\"></p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>要实现这样的效果，大家先想想怎么做？<br>这里的逻辑步骤分为：<br>1、创建新类继承自MarkerView<br>2、inflate layout进去<br>3、重写getOffsetForDrawingAtPoint ，分别处理各种边界情况的偏移<br>4、重写draw，绘制底色，根据不同的情况，绘制带箭头的对话框</p>\n<h5 id=\"直接上代码\"><a href=\"#直接上代码\" class=\"headerlink\" title=\"直接上代码\"></a>直接上代码</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class XYMarkerView extends MarkerView &#123;</span><br><span class=\"line\">    public static final int ARROW_SIZE = 40; // 箭头的大小</span><br><span class=\"line\">    private static final float CIRCLE_OFFSET = 10;//因为我这里的折点是圆圈，所以要偏移，防止直接指向了圆心</span><br><span class=\"line\">    private static final float STOKE_WIDTH = 5;//这里对于stroke_width的宽度也要做一定偏移</span><br><span class=\"line\">    private final TextView tvContent;</span><br><span class=\"line\">    private final RoundImageView avatar;</span><br><span class=\"line\">    private final TextView name;</span><br><span class=\"line\">    private final List&lt;StepListModel&gt; stepListModels;</span><br><span class=\"line\">    private int index;</span><br><span class=\"line\">    private int oldIndex = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">    public XYMarkerView(Context context, List&lt;StepListModel&gt; stepListModels) &#123;</span><br><span class=\"line\">        super(context, R.layout.custom_marker_view);</span><br><span class=\"line\">        tvContent = (TextView) findViewById(R.id.tvContent);</span><br><span class=\"line\">        avatar = (RoundImageView) findViewById(R.id.avatar);</span><br><span class=\"line\">        name = (TextView) findViewById(R.id.name);</span><br><span class=\"line\">        this.stepListModels = stepListModels;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void refreshContent(Entry e, Highlight highlight) &#123;</span><br><span class=\"line\">        super.refreshContent(e, highlight);</span><br><span class=\"line\">        index = highlight.getDataSetIndex();//这个方法用于获得折线是哪根</span><br><span class=\"line\">        tvContent.setText((int) e.getY() + &quot;&quot;);</span><br><span class=\"line\">//            StepListModel stepListModel = stepListModels.get(highlight.getDataSetIndex() % Constants.battleUsersCount);</span><br><span class=\"line\">//            name.setText(stepListModel.getNickNm());</span><br><span class=\"line\">//            Glide.with(getContext())</span><br><span class=\"line\">//                    .load(GlideUtil.getGlideUrl(stepListModel.getIconUrl()))</span><br><span class=\"line\">//                    .into(avatar);</span><br><span class=\"line\">        Glide.with(getContext())</span><br><span class=\"line\">                .asBitmap()</span><br><span class=\"line\">                .load(avatars[index % avatars.length])</span><br><span class=\"line\">                .listener(new RequestListener&lt;Bitmap&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) &#123;</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class=\"line\">                        if (resource != null) &#123;</span><br><span class=\"line\">                            if (oldIndex != index) &#123;</span><br><span class=\"line\">                                XYMarkerView.this.getChartView().invalidate();</span><br><span class=\"line\">                                oldIndex = index;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            avatar.setImageBitmap(resource);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .into(avatar);</span><br><span class=\"line\">        name.setText(highlight.getDataSetIndex() + &quot;&quot;);</span><br><span class=\"line\">        tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));</span><br><span class=\"line\">        LogUtil.m(&quot;getDataSetIndex&quot; + highlight.getDataSetIndex());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) &#123;</span><br><span class=\"line\">        MPPointF offset = getOffset();</span><br><span class=\"line\">        Chart chart = getChartView();</span><br><span class=\"line\">        float width = getWidth();</span><br><span class=\"line\">        float height = getHeight();</span><br><span class=\"line\">// posY \\posX 指的是markerView左上角点在图表上面的位置</span><br><span class=\"line\">//处理Y方向</span><br><span class=\"line\">        if (posY &lt;= height + ARROW_SIZE) &#123;// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小</span><br><span class=\"line\">            offset.y = ARROW_SIZE;</span><br><span class=\"line\">        &#125; else &#123;//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框</span><br><span class=\"line\">            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边</span><br><span class=\"line\">//</span><br><span class=\"line\">        if (posX &gt; chart.getWidth() - width) &#123;//如果超过右边界，则向左偏移markerView的宽度</span><br><span class=\"line\">            offset.x = -width;</span><br><span class=\"line\">        &#125; else &#123;//默认情况，不偏移（因为是点是在左上角）</span><br><span class=\"line\">            offset.x = 0;</span><br><span class=\"line\">            if (posX &gt; width / 2) &#123;//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度</span><br><span class=\"line\">                offset.x = -(width / 2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void draw(Canvas canvas, float posX, float posY) &#123;</span><br><span class=\"line\">        Paint paint = new Paint();//绘制边框的画笔</span><br><span class=\"line\">        paint.setStrokeWidth(STOKE_WIDTH);</span><br><span class=\"line\">        paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class=\"line\">        paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));</span><br><span class=\"line\"></span><br><span class=\"line\">        Paint whitePaint = new Paint();//绘制底色白色的画笔</span><br><span class=\"line\">        whitePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        whitePaint.setColor(Color.WHITE);</span><br><span class=\"line\"></span><br><span class=\"line\">        Chart chart = getChartView();</span><br><span class=\"line\">        float width = getWidth();</span><br><span class=\"line\">        float height = getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\">        int saveId = canvas.save();</span><br><span class=\"line\"></span><br><span class=\"line\">        Path path = new Path();</span><br><span class=\"line\">        if (posY &lt; height + ARROW_SIZE) &#123;//处理超过上边界</span><br><span class=\"line\">            path = new Path();</span><br><span class=\"line\">            path.moveTo(0, 0);</span><br><span class=\"line\">            if (posX &gt; chart.getWidth() - width) &#123;//超过右边界</span><br><span class=\"line\">                path.lineTo(width - ARROW_SIZE, 0);</span><br><span class=\"line\">                path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                path.lineTo(width, 0);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (posX &gt; width / 2) &#123;//在图表中间</span><br><span class=\"line\">                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0);</span><br><span class=\"line\">                    path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0);</span><br><span class=\"line\">                &#125; else &#123;//超过左边界</span><br><span class=\"line\">                    path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(0 + ARROW_SIZE, 0);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.lineTo(0 + width, 0);</span><br><span class=\"line\">            path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">            path.lineTo(0, 0 + height);</span><br><span class=\"line\">            path.lineTo(0, 0);</span><br><span class=\"line\">            path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        &#125; else &#123;//没有超过上边界</span><br><span class=\"line\">            path = new Path();</span><br><span class=\"line\">            path.moveTo(0, 0);</span><br><span class=\"line\">            path.lineTo(0 + width, 0);</span><br><span class=\"line\">            path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">            if (posX &gt; chart.getWidth() - width) &#123;</span><br><span class=\"line\">                path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                path.lineTo(width - ARROW_SIZE, 0 + height);</span><br><span class=\"line\">                path.lineTo(0, 0 + height);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (posX &gt; width / 2) &#123;</span><br><span class=\"line\">                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                    path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                    path.lineTo(0, 0 + height);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    path.lineTo(0 + ARROW_SIZE, 0 + height);</span><br><span class=\"line\">                    path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                    path.lineTo(0, 0 + height);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.lineTo(0, 0);</span><br><span class=\"line\">            path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // translate to the correct position and draw</span><br><span class=\"line\">        canvas.drawPath(path, whitePaint);</span><br><span class=\"line\">        canvas.drawPath(path, paint);</span><br><span class=\"line\">        canvas.translate(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        draw(canvas);</span><br><span class=\"line\">        canvas.restoreToCount(saveId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"详细\"><a href=\"#详细\" class=\"headerlink\" title=\"详细\"></a>详细</h3><h5 id=\"不同颜色、头像等处理\"><a href=\"#不同颜色、头像等处理\" class=\"headerlink\" title=\"不同颜色、头像等处理\"></a>不同颜色、头像等处理</h5><p>我这里的需求是根据不同的折线，显示不同的人物头像、名字和对应的值，并且对话框的颜色、字体都要对应折线的颜色。<br>所以，我这里根据<figure class=\"highlight plain\"><figcaption><span>```就能处理不同颜色、头像等信息的情况。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">//类似这个</span><br><span class=\"line\"> name.setText(highlight.getDataSetIndex() + &quot;&quot;);</span><br><span class=\"line\"> tvContent.setTextColor(getResources().getColor(ColorUtil.colors[highlight.getDataSetIndex() % ColorUtil.colors.length]));</span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>这里有个地方要注意一下，这里如果你使用Glide来加载图片到ImageView里去，会出现第一次加载不出来头像，第二次点击的时候就加载出来了。<br>原因 ：是因为其实glide已经加载出来了，然后只是异步加载出来之后，已经是在layout绘制完成之后了，并没有进行invalidate的刷新。所以直到第二次的时候，其实glide已经加载过了，有缓存，所以直接就显示了，发生在draw方法之前，因为refreshContent就在draw之前调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// callbacks to update the content</span><br><span class=\"line\">mMarker.refreshContent(e, highlight);</span><br><span class=\"line\"></span><br><span class=\"line\">// draw the marker</span><br><span class=\"line\">mMarker.draw(canvas, pos[0], pos[1]);</span><br></pre></td></tr></table></figure></p>\n<p>我这里是直接在glide的onResourceReady里面调用chart的invalidate，但是这样的话会一直循环刷新了，卡死！<br>所以，这里使用了一个oldIndex是否等于index来判断是否是已经invalidate，这样的话就只有点击不同的折线的时候会invalidate一次，之后就不会了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int index;</span><br><span class=\"line\">private int oldIndex = -1;</span><br><span class=\"line\">...</span><br><span class=\"line\">Glide.with(getContext())</span><br><span class=\"line\">              .asBitmap()</span><br><span class=\"line\">              .load(avatars[index % avatars.length])</span><br><span class=\"line\">              .listener(new RequestListener&lt;Bitmap&gt;() &#123;</span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) &#123;</span><br><span class=\"line\">                      return false;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                  @Override</span><br><span class=\"line\">                  public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class=\"line\">                      if (resource != null) &#123;</span><br><span class=\"line\">                          if (oldIndex != index) &#123;</span><br><span class=\"line\">                              XYMarkerView.this.getChartView().invalidate();</span><br><span class=\"line\">                              oldIndex = index;</span><br><span class=\"line\">                          &#125;</span><br><span class=\"line\">                          avatar.setImageBitmap(resource);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      return false;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">              .into(avatar);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"边界情况的处理\"><a href=\"#边界情况的处理\" class=\"headerlink\" title=\"边界情况的处理\"></a>边界情况的处理</h5><p>MarkerView的draw方法，里面有posX、posY，这个点坐标代表的是markerView的左上角的坐标（如果不偏移的情况下，官方的默认也是做了偏移处理的，但是还有不够完善）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0fb26dedb2ee3beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"默认是在左上角的，像这样\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"> @Override</span><br><span class=\"line\">    public void draw(Canvas canvas, float posX, float posY) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\"></span><br><span class=\"line\">        int saveId = canvas.save();</span><br><span class=\"line\">        // translate to the correct position and draw</span><br><span class=\"line\">        canvas.translate(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">        draw(canvas);</span><br><span class=\"line\">        canvas.restoreToCount(saveId);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是我对各种边界情况的处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     @Override</span><br><span class=\"line\">    public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) &#123;</span><br><span class=\"line\">        MPPointF offset = getOffset();</span><br><span class=\"line\">        Chart chart = getChartView();</span><br><span class=\"line\">        float width = getWidth();</span><br><span class=\"line\">        float height = getHeight();</span><br><span class=\"line\">// posY \\posX 指的是markerView左上角点在图表上面的位置</span><br><span class=\"line\">//处理Y方向</span><br><span class=\"line\">        if (posY &lt;= height + ARROW_SIZE) &#123;// 如果点y坐标小于markerView的高度，如果不处理会超出上边界，处理了之后这时候箭头是向上的，我们需要把图标下移一个箭头的大小</span><br><span class=\"line\">            offset.y = ARROW_SIZE;</span><br><span class=\"line\">        &#125; else &#123;//否则属于正常情况，因为我们默认是箭头朝下，然后正常偏移就是，需要向上偏移markerView高度和arrow size，再加一个stroke的宽度，因为你需要看到对话框的上面的边框</span><br><span class=\"line\">            offset.y = -height - ARROW_SIZE - STOKE_WIDTH; // 40 arrow height   5 stroke width</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//处理X方向，分为3种情况，1、在图表左边 2、在图表中间 3、在图表右边</span><br><span class=\"line\">//</span><br><span class=\"line\">        if (posX &gt; chart.getWidth() - width) &#123;//如果超过右边界，则向左偏移markerView的宽度</span><br><span class=\"line\">            offset.x = -width;</span><br><span class=\"line\">        &#125; else &#123;//默认情况，不偏移（因为是点是在左上角）</span><br><span class=\"line\">            offset.x = 0;</span><br><span class=\"line\">            if (posX &gt; width / 2) &#123;//如果大于markerView的一半，说明箭头在中间，所以向右偏移一半宽度</span><br><span class=\"line\">                offset.x = -(width / 2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return offset;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a9f533f780593dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理左边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-c786c8d1e97c52ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理一般情况\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ca258b7c1f605dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理上边界\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-61b9d9ab08f5a30e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"处理右边界\"></p>\n<h4 id=\"对于各个箭头的处理\"><a href=\"#对于各个箭头的处理\" class=\"headerlink\" title=\"对于各个箭头的处理\"></a>对于各个箭头的处理</h4><p>实现这个对话框，主要是通过绘制path来实现的，箭头的处理也是根据不同的情况，进行不同的path绘制实现的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public void draw(Canvas canvas, float posX, float posY) &#123;</span><br><span class=\"line\">       Paint paint = new Paint();//绘制边框的画笔</span><br><span class=\"line\">       paint.setStrokeWidth(STOKE_WIDTH);</span><br><span class=\"line\">       paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">       paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class=\"line\">       paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));</span><br><span class=\"line\"></span><br><span class=\"line\">       Paint whitePaint = new Paint();//绘制底色白色的画笔</span><br><span class=\"line\">       whitePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">       whitePaint.setColor(Color.WHITE);</span><br><span class=\"line\"></span><br><span class=\"line\">       Chart chart = getChartView();</span><br><span class=\"line\">       float width = getWidth();</span><br><span class=\"line\">       float height = getHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">       MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\">       int saveId = canvas.save();</span><br><span class=\"line\"></span><br><span class=\"line\">       Path path = new Path();</span><br><span class=\"line\">       if (posY &lt; height + ARROW_SIZE) &#123;//处理超过上边界</span><br><span class=\"line\">           path = new Path();</span><br><span class=\"line\">           path.moveTo(0, 0);</span><br><span class=\"line\">           if (posX &gt; chart.getWidth() - width) &#123;//超过右边界</span><br><span class=\"line\">               path.lineTo(width - ARROW_SIZE, 0);</span><br><span class=\"line\">               path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">               path.lineTo(width, 0);</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               if (posX &gt; width / 2) &#123;//在图表中间</span><br><span class=\"line\">                   path.lineTo(width / 2 - ARROW_SIZE / 2, 0);</span><br><span class=\"line\">                   path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(width / 2 + ARROW_SIZE / 2, 0);</span><br><span class=\"line\">               &#125; else &#123;//超过左边界</span><br><span class=\"line\">                   path.lineTo(0, -ARROW_SIZE + CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(0 + ARROW_SIZE, 0);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           path.lineTo(0 + width, 0);</span><br><span class=\"line\">           path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">           path.lineTo(0, 0 + height);</span><br><span class=\"line\">           path.lineTo(0, 0);</span><br><span class=\"line\">           path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">       &#125; else &#123;//没有超过上边界</span><br><span class=\"line\">           path = new Path();</span><br><span class=\"line\">           path.moveTo(0, 0);</span><br><span class=\"line\">           path.lineTo(0 + width, 0);</span><br><span class=\"line\">           path.lineTo(0 + width, 0 + height);</span><br><span class=\"line\">           if (posX &gt; chart.getWidth() - width) &#123;</span><br><span class=\"line\">               path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">               path.lineTo(width - ARROW_SIZE, 0 + height);</span><br><span class=\"line\">               path.lineTo(0, 0 + height);</span><br><span class=\"line\">           &#125; else &#123;</span><br><span class=\"line\">               if (posX &gt; width / 2) &#123;</span><br><span class=\"line\">                   path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                   path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height);</span><br><span class=\"line\">                   path.lineTo(0, 0 + height);</span><br><span class=\"line\">               &#125; else &#123;</span><br><span class=\"line\">                   path.lineTo(0 + ARROW_SIZE, 0 + height);</span><br><span class=\"line\">                   path.lineTo(0, height + ARROW_SIZE - CIRCLE_OFFSET);</span><br><span class=\"line\">                   path.lineTo(0, 0 + height);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           path.lineTo(0, 0);</span><br><span class=\"line\">           path.offset(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // translate to the correct position and draw</span><br><span class=\"line\">       canvas.drawPath(path, whitePaint);</span><br><span class=\"line\">       canvas.drawPath(path, paint);</span><br><span class=\"line\">       canvas.translate(posX + offset.x, posY + offset.y);</span><br><span class=\"line\">       draw(canvas);</span><br><span class=\"line\">       canvas.restoreToCount(saveId);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>绘制MarkerView分为两部分，一部分是绘制对话框，一部分是绘制传入的R.layout.xx的view。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6955c8a84ac1ddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"类似这样\"></p>\n<p>这里有一个问题，就是需要填充对话框白色，并且还要有边框。<br>一个画笔是不够的，所以这里有两个画笔，一个是填充的，一个是画边框的。<br>并且，是必须要先绘制对话框的底色，绘制对话框，再绘制传入的view<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Paint paint = new Paint();//绘制边框的画笔</span><br><span class=\"line\">     paint.setStrokeWidth(STOKE_WIDTH);</span><br><span class=\"line\">     paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">     paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class=\"line\">     paint.setColor(getResources().getColor(ColorUtil.colors[index % ColorUtil.colors.length]));</span><br><span class=\"line\"></span><br><span class=\"line\">     Paint whitePaint = new Paint();//绘制底色白色的画笔</span><br><span class=\"line\">     whitePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">     whitePaint.setColor(Color.WHITE);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一步        canvas.drawPath(path, whitePaint); </span><br><span class=\"line\">// 第二步        canvas.drawPath(path, paint); </span><br><span class=\"line\">                canvas.translate(posX + offset.x, posY + offset.y); </span><br><span class=\"line\">// 第三步        draw(canvas);</span><br></pre></td></tr></table></figure>\n<p>因为我们的markerView偏移是对于canvas的偏移，但是我们的对话框的path并没有偏移，所以我们也要对path进行同样的偏移处理。很简单，直接获取偏移值，然后偏移就好。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> MPPointF offset = getOffsetForDrawingAtPoint(posX, posY);</span><br><span class=\"line\">path.offset(posX + offset.x, posY + offset.y);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>这样的最终效果就是传入的layout 被对话框包裹在里面了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-bfbfff71ab2aeb8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>箭头的绘制处理也比较简单，就是根据不同的情况来进行绘制就好，看代码吧。</p>\n"},{"layout":"android","title":"android PorterDuffXferMode真正的效果测试集合（对比官方demo）","date":"2018-01-21T04:24:37.000Z","_content":"\n##### 前言\n当时在做头像imageView，就是切圆头像\n1、如果我们先画一个circle（非bitmap），然后setXfermode 为Src_In，再画一个bitmap(图片的)。成功，完美 。\n\n![成功](http://upload-images.jianshu.io/upload_images/1311457-1d790e3f8065c18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2、如果我们先画一个bitmap(图片的)，然后setXfermode 为Dsr_In,再画circle。粗略学习了网上那张图之后，理论上应该也是成功的，但是却出现了问题。\n\n![不成功](http://upload-images.jianshu.io/upload_images/1311457-cc02fd317d50ee46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以，我很疑惑，就开始了各种探索学习测试。（当然，至于为什么出现这种情况，文末会有解释）\n\n到目前为止已经被PorterDuffXferMode坑了有1天时间了，网上看了无数的文章，很乱很杂，没有写得能够让我很清楚很明白且有点权威的文献，因为很多没有测试结果，并且我没有亲身实践过，所以，现在我要重新自己动手实践一下。\n\n在网上搜罗了一大圈，在群里和很多人交流了，大概有2篇文章，个人认为说得在理。（建议大家先去看一下，不过可能你会跟我一样，看了之后就更云里雾里，但是还是需要亲身实践为好）\n\n感谢两位作者。\n\n[PorterDuffXferMode不正确的真正原因PorterDuffXferMode深入试验](http://m.blog.csdn.net/article/details?id=50534175)\n\n[Android中Canvas绘图之PorterDuffXfermode使用及工作原理详解](http://blog.csdn.net/iispring/article/details/50472485)\n\n**第一篇**主要总结：\n如果想让PorterDuffXferMode按照预期Demo（或者效果图）的效果图像实现，必须满足以下条件：\n**1、关闭硬件加速。（经过作者修改为 开启硬件离屏缓存）\n2、两个bitmap大小尽量一样。\n3、背景色为透明色。\n4、如果两个bitmap位置不完全一样，可能也是预期效果，只不过你看到的效果和你自己脑补的预期效果不一致。**\n\n**第二篇**主要总结：\n**PorterDuffXfermode用于实现新绘制的像素与Canvas上对应位置已有的像素按照混合规则进行颜色混合。**\n\n\n-----------------\n我主要是在第一篇的结论基础上去做测试，并给大家展示测试结果。\n下面高能篇幅，如果你不是真正在学习研究PorterDuffXfermode踩坑的人，如果你没有耐心阅读的，就可以别往下看了。\n亦或你也想亲手尝试，那还是先去尝试一下吧。\n\n-------\n\n首先代码图：\n```\npublic class TestXfermodeView extends View {\n    public TestXfermodeView(Context context) {\n        super(context);\n    }\n\n    public TestXfermodeView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public TestXfermodeView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        Bitmap circle = getCircleBitmap();\n        Bitmap rectangle = getRetangleBitmap();\n\n//        int sc = canvas.saveLayer(0, 0, 400, 400, null,\n//                Canvas.MATRIX_SAVE_FLAG |\n//                        Canvas.CLIP_SAVE_FLAG |\n//                        Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |\n//                        Canvas.FULL_COLOR_LAYER_SAVE_FLAG |\n//                        Canvas.CLIP_TO_LAYER_SAVE_FLAG);\n\n        /**\n         * 开启硬件离屏缓存\n         */\n        setLayerType(LAYER_TYPE_HARDWARE, null);\n        Paint paint = new Paint();\n        /**\n         * 画bitmap的也透明\n         */\n        canvas.drawARGB(0, 0, 0, 0);\n//        canvas.drawCircle(100, 100, 100, paint);\n        canvas.drawBitmap(rectangle, 100, 100, paint);\n//        Bitmap b= BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);\n//        Rect rect = new Rect(0, 0, 100, 100);\n//        canvas.drawBitmap(b,rect, rect, paint);\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER));\n\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OVER));\n\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XOR));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DARKEN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.OVERLAY));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SCREEN));\n        canvas.drawBitmap(circle, 0, 0, paint);\n//        canvas.restoreToCount(sc);\n\n    }\n\n    @NonNull\n    private Bitmap getRetangleBitmap() {\n        /**\n         * bm1 在bitmap上面画正方形\n         */\n        Bitmap rectangle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);\n        Canvas c1 = new Canvas(rectangle);\n        Paint p1 = new Paint(Paint.ANTI_ALIAS_FLAG);\n        p1.setColor(getResources().getColor(R.color.colorAccent));\n        /**\n         * 设置透明\n         */\n        c1.drawARGB(0, 0, 0, 0);\n        c1.drawRect(0, 0, 200, 200, p1);\n        return rectangle;\n    }\n\n    @NonNull\n    private Bitmap getCircleBitmap() {\n        /**\n         * bm 在bitmap上面画圆\n         */\n        Bitmap circle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);\n        Canvas c = new Canvas(circle);\n        /**\n         * 设置透明\n         */\n        c.drawARGB(0, 0, 0, 0);\n        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);\n        p.setColor(getResources().getColor(R.color.colorPrimary));\n        c.drawCircle(100, 100, 100, p);\n        return circle;\n    }\n}\n```\n这俩方法 就是在2个新的bitmap上画圆和正方形\n注意是跟官方demo一致 ** 先画 正方形 后画 圆**\n满足条件\n**2、两个bitmap大小尽量一样。\n3、背景色为透明色。**\n\nonDraw中也设置了透明和开启硬件离屏缓存\n```\n setLayerType(LAYER_TYPE_HARDWARE, null);\n        Paint paint = new Paint();\n        /**\n         * 画bitmap的也透明\n         */\n        canvas.drawARGB(0, 0, 0, 0);\n```\n满足条件\n**1、开启硬件离屏缓存**（顺便说一下它的好处）\n    - 1.解决xfermode黑色问题。\n    - 2.效率比关闭硬件加速高3倍以上\n\n\n### 好正式开始 Xfermode的条件测试：\n\n```\npaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));\n```\n![PorterDuff.Mode.SRC](http://upload-images.jianshu.io/upload_images/1311457-754c0b6d61b351f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出圆的canvas背景（透明，activity本身就是白色，所以这里为白色）也显示出来并且覆盖在了正方形上面\n\n```\n paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));\n```\n![PorterDuff.Mode.DST](http://upload-images.jianshu.io/upload_images/1311457-0613ecff661625fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出后画的圆已经不显示了\n\n```\npaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n```\n![PorterDuff.Mode.SRC_IN](http://upload-images.jianshu.io/upload_images/1311457-2cb7351f70b49922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出圆的**canvas背景显示出来**， 只取了与正方形**相交的部分**（是canvas背景区域相交的部分），并且相交部分显示的是**后画**的**圆**的颜色\n\n```\n paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.DST_IN));\n```\n![PorterDuff.Mode.DST_IN](http://upload-images.jianshu.io/upload_images/1311457-969d4479ee7371f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出圆的**canvas背景显示出来**， 只取了与正方形**相交的部分**（是canvas背景区域相交的部分），并且相交部分显示的是**先画**的**正方形**的颜色\n```\n paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.XOR));\n```\n![PorterDuff.Mode.XOR](http://upload-images.jianshu.io/upload_images/1311457-354d41f24e1bafca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出取的是**相交部分之外**，并且与官方demo效果一致\n```\n paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.CLEAR));\n```\n![PorterDuff.Mode.CLEAR](http://upload-images.jianshu.io/upload_images/1311457-ac3954a3a64a9bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出**后画**的**圆**不见了 ，并且**相交的部分也不见了**\n\n这前面几个是相对比较常用，也是比较重要的。\n\n后面的我直接列出来\n\n\n![PorterDuff.Mode.SRC_OUT](http://upload-images.jianshu.io/upload_images/1311457-2d9284eef84de8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.SRC_ATOP](http://upload-images.jianshu.io/upload_images/1311457-414dc08dcc4d67a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.SRC_OVER](http://upload-images.jianshu.io/upload_images/1311457-1a2aa3a16595f547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.DST_OUT](http://upload-images.jianshu.io/upload_images/1311457-68b79dda92a19db6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.DST_ATOP](http://upload-images.jianshu.io/upload_images/1311457-eb5219787ee38ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.DST_OVER](http://upload-images.jianshu.io/upload_images/1311457-f3dc6a1420311882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.ADD](http://upload-images.jianshu.io/upload_images/1311457-4b0087f29d24e930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n![PorterDuff.Mode.MUTIPLY](http://upload-images.jianshu.io/upload_images/1311457-9650b3ed79cccab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.DARKEN](http://upload-images.jianshu.io/upload_images/1311457-f5c46b9049166e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.OVERPLAY](http://upload-images.jianshu.io/upload_images/1311457-90123e62d6385489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.SCREEN](http://upload-images.jianshu.io/upload_images/1311457-b9c3af1f7e50c5e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 总览全局\n\n![官方demo](http://upload-images.jianshu.io/upload_images/1311457-a84859d50c0765e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![我的](http://upload-images.jianshu.io/upload_images/1311457-1758f01d16feb3b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![第二篇文献里面的](http://upload-images.jianshu.io/upload_images/1311457-4641819c69a2b5fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n注：我的是跟官方demo一样先画正方形后画圆，第二篇文献里面的图是先画圆后画正方形，可以对比一下，体会一下。\n\n我说说我们的demo和官方api demo的区别：\n- 我的demo里面，两个bitmap大小一样，是在bitmap里面填充画满 circle和rectangle,并且在画两个Bitmap的时候，是调整的它的位置来画的；\n- 官方的demo里面，是两个bitmap大小一样，circle的bitmap里面只填充了 左上角2/3，而rectangle的bitmap里面只填充了 右下角的2/3，并且在画的时候，两个bitmap的位置大小都是一样的\n\n我的\n\n\n![circle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-e82d8c4b1c4e7c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![rectangle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-683334825b5b9b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\ncanvas.drawBitmap(rectangle,**100, 100**, paint);\ncanvas.drawBitmap(circle, 0, 0, paint);\n```\n\n官方的\n![circle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-0ac2c837454b7b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![rectangle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-9abd3d62e2f26c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\ncanvas.drawBitmap(mSrcB, **0, 0**, paint);\ncanvas.drawBitmap(mDstB, 0, 0, paint);\n```\n\n大家可以再去对比对比两张总结图，思考思考。\n如果想要探寻为什么不同的方法会导致不同的效果，也可以去阅读页首的第二篇文章\n\n### 总结\n如果你想要做出实际效果，那么你要按照官方的那种方式，你就能够做出跟网上普遍流传的那张图一样的效果。\n\n如果你要根据自己的实际情况来，那么你可能就要考虑我的这种方式和官方的那种方式来决定怎么做了。\n\n至于文首的问题，**原因如下：**\n因为我们的Xfermode 叠合裁剪，都是建立在不同的层级上，重新画一个bitmap会新开一层。\n第一种：先画circle 在canvas那层，再画Bitmap，新开了一层，中间镶嵌Xfermode，成功。\n第二种:   先画bitmap，新开了一层，再画circle，还是在bitmap那层，中间镶嵌 Xfermode,不成功。\n\n**解决方案：**\n```\n //第一种\n        \n        canvas.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, paint);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\n        canvas.drawBitmap(scaleBitmap, rect, rect1, paint);\n```\n\n```\n//第二种\n        canvas.drawBitmap(scaleBitmap, rect, rect1, paint);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n      \n        Bitmap bitmap = Bitmap.createBitmap(scaleBitmap.getWidth(), scaleBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        Canvas canvas1 = new Canvas(bitmap);\n        Paint p = new Paint();\n        canvas1.drawARGB(0, 0, 0, 0);\n        canvas1.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, p);\n        canvas.drawBitmap(bitmap, rect, rect1, paint);\n```\n\n**ps:** \n写这篇文章呢，主要是我个人想要实践一下，顺便记录一下实验结果。最后也顺便分享出来，个人感觉这里确实有很多坑，如果你是真正在研究PorterDuffXformode的人，那你肯定会跟我一样很疑惑，希望这篇文章能够带给你一个思路。\n\n","source":"_posts/android-PorterDuffXferMode真正的效果测试集合（对比官方demo）.md","raw":"layout: android\ntitle: android PorterDuffXferMode真正的效果测试集合（对比官方demo）\ndate: 2018-01-21 12:24:37\ntags: android\n---\n\n##### 前言\n当时在做头像imageView，就是切圆头像\n1、如果我们先画一个circle（非bitmap），然后setXfermode 为Src_In，再画一个bitmap(图片的)。成功，完美 。\n\n![成功](http://upload-images.jianshu.io/upload_images/1311457-1d790e3f8065c18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2、如果我们先画一个bitmap(图片的)，然后setXfermode 为Dsr_In,再画circle。粗略学习了网上那张图之后，理论上应该也是成功的，但是却出现了问题。\n\n![不成功](http://upload-images.jianshu.io/upload_images/1311457-cc02fd317d50ee46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以，我很疑惑，就开始了各种探索学习测试。（当然，至于为什么出现这种情况，文末会有解释）\n\n到目前为止已经被PorterDuffXferMode坑了有1天时间了，网上看了无数的文章，很乱很杂，没有写得能够让我很清楚很明白且有点权威的文献，因为很多没有测试结果，并且我没有亲身实践过，所以，现在我要重新自己动手实践一下。\n\n在网上搜罗了一大圈，在群里和很多人交流了，大概有2篇文章，个人认为说得在理。（建议大家先去看一下，不过可能你会跟我一样，看了之后就更云里雾里，但是还是需要亲身实践为好）\n\n感谢两位作者。\n\n[PorterDuffXferMode不正确的真正原因PorterDuffXferMode深入试验](http://m.blog.csdn.net/article/details?id=50534175)\n\n[Android中Canvas绘图之PorterDuffXfermode使用及工作原理详解](http://blog.csdn.net/iispring/article/details/50472485)\n\n**第一篇**主要总结：\n如果想让PorterDuffXferMode按照预期Demo（或者效果图）的效果图像实现，必须满足以下条件：\n**1、关闭硬件加速。（经过作者修改为 开启硬件离屏缓存）\n2、两个bitmap大小尽量一样。\n3、背景色为透明色。\n4、如果两个bitmap位置不完全一样，可能也是预期效果，只不过你看到的效果和你自己脑补的预期效果不一致。**\n\n**第二篇**主要总结：\n**PorterDuffXfermode用于实现新绘制的像素与Canvas上对应位置已有的像素按照混合规则进行颜色混合。**\n\n\n-----------------\n我主要是在第一篇的结论基础上去做测试，并给大家展示测试结果。\n下面高能篇幅，如果你不是真正在学习研究PorterDuffXfermode踩坑的人，如果你没有耐心阅读的，就可以别往下看了。\n亦或你也想亲手尝试，那还是先去尝试一下吧。\n\n-------\n\n首先代码图：\n```\npublic class TestXfermodeView extends View {\n    public TestXfermodeView(Context context) {\n        super(context);\n    }\n\n    public TestXfermodeView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public TestXfermodeView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        Bitmap circle = getCircleBitmap();\n        Bitmap rectangle = getRetangleBitmap();\n\n//        int sc = canvas.saveLayer(0, 0, 400, 400, null,\n//                Canvas.MATRIX_SAVE_FLAG |\n//                        Canvas.CLIP_SAVE_FLAG |\n//                        Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |\n//                        Canvas.FULL_COLOR_LAYER_SAVE_FLAG |\n//                        Canvas.CLIP_TO_LAYER_SAVE_FLAG);\n\n        /**\n         * 开启硬件离屏缓存\n         */\n        setLayerType(LAYER_TYPE_HARDWARE, null);\n        Paint paint = new Paint();\n        /**\n         * 画bitmap的也透明\n         */\n        canvas.drawARGB(0, 0, 0, 0);\n//        canvas.drawCircle(100, 100, 100, paint);\n        canvas.drawBitmap(rectangle, 100, 100, paint);\n//        Bitmap b= BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);\n//        Rect rect = new Rect(0, 0, 100, 100);\n//        canvas.drawBitmap(b,rect, rect, paint);\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER));\n\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OVER));\n\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XOR));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DARKEN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.OVERLAY));\n//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SCREEN));\n        canvas.drawBitmap(circle, 0, 0, paint);\n//        canvas.restoreToCount(sc);\n\n    }\n\n    @NonNull\n    private Bitmap getRetangleBitmap() {\n        /**\n         * bm1 在bitmap上面画正方形\n         */\n        Bitmap rectangle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);\n        Canvas c1 = new Canvas(rectangle);\n        Paint p1 = new Paint(Paint.ANTI_ALIAS_FLAG);\n        p1.setColor(getResources().getColor(R.color.colorAccent));\n        /**\n         * 设置透明\n         */\n        c1.drawARGB(0, 0, 0, 0);\n        c1.drawRect(0, 0, 200, 200, p1);\n        return rectangle;\n    }\n\n    @NonNull\n    private Bitmap getCircleBitmap() {\n        /**\n         * bm 在bitmap上面画圆\n         */\n        Bitmap circle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);\n        Canvas c = new Canvas(circle);\n        /**\n         * 设置透明\n         */\n        c.drawARGB(0, 0, 0, 0);\n        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);\n        p.setColor(getResources().getColor(R.color.colorPrimary));\n        c.drawCircle(100, 100, 100, p);\n        return circle;\n    }\n}\n```\n这俩方法 就是在2个新的bitmap上画圆和正方形\n注意是跟官方demo一致 ** 先画 正方形 后画 圆**\n满足条件\n**2、两个bitmap大小尽量一样。\n3、背景色为透明色。**\n\nonDraw中也设置了透明和开启硬件离屏缓存\n```\n setLayerType(LAYER_TYPE_HARDWARE, null);\n        Paint paint = new Paint();\n        /**\n         * 画bitmap的也透明\n         */\n        canvas.drawARGB(0, 0, 0, 0);\n```\n满足条件\n**1、开启硬件离屏缓存**（顺便说一下它的好处）\n    - 1.解决xfermode黑色问题。\n    - 2.效率比关闭硬件加速高3倍以上\n\n\n### 好正式开始 Xfermode的条件测试：\n\n```\npaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));\n```\n![PorterDuff.Mode.SRC](http://upload-images.jianshu.io/upload_images/1311457-754c0b6d61b351f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出圆的canvas背景（透明，activity本身就是白色，所以这里为白色）也显示出来并且覆盖在了正方形上面\n\n```\n paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));\n```\n![PorterDuff.Mode.DST](http://upload-images.jianshu.io/upload_images/1311457-0613ecff661625fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出后画的圆已经不显示了\n\n```\npaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n```\n![PorterDuff.Mode.SRC_IN](http://upload-images.jianshu.io/upload_images/1311457-2cb7351f70b49922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出圆的**canvas背景显示出来**， 只取了与正方形**相交的部分**（是canvas背景区域相交的部分），并且相交部分显示的是**后画**的**圆**的颜色\n\n```\n paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.DST_IN));\n```\n![PorterDuff.Mode.DST_IN](http://upload-images.jianshu.io/upload_images/1311457-969d4479ee7371f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出圆的**canvas背景显示出来**， 只取了与正方形**相交的部分**（是canvas背景区域相交的部分），并且相交部分显示的是**先画**的**正方形**的颜色\n```\n paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.XOR));\n```\n![PorterDuff.Mode.XOR](http://upload-images.jianshu.io/upload_images/1311457-354d41f24e1bafca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出取的是**相交部分之外**，并且与官方demo效果一致\n```\n paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.CLEAR));\n```\n![PorterDuff.Mode.CLEAR](http://upload-images.jianshu.io/upload_images/1311457-ac3954a3a64a9bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看出**后画**的**圆**不见了 ，并且**相交的部分也不见了**\n\n这前面几个是相对比较常用，也是比较重要的。\n\n后面的我直接列出来\n\n\n![PorterDuff.Mode.SRC_OUT](http://upload-images.jianshu.io/upload_images/1311457-2d9284eef84de8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.SRC_ATOP](http://upload-images.jianshu.io/upload_images/1311457-414dc08dcc4d67a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.SRC_OVER](http://upload-images.jianshu.io/upload_images/1311457-1a2aa3a16595f547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.DST_OUT](http://upload-images.jianshu.io/upload_images/1311457-68b79dda92a19db6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.DST_ATOP](http://upload-images.jianshu.io/upload_images/1311457-eb5219787ee38ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.DST_OVER](http://upload-images.jianshu.io/upload_images/1311457-f3dc6a1420311882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![PorterDuff.Mode.ADD](http://upload-images.jianshu.io/upload_images/1311457-4b0087f29d24e930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n![PorterDuff.Mode.MUTIPLY](http://upload-images.jianshu.io/upload_images/1311457-9650b3ed79cccab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.DARKEN](http://upload-images.jianshu.io/upload_images/1311457-f5c46b9049166e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.OVERPLAY](http://upload-images.jianshu.io/upload_images/1311457-90123e62d6385489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![PorterDuff.Mode.SCREEN](http://upload-images.jianshu.io/upload_images/1311457-b9c3af1f7e50c5e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 总览全局\n\n![官方demo](http://upload-images.jianshu.io/upload_images/1311457-a84859d50c0765e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![我的](http://upload-images.jianshu.io/upload_images/1311457-1758f01d16feb3b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![第二篇文献里面的](http://upload-images.jianshu.io/upload_images/1311457-4641819c69a2b5fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n注：我的是跟官方demo一样先画正方形后画圆，第二篇文献里面的图是先画圆后画正方形，可以对比一下，体会一下。\n\n我说说我们的demo和官方api demo的区别：\n- 我的demo里面，两个bitmap大小一样，是在bitmap里面填充画满 circle和rectangle,并且在画两个Bitmap的时候，是调整的它的位置来画的；\n- 官方的demo里面，是两个bitmap大小一样，circle的bitmap里面只填充了 左上角2/3，而rectangle的bitmap里面只填充了 右下角的2/3，并且在画的时候，两个bitmap的位置大小都是一样的\n\n我的\n\n\n![circle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-e82d8c4b1c4e7c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![rectangle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-683334825b5b9b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\ncanvas.drawBitmap(rectangle,**100, 100**, paint);\ncanvas.drawBitmap(circle, 0, 0, paint);\n```\n\n官方的\n![circle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-0ac2c837454b7b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![rectangle的bitmap](http://upload-images.jianshu.io/upload_images/1311457-9abd3d62e2f26c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\ncanvas.drawBitmap(mSrcB, **0, 0**, paint);\ncanvas.drawBitmap(mDstB, 0, 0, paint);\n```\n\n大家可以再去对比对比两张总结图，思考思考。\n如果想要探寻为什么不同的方法会导致不同的效果，也可以去阅读页首的第二篇文章\n\n### 总结\n如果你想要做出实际效果，那么你要按照官方的那种方式，你就能够做出跟网上普遍流传的那张图一样的效果。\n\n如果你要根据自己的实际情况来，那么你可能就要考虑我的这种方式和官方的那种方式来决定怎么做了。\n\n至于文首的问题，**原因如下：**\n因为我们的Xfermode 叠合裁剪，都是建立在不同的层级上，重新画一个bitmap会新开一层。\n第一种：先画circle 在canvas那层，再画Bitmap，新开了一层，中间镶嵌Xfermode，成功。\n第二种:   先画bitmap，新开了一层，再画circle，还是在bitmap那层，中间镶嵌 Xfermode,不成功。\n\n**解决方案：**\n```\n //第一种\n        \n        canvas.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, paint);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n\n        canvas.drawBitmap(scaleBitmap, rect, rect1, paint);\n```\n\n```\n//第二种\n        canvas.drawBitmap(scaleBitmap, rect, rect1, paint);\n\n        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n      \n        Bitmap bitmap = Bitmap.createBitmap(scaleBitmap.getWidth(), scaleBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        Canvas canvas1 = new Canvas(bitmap);\n        Paint p = new Paint();\n        canvas1.drawARGB(0, 0, 0, 0);\n        canvas1.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, p);\n        canvas.drawBitmap(bitmap, rect, rect1, paint);\n```\n\n**ps:** \n写这篇文章呢，主要是我个人想要实践一下，顺便记录一下实验结果。最后也顺便分享出来，个人感觉这里确实有很多坑，如果你是真正在研究PorterDuffXformode的人，那你肯定会跟我一样很疑惑，希望这篇文章能够带给你一个思路。\n\n","slug":"android-PorterDuffXferMode真正的效果测试集合（对比官方demo）","published":1,"updated":"2018-01-21T04:43:46.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjv000050cuskjgrh4kv","content":"<h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><p>当时在做头像imageView，就是切圆头像<br>1、如果我们先画一个circle（非bitmap），然后setXfermode 为Src_In，再画一个bitmap(图片的)。成功，完美 。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1d790e3f8065c18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"成功\"><br>2、如果我们先画一个bitmap(图片的)，然后setXfermode 为Dsr_In,再画circle。粗略学习了网上那张图之后，理论上应该也是成功的，但是却出现了问题。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-cc02fd317d50ee46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"不成功\"></p>\n<p>所以，我很疑惑，就开始了各种探索学习测试。（当然，至于为什么出现这种情况，文末会有解释）</p>\n<p>到目前为止已经被PorterDuffXferMode坑了有1天时间了，网上看了无数的文章，很乱很杂，没有写得能够让我很清楚很明白且有点权威的文献，因为很多没有测试结果，并且我没有亲身实践过，所以，现在我要重新自己动手实践一下。</p>\n<p>在网上搜罗了一大圈，在群里和很多人交流了，大概有2篇文章，个人认为说得在理。（建议大家先去看一下，不过可能你会跟我一样，看了之后就更云里雾里，但是还是需要亲身实践为好）</p>\n<p>感谢两位作者。</p>\n<p><a href=\"http://m.blog.csdn.net/article/details?id=50534175\" target=\"_blank\" rel=\"noopener\">PorterDuffXferMode不正确的真正原因PorterDuffXferMode深入试验</a></p>\n<p><a href=\"http://blog.csdn.net/iispring/article/details/50472485\" target=\"_blank\" rel=\"noopener\">Android中Canvas绘图之PorterDuffXfermode使用及工作原理详解</a></p>\n<p><strong>第一篇</strong>主要总结：<br>如果想让PorterDuffXferMode按照预期Demo（或者效果图）的效果图像实现，必须满足以下条件：<br><strong>1、关闭硬件加速。（经过作者修改为 开启硬件离屏缓存）<br>2、两个bitmap大小尽量一样。<br>3、背景色为透明色。<br>4、如果两个bitmap位置不完全一样，可能也是预期效果，只不过你看到的效果和你自己脑补的预期效果不一致。</strong></p>\n<p><strong>第二篇</strong>主要总结：<br><strong>PorterDuffXfermode用于实现新绘制的像素与Canvas上对应位置已有的像素按照混合规则进行颜色混合。</strong></p>\n<hr>\n<p>我主要是在第一篇的结论基础上去做测试，并给大家展示测试结果。<br>下面高能篇幅，如果你不是真正在学习研究PorterDuffXfermode踩坑的人，如果你没有耐心阅读的，就可以别往下看了。<br>亦或你也想亲手尝试，那还是先去尝试一下吧。</p>\n<hr>\n<p>首先代码图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestXfermodeView extends View &#123;</span><br><span class=\"line\">    public TestXfermodeView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestXfermodeView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestXfermodeView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        Bitmap circle = getCircleBitmap();</span><br><span class=\"line\">        Bitmap rectangle = getRetangleBitmap();</span><br><span class=\"line\"></span><br><span class=\"line\">//        int sc = canvas.saveLayer(0, 0, 400, 400, null,</span><br><span class=\"line\">//                Canvas.MATRIX_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.CLIP_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.FULL_COLOR_LAYER_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.CLIP_TO_LAYER_SAVE_FLAG);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 开启硬件离屏缓存</span><br><span class=\"line\">         */</span><br><span class=\"line\">        setLayerType(LAYER_TYPE_HARDWARE, null);</span><br><span class=\"line\">        Paint paint = new Paint();</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 画bitmap的也透明</span><br><span class=\"line\">         */</span><br><span class=\"line\">        canvas.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">//        canvas.drawCircle(100, 100, 100, paint);</span><br><span class=\"line\">        canvas.drawBitmap(rectangle, 100, 100, paint);</span><br><span class=\"line\">//        Bitmap b= BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);</span><br><span class=\"line\">//        Rect rect = new Rect(0, 0, 100, 100);</span><br><span class=\"line\">//        canvas.drawBitmap(b,rect, rect, paint);</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER));</span><br><span class=\"line\"></span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OVER));</span><br><span class=\"line\"></span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XOR));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DARKEN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.OVERLAY));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SCREEN));</span><br><span class=\"line\">        canvas.drawBitmap(circle, 0, 0, paint);</span><br><span class=\"line\">//        canvas.restoreToCount(sc);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private Bitmap getRetangleBitmap() &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * bm1 在bitmap上面画正方形</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Bitmap rectangle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);</span><br><span class=\"line\">        Canvas c1 = new Canvas(rectangle);</span><br><span class=\"line\">        Paint p1 = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        p1.setColor(getResources().getColor(R.color.colorAccent));</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 设置透明</span><br><span class=\"line\">         */</span><br><span class=\"line\">        c1.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">        c1.drawRect(0, 0, 200, 200, p1);</span><br><span class=\"line\">        return rectangle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private Bitmap getCircleBitmap() &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * bm 在bitmap上面画圆</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Bitmap circle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);</span><br><span class=\"line\">        Canvas c = new Canvas(circle);</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 设置透明</span><br><span class=\"line\">         */</span><br><span class=\"line\">        c.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        p.setColor(getResources().getColor(R.color.colorPrimary));</span><br><span class=\"line\">        c.drawCircle(100, 100, 100, p);</span><br><span class=\"line\">        return circle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这俩方法 就是在2个新的bitmap上画圆和正方形<br>注意是跟官方demo一致 <strong> 先画 正方形 后画 圆</strong><br>满足条件<br><strong>2、两个bitmap大小尽量一样。<br>3、背景色为透明色。</strong></p>\n<p>onDraw中也设置了透明和开启硬件离屏缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setLayerType(LAYER_TYPE_HARDWARE, null);</span><br><span class=\"line\">       Paint paint = new Paint();</span><br><span class=\"line\">       /**</span><br><span class=\"line\">        * 画bitmap的也透明</span><br><span class=\"line\">        */</span><br><span class=\"line\">       canvas.drawARGB(0, 0, 0, 0);</span><br></pre></td></tr></table></figure></p>\n<p>满足条件<br><strong>1、开启硬件离屏缓存</strong>（顺便说一下它的好处）</p>\n<pre><code>- 1.解决xfermode黑色问题。\n- 2.效率比关闭硬件加速高3倍以上\n</code></pre><h3 id=\"好正式开始-Xfermode的条件测试：\"><a href=\"#好正式开始-Xfermode的条件测试：\" class=\"headerlink\" title=\"好正式开始 Xfermode的条件测试：\"></a>好正式开始 Xfermode的条件测试：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-754c0b6d61b351f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC\"><br>可以看出圆的canvas背景（透明，activity本身就是白色，所以这里为白色）也显示出来并且覆盖在了正方形上面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0613ecff661625fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST\"><br>可以看出后画的圆已经不显示了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2cb7351f70b49922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_IN\"><br>可以看出圆的<strong>canvas背景显示出来</strong>， 只取了与正方形<strong>相交的部分</strong>（是canvas背景区域相交的部分），并且相交部分显示的是<strong>后画</strong>的<strong>圆</strong>的颜色</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-969d4479ee7371f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_IN\"><br>可以看出圆的<strong>canvas背景显示出来</strong>， 只取了与正方形<strong>相交的部分</strong>（是canvas背景区域相交的部分），并且相交部分显示的是<strong>先画</strong>的<strong>正方形</strong>的颜色<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.XOR));</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-354d41f24e1bafca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.XOR\"><br>可以看出取的是<strong>相交部分之外</strong>，并且与官方demo效果一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ac3954a3a64a9bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.CLEAR\"><br>可以看出<strong>后画</strong>的<strong>圆</strong>不见了 ，并且<strong>相交的部分也不见了</strong></p>\n<p>这前面几个是相对比较常用，也是比较重要的。</p>\n<p>后面的我直接列出来</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2d9284eef84de8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_OUT\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-414dc08dcc4d67a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_ATOP\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1a2aa3a16595f547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_OVER\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-68b79dda92a19db6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_OUT\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-eb5219787ee38ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_ATOP\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-f3dc6a1420311882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_OVER\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-4b0087f29d24e930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.ADD\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9650b3ed79cccab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.MUTIPLY\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-f5c46b9049166e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DARKEN\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-90123e62d6385489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.OVERPLAY\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b9c3af1f7e50c5e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SCREEN\"></p>\n<h3 id=\"总览全局\"><a href=\"#总览全局\" class=\"headerlink\" title=\"总览全局\"></a>总览全局</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a84859d50c0765e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"官方demo\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1758f01d16feb3b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"我的\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-4641819c69a2b5fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"第二篇文献里面的\"></p>\n<p>注：我的是跟官方demo一样先画正方形后画圆，第二篇文献里面的图是先画圆后画正方形，可以对比一下，体会一下。</p>\n<p>我说说我们的demo和官方api demo的区别：</p>\n<ul>\n<li>我的demo里面，两个bitmap大小一样，是在bitmap里面填充画满 circle和rectangle,并且在画两个Bitmap的时候，是调整的它的位置来画的；</li>\n<li>官方的demo里面，是两个bitmap大小一样，circle的bitmap里面只填充了 左上角2/3，而rectangle的bitmap里面只填充了 右下角的2/3，并且在画的时候，两个bitmap的位置大小都是一样的</li>\n</ul>\n<p>我的</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e82d8c4b1c4e7c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"circle的bitmap\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-683334825b5b9b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"rectangle的bitmap\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.drawBitmap(rectangle,**100, 100**, paint);</span><br><span class=\"line\">canvas.drawBitmap(circle, 0, 0, paint);</span><br></pre></td></tr></table></figure>\n<p>官方的<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0ac2c837454b7b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"circle的bitmap\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9abd3d62e2f26c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"rectangle的bitmap\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.drawBitmap(mSrcB, **0, 0**, paint);</span><br><span class=\"line\">canvas.drawBitmap(mDstB, 0, 0, paint);</span><br></pre></td></tr></table></figure></p>\n<p>大家可以再去对比对比两张总结图，思考思考。<br>如果想要探寻为什么不同的方法会导致不同的效果，也可以去阅读页首的第二篇文章</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果你想要做出实际效果，那么你要按照官方的那种方式，你就能够做出跟网上普遍流传的那张图一样的效果。</p>\n<p>如果你要根据自己的实际情况来，那么你可能就要考虑我的这种方式和官方的那种方式来决定怎么做了。</p>\n<p>至于文首的问题，<strong>原因如下：</strong><br>因为我们的Xfermode 叠合裁剪，都是建立在不同的层级上，重新画一个bitmap会新开一层。<br>第一种：先画circle 在canvas那层，再画Bitmap，新开了一层，中间镶嵌Xfermode，成功。<br>第二种:   先画bitmap，新开了一层，再画circle，还是在bitmap那层，中间镶嵌 Xfermode,不成功。</p>\n<p><strong>解决方案：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第一种</span><br><span class=\"line\">       </span><br><span class=\"line\">       canvas.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, paint);</span><br><span class=\"line\"></span><br><span class=\"line\">       paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class=\"line\"></span><br><span class=\"line\">       canvas.drawBitmap(scaleBitmap, rect, rect1, paint);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第二种</span><br><span class=\"line\">        canvas.drawBitmap(scaleBitmap, rect, rect1, paint);</span><br><span class=\"line\"></span><br><span class=\"line\">        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class=\"line\">      </span><br><span class=\"line\">        Bitmap bitmap = Bitmap.createBitmap(scaleBitmap.getWidth(), scaleBitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class=\"line\">        Canvas canvas1 = new Canvas(bitmap);</span><br><span class=\"line\">        Paint p = new Paint();</span><br><span class=\"line\">        canvas1.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">        canvas1.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, p);</span><br><span class=\"line\">        canvas.drawBitmap(bitmap, rect, rect1, paint);</span><br></pre></td></tr></table></figure>\n<p><strong>ps:</strong><br>写这篇文章呢，主要是我个人想要实践一下，顺便记录一下实验结果。最后也顺便分享出来，个人感觉这里确实有很多坑，如果你是真正在研究PorterDuffXformode的人，那你肯定会跟我一样很疑惑，希望这篇文章能够带给你一个思路。</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><p>当时在做头像imageView，就是切圆头像<br>1、如果我们先画一个circle（非bitmap），然后setXfermode 为Src_In，再画一个bitmap(图片的)。成功，完美 。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1d790e3f8065c18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"成功\"><br>2、如果我们先画一个bitmap(图片的)，然后setXfermode 为Dsr_In,再画circle。粗略学习了网上那张图之后，理论上应该也是成功的，但是却出现了问题。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-cc02fd317d50ee46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"不成功\"></p>\n<p>所以，我很疑惑，就开始了各种探索学习测试。（当然，至于为什么出现这种情况，文末会有解释）</p>\n<p>到目前为止已经被PorterDuffXferMode坑了有1天时间了，网上看了无数的文章，很乱很杂，没有写得能够让我很清楚很明白且有点权威的文献，因为很多没有测试结果，并且我没有亲身实践过，所以，现在我要重新自己动手实践一下。</p>\n<p>在网上搜罗了一大圈，在群里和很多人交流了，大概有2篇文章，个人认为说得在理。（建议大家先去看一下，不过可能你会跟我一样，看了之后就更云里雾里，但是还是需要亲身实践为好）</p>\n<p>感谢两位作者。</p>\n<p><a href=\"http://m.blog.csdn.net/article/details?id=50534175\" target=\"_blank\" rel=\"noopener\">PorterDuffXferMode不正确的真正原因PorterDuffXferMode深入试验</a></p>\n<p><a href=\"http://blog.csdn.net/iispring/article/details/50472485\" target=\"_blank\" rel=\"noopener\">Android中Canvas绘图之PorterDuffXfermode使用及工作原理详解</a></p>\n<p><strong>第一篇</strong>主要总结：<br>如果想让PorterDuffXferMode按照预期Demo（或者效果图）的效果图像实现，必须满足以下条件：<br><strong>1、关闭硬件加速。（经过作者修改为 开启硬件离屏缓存）<br>2、两个bitmap大小尽量一样。<br>3、背景色为透明色。<br>4、如果两个bitmap位置不完全一样，可能也是预期效果，只不过你看到的效果和你自己脑补的预期效果不一致。</strong></p>\n<p><strong>第二篇</strong>主要总结：<br><strong>PorterDuffXfermode用于实现新绘制的像素与Canvas上对应位置已有的像素按照混合规则进行颜色混合。</strong></p>\n<hr>\n<p>我主要是在第一篇的结论基础上去做测试，并给大家展示测试结果。<br>下面高能篇幅，如果你不是真正在学习研究PorterDuffXfermode踩坑的人，如果你没有耐心阅读的，就可以别往下看了。<br>亦或你也想亲手尝试，那还是先去尝试一下吧。</p>\n<hr>\n<p>首先代码图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestXfermodeView extends View &#123;</span><br><span class=\"line\">    public TestXfermodeView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestXfermodeView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestXfermodeView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        Bitmap circle = getCircleBitmap();</span><br><span class=\"line\">        Bitmap rectangle = getRetangleBitmap();</span><br><span class=\"line\"></span><br><span class=\"line\">//        int sc = canvas.saveLayer(0, 0, 400, 400, null,</span><br><span class=\"line\">//                Canvas.MATRIX_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.CLIP_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.FULL_COLOR_LAYER_SAVE_FLAG |</span><br><span class=\"line\">//                        Canvas.CLIP_TO_LAYER_SAVE_FLAG);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 开启硬件离屏缓存</span><br><span class=\"line\">         */</span><br><span class=\"line\">        setLayerType(LAYER_TYPE_HARDWARE, null);</span><br><span class=\"line\">        Paint paint = new Paint();</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 画bitmap的也透明</span><br><span class=\"line\">         */</span><br><span class=\"line\">        canvas.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">//        canvas.drawCircle(100, 100, 100, paint);</span><br><span class=\"line\">        canvas.drawBitmap(rectangle, 100, 100, paint);</span><br><span class=\"line\">//        Bitmap b= BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);</span><br><span class=\"line\">//        Rect rect = new Rect(0, 0, 100, 100);</span><br><span class=\"line\">//        canvas.drawBitmap(b,rect, rect, paint);</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER));</span><br><span class=\"line\"></span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OVER));</span><br><span class=\"line\"></span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XOR));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DARKEN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.OVERLAY));</span><br><span class=\"line\">//        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SCREEN));</span><br><span class=\"line\">        canvas.drawBitmap(circle, 0, 0, paint);</span><br><span class=\"line\">//        canvas.restoreToCount(sc);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private Bitmap getRetangleBitmap() &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * bm1 在bitmap上面画正方形</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Bitmap rectangle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);</span><br><span class=\"line\">        Canvas c1 = new Canvas(rectangle);</span><br><span class=\"line\">        Paint p1 = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        p1.setColor(getResources().getColor(R.color.colorAccent));</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 设置透明</span><br><span class=\"line\">         */</span><br><span class=\"line\">        c1.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">        c1.drawRect(0, 0, 200, 200, p1);</span><br><span class=\"line\">        return rectangle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    private Bitmap getCircleBitmap() &#123;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * bm 在bitmap上面画圆</span><br><span class=\"line\">         */</span><br><span class=\"line\">        Bitmap circle = Bitmap.createBitmap(200, 200, Bitmap.Config.ARGB_8888);</span><br><span class=\"line\">        Canvas c = new Canvas(circle);</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 设置透明</span><br><span class=\"line\">         */</span><br><span class=\"line\">        c.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class=\"line\">        p.setColor(getResources().getColor(R.color.colorPrimary));</span><br><span class=\"line\">        c.drawCircle(100, 100, 100, p);</span><br><span class=\"line\">        return circle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这俩方法 就是在2个新的bitmap上画圆和正方形<br>注意是跟官方demo一致 <strong> 先画 正方形 后画 圆</strong><br>满足条件<br><strong>2、两个bitmap大小尽量一样。<br>3、背景色为透明色。</strong></p>\n<p>onDraw中也设置了透明和开启硬件离屏缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setLayerType(LAYER_TYPE_HARDWARE, null);</span><br><span class=\"line\">       Paint paint = new Paint();</span><br><span class=\"line\">       /**</span><br><span class=\"line\">        * 画bitmap的也透明</span><br><span class=\"line\">        */</span><br><span class=\"line\">       canvas.drawARGB(0, 0, 0, 0);</span><br></pre></td></tr></table></figure></p>\n<p>满足条件<br><strong>1、开启硬件离屏缓存</strong>（顺便说一下它的好处）</p>\n<pre><code>- 1.解决xfermode黑色问题。\n- 2.效率比关闭硬件加速高3倍以上\n</code></pre><h3 id=\"好正式开始-Xfermode的条件测试：\"><a href=\"#好正式开始-Xfermode的条件测试：\" class=\"headerlink\" title=\"好正式开始 Xfermode的条件测试：\"></a>好正式开始 Xfermode的条件测试：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-754c0b6d61b351f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC\"><br>可以看出圆的canvas背景（透明，activity本身就是白色，所以这里为白色）也显示出来并且覆盖在了正方形上面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0613ecff661625fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST\"><br>可以看出后画的圆已经不显示了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2cb7351f70b49922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_IN\"><br>可以看出圆的<strong>canvas背景显示出来</strong>， 只取了与正方形<strong>相交的部分</strong>（是canvas背景区域相交的部分），并且相交部分显示的是<strong>后画</strong>的<strong>圆</strong>的颜色</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-969d4479ee7371f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_IN\"><br>可以看出圆的<strong>canvas背景显示出来</strong>， 只取了与正方形<strong>相交的部分</strong>（是canvas背景区域相交的部分），并且相交部分显示的是<strong>先画</strong>的<strong>正方形</strong>的颜色<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.XOR));</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-354d41f24e1bafca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.XOR\"><br>可以看出取的是<strong>相交部分之外</strong>，并且与官方demo效果一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setXfermode(newPorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ac3954a3a64a9bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.CLEAR\"><br>可以看出<strong>后画</strong>的<strong>圆</strong>不见了 ，并且<strong>相交的部分也不见了</strong></p>\n<p>这前面几个是相对比较常用，也是比较重要的。</p>\n<p>后面的我直接列出来</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2d9284eef84de8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_OUT\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-414dc08dcc4d67a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_ATOP\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1a2aa3a16595f547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SRC_OVER\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-68b79dda92a19db6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_OUT\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-eb5219787ee38ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_ATOP\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-f3dc6a1420311882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DST_OVER\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-4b0087f29d24e930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.ADD\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9650b3ed79cccab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.MUTIPLY\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-f5c46b9049166e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.DARKEN\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-90123e62d6385489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.OVERPLAY\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b9c3af1f7e50c5e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"PorterDuff.Mode.SCREEN\"></p>\n<h3 id=\"总览全局\"><a href=\"#总览全局\" class=\"headerlink\" title=\"总览全局\"></a>总览全局</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a84859d50c0765e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"官方demo\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1758f01d16feb3b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"我的\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-4641819c69a2b5fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"第二篇文献里面的\"></p>\n<p>注：我的是跟官方demo一样先画正方形后画圆，第二篇文献里面的图是先画圆后画正方形，可以对比一下，体会一下。</p>\n<p>我说说我们的demo和官方api demo的区别：</p>\n<ul>\n<li>我的demo里面，两个bitmap大小一样，是在bitmap里面填充画满 circle和rectangle,并且在画两个Bitmap的时候，是调整的它的位置来画的；</li>\n<li>官方的demo里面，是两个bitmap大小一样，circle的bitmap里面只填充了 左上角2/3，而rectangle的bitmap里面只填充了 右下角的2/3，并且在画的时候，两个bitmap的位置大小都是一样的</li>\n</ul>\n<p>我的</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e82d8c4b1c4e7c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"circle的bitmap\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-683334825b5b9b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"rectangle的bitmap\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.drawBitmap(rectangle,**100, 100**, paint);</span><br><span class=\"line\">canvas.drawBitmap(circle, 0, 0, paint);</span><br></pre></td></tr></table></figure>\n<p>官方的<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0ac2c837454b7b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"circle的bitmap\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9abd3d62e2f26c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"rectangle的bitmap\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.drawBitmap(mSrcB, **0, 0**, paint);</span><br><span class=\"line\">canvas.drawBitmap(mDstB, 0, 0, paint);</span><br></pre></td></tr></table></figure></p>\n<p>大家可以再去对比对比两张总结图，思考思考。<br>如果想要探寻为什么不同的方法会导致不同的效果，也可以去阅读页首的第二篇文章</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果你想要做出实际效果，那么你要按照官方的那种方式，你就能够做出跟网上普遍流传的那张图一样的效果。</p>\n<p>如果你要根据自己的实际情况来，那么你可能就要考虑我的这种方式和官方的那种方式来决定怎么做了。</p>\n<p>至于文首的问题，<strong>原因如下：</strong><br>因为我们的Xfermode 叠合裁剪，都是建立在不同的层级上，重新画一个bitmap会新开一层。<br>第一种：先画circle 在canvas那层，再画Bitmap，新开了一层，中间镶嵌Xfermode，成功。<br>第二种:   先画bitmap，新开了一层，再画circle，还是在bitmap那层，中间镶嵌 Xfermode,不成功。</p>\n<p><strong>解决方案：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第一种</span><br><span class=\"line\">       </span><br><span class=\"line\">       canvas.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, paint);</span><br><span class=\"line\"></span><br><span class=\"line\">       paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class=\"line\"></span><br><span class=\"line\">       canvas.drawBitmap(scaleBitmap, rect, rect1, paint);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第二种</span><br><span class=\"line\">        canvas.drawBitmap(scaleBitmap, rect, rect1, paint);</span><br><span class=\"line\"></span><br><span class=\"line\">        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class=\"line\">      </span><br><span class=\"line\">        Bitmap bitmap = Bitmap.createBitmap(scaleBitmap.getWidth(), scaleBitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class=\"line\">        Canvas canvas1 = new Canvas(bitmap);</span><br><span class=\"line\">        Paint p = new Paint();</span><br><span class=\"line\">        canvas1.drawARGB(0, 0, 0, 0);</span><br><span class=\"line\">        canvas1.drawCircle(scaleBitmap.getWidth() / 2, scaleBitmap.getHeight() / 2, scaleBitmap.getWidth() / 2, p);</span><br><span class=\"line\">        canvas.drawBitmap(bitmap, rect, rect1, paint);</span><br></pre></td></tr></table></figure>\n<p><strong>ps:</strong><br>写这篇文章呢，主要是我个人想要实践一下，顺便记录一下实验结果。最后也顺便分享出来，个人感觉这里确实有很多坑，如果你是真正在研究PorterDuffXformode的人，那你肯定会跟我一样很疑惑，希望这篇文章能够带给你一个思路。</p>\n"},{"layout":"android","title":"android scheme链接打开本地应用","date":"2018-01-21T04:29:19.000Z","_content":"大家都知道，如果我们想要打开手机本地的其他应用，我们可以通过**intent的隐式**启动，添加相关界面activity的包路径，来打开对应的应用和其界面。但这并不是万能的，因为**一来别人家的APP的包路径，不通过逆向手段是无法获知的，二来如果其打开界面本就需要传递一些参数才能正常开启，字段key你也不知道**。\n\n所以，Android系统也知道这种情况，所以才有了**scheme**这样的东西来**方便**我们的应用提供一个入口供别人开启。\n\n废话不多说先上[demo地址](https://github.com/fly7632785/SchemeDemo)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-e32a9849d8b9ae35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840)\n![](http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip)\n\n这篇文章主要讲述\n一、提供scheme供别人打开自己的应用\n二、webview中的网页链接打开应用\n三、有哪些现成的scheme url\n四、相关注意事项\n\n\n---------\n### 一、通过scheme提供开启自己应用的入口：\n方法很简单：\n在AndroidManifest.xml文件中的activity标签中添加intent-filter,并且添加data的scheme、host等，如图\n\n![](http://upload-images.jianshu.io/upload_images/1311457-1a561a637d421c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840)\n\n##### 注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\n\n这样就可以通过以下代码打开我们自己的app了\n```\nString url = \"jafir://main.app\" \n Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n                    startActivity(in);\n```\n\n\n**我们还可以通过这个url链接传递参数**\n传递参数有啥用呢？比如打开QQ的与某人的聊天界面，你肯定要传递一个qq号\n所以打开qq的链接一般为：\n**mqqwpa://im/chat?chat_type=wpa&uin=522648467**\n```\nString url = \"jafir://main.app?key=传递的参数\" \n Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n                    startActivity(in);\n```\n然后在MainActivity中通过如下代码获得\n```\n        Intent intent = getIntent();\n        String scheme = intent.getScheme();\n        Uri uri = intent.getData();\n        System.out.println(\"scheme:\"+scheme);\n        if (uri != null) {\n            String host = uri.getHost();\n            String dataString = intent.getDataString();\n            //获得参数值\n            String key1 = uri.getQueryParameter(\"key1\");\n      }  \n```\n效果图：\n\n![](http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip)\n\n\n\n### 二、 webview中链接打开应用\n我们都知道现在的网页web一般开启三方应用，比如开启迅雷，开启QQ临时对话等等，这些都是网页链接，但是网页链接确可以打开Android本地应用（前提是浏览器支持）。一个网页链接可以做到在电脑浏览器上打开PC软件，在手机浏览器上又是打开app，这是怎么回事呢？原因稍后解释\n\n在Android的webview中本是不支持直接打开本地应用的，所以我们就要自己来处理。\n\n\n```\n String url = \"http://wpa.qq.com/msgrd?v=3&uin=522648467&site=qq&menu=yes\";\n WebViewClient webViewClient = new WebViewClient() {\n            @Override\n            public boolean shouldOverrideUrlLoading(final WebView view, String url) {\n                if (url.startsWith(\"http\") || url.startsWith(\"https\")) { //http和https协议开头的执行正常的流程\n                    return false;\n                } else {  //其他的URL则会开启一个Acitity然后去调用原生APP\n                    Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n                    if (in.resolveActivity(getPackageManager()) == null) {\n                        //说明系统中不存在这个activity\n                        view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                Toast.makeText(MainActivity.this, \"应用未安装\", Toast.LENGTH_SHORT).show();\n                                view.loadUrl(failUrl);\n                            }\n                        });\n\n                    } else {\n                        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);\n                        startActivity(in);\n                        //如果想要加载成功跳转可以 这样\n                        view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                view.loadUrl(successUrl);\n                            }\n                        });\n                    }\n                    return true;\n                }\n            }\n        };\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(webViewClient);\n        webView.loadUrl(url);\n```\n网上的方法，普遍为这种：\n**通过在重定向的时候判断是否是普通的网页链接，如果不是则为scheme调用的这种，则我们自己来处理为intent跳转开启**\n\n**tips:**\n可以在成功的时候再``` view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                            view.loadUrl(successUrl);\n                            }\n                        });```然后就会自动跳转到成功的界面。successUrl是我本地的assets里面写的一个成功的html界面\n同理 可以在应用未安装失败的时候再``` //说明系统中不存在这个activity\n                        view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                Toast.makeText(MainActivity.this,\"应用未安装\",Toast.LENGTH_SHORT).show();\n                                view.loadUrl(failUrl);\n                            }\n                        });```然后就会自动跳转到失败的提示界面。failUrl是我本地的assets里面写的一个失败提示的html界面\n\n##### 测试通过网页链接打开QQ：\n###### 注意：\n我们在打印重定向url的时候发现，qq的url重定向了几次，最终在手机浏览器上呈现的形式就是scheme的形式：**mqqwpa://im/chat?chat_type=wpa&uin=522648467**\n为什么要重定向呢？就回到了之前上面提的那个问题，网页上使用的url：**http://wpa.qq.com/msgrd?v=3&uin=793563805&site=qq&menu=yes**这个在电脑浏览器上可以直接打开PC的qq，但是在手机上，重定向就是在判断和甄别是否是手机浏览器，如果是的话就会把url重定向为scheme形式的链接。\n\n并且这里要**注意**：**如果shouldOverrideUrlLoading返回的不是true，而是super，那么你会惊奇的发现，qq直接重定向到它自己的应用宝去了，哈哈，有点恶心**\n\n测试：\n我们在本地assets里面建一个html\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <title>JavaScript HTML App</title>\n</head>\n<body>\n    <!--<h1>已经打开APP啦！！！！</h1>-->\n <a target=\"_blank\" href=\" http://wpa.qq.com/msgrd?v=3&uin=522648467&site=qq&menu=yes\">打开qq</a>\n</body>\n</html>\n```\n\n然后直接打开\n```\nwebview.loadUrl(\"file:///android_asset/index.html\");\n```\n模拟webview中点击链接打开qq应用\n\n#### 注意：\n1、我们要想打开指定qq的临时聊天界面，需要那个qq已经开通了临时聊天界面，不然会报错。\n[在这里开启](http://shang.qq.com/v3/index.html)的**推广工具**中免费开通，不然的话它重定向的url就不是mqqwpa://chat... 而是 tencent://message...去了，直接调用intent就找不对对应的activity然后crash，所以要**确保你的对应qq号是已经开通了临时聊天的（推广）**。\n2、如果你想要点击了开启应用然后跳转到别的网页链接可以这么做\n```\n//在shouldInterceptRequest中重新加载\nview.post(new Runnable() {\n                        @Override\n                        public void run() {\n                            view.loadUrl(localUrl);\n                        }\n                    });\n```\n**注意**：因为webview的拦截线程不在主线程，所以可以用\n```webview.post(new runnable(){})```\n来实现\n\n效果图：由于模拟器上面没有x86 qq 所以，效果的话，你自己运行[demo](https://github.com/fly7632785/SchemeDemo)然后在手机上试吧\n\n### 有哪些应用的scheme url\n\n我这里整理了一下，有点多，没有全部测试过(网上搜罗而来，并非原创)\n```\nQQ的url是 mqq:// \n微信是weixin:// \n淘宝taobao:// \n点评dianping://\n dianping://search\n 微博 sinaweibo:// \n名片全能王camcard:// \nweico微博weico:// \n支付宝alipay:// \n豆瓣fm：doubanradio:// \n微盘 sinavdisk:// \n网易公开课ntesopen://\n美团 imeituan:// \n京冬openapp.jdmoble:// \n人人renren://\n 我查查 wcc:// \n1号店wccbyihaodian:// \n有道词典yddictproapp:// \n知乎zhihu://\n优酷 youku://\n```\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-62f9e36a5656ab3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-6bd04773176feacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-51e2ca8fbebd771e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-7b33516711742ec4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-e6e56fe463a39b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 四、注意事项\n其实写到最后发现，那些注意事项基本都是写到各项里面去了，觉得那样会好点。\n这里就写写思路吧：\n\n我们的应用如果需要提供给别人数据，那么用的是**contentProvider内容提供者**，如果是供别人打开的话用的是**scheme url intent隐式打开**，这里就就涉及到相关的一些被别人开启和使用的知识，联想到比如**launchMode**，提供给别人使用的界面一般情况下可能是用singleTask 或者某些特殊的会使用singleInstance，再者再深一点的还有**taskAffinity**相关，哪些提供出来的独立的界面在自己的任务栈还是在指定的任务栈里面，这些统统都是跟 **提供** 有关联。\n\n### 最后\n总之，我在写博客的之前并没有想到我要写这篇博客，但是在一步一步实践探索那些知识的时候确实就是踩了一些坑，所以还是想要记录下来分享，又想不能做的太水，于是要求内容稍微饱满，就这样逐渐逐渐思维发散，然后拼接整理，最终落下此文。\n\nps:如果文中有错误，请指正，谢谢。也欢迎广提意见，思维发散。\n","source":"_posts/android-scheme链接打开本地应用.md","raw":"layout: android\ntitle: android scheme链接打开本地应用\ndate: 2018-01-21 12:29:19\ntags: android \n---\n大家都知道，如果我们想要打开手机本地的其他应用，我们可以通过**intent的隐式**启动，添加相关界面activity的包路径，来打开对应的应用和其界面。但这并不是万能的，因为**一来别人家的APP的包路径，不通过逆向手段是无法获知的，二来如果其打开界面本就需要传递一些参数才能正常开启，字段key你也不知道**。\n\n所以，Android系统也知道这种情况，所以才有了**scheme**这样的东西来**方便**我们的应用提供一个入口供别人开启。\n\n废话不多说先上[demo地址](https://github.com/fly7632785/SchemeDemo)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-e32a9849d8b9ae35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840)\n![](http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip)\n\n这篇文章主要讲述\n一、提供scheme供别人打开自己的应用\n二、webview中的网页链接打开应用\n三、有哪些现成的scheme url\n四、相关注意事项\n\n\n---------\n### 一、通过scheme提供开启自己应用的入口：\n方法很简单：\n在AndroidManifest.xml文件中的activity标签中添加intent-filter,并且添加data的scheme、host等，如图\n\n![](http://upload-images.jianshu.io/upload_images/1311457-1a561a637d421c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840)\n\n##### 注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\n\n这样就可以通过以下代码打开我们自己的app了\n```\nString url = \"jafir://main.app\" \n Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n                    startActivity(in);\n```\n\n\n**我们还可以通过这个url链接传递参数**\n传递参数有啥用呢？比如打开QQ的与某人的聊天界面，你肯定要传递一个qq号\n所以打开qq的链接一般为：\n**mqqwpa://im/chat?chat_type=wpa&uin=522648467**\n```\nString url = \"jafir://main.app?key=传递的参数\" \n Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n                    startActivity(in);\n```\n然后在MainActivity中通过如下代码获得\n```\n        Intent intent = getIntent();\n        String scheme = intent.getScheme();\n        Uri uri = intent.getData();\n        System.out.println(\"scheme:\"+scheme);\n        if (uri != null) {\n            String host = uri.getHost();\n            String dataString = intent.getDataString();\n            //获得参数值\n            String key1 = uri.getQueryParameter(\"key1\");\n      }  \n```\n效果图：\n\n![](http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip)\n\n\n\n### 二、 webview中链接打开应用\n我们都知道现在的网页web一般开启三方应用，比如开启迅雷，开启QQ临时对话等等，这些都是网页链接，但是网页链接确可以打开Android本地应用（前提是浏览器支持）。一个网页链接可以做到在电脑浏览器上打开PC软件，在手机浏览器上又是打开app，这是怎么回事呢？原因稍后解释\n\n在Android的webview中本是不支持直接打开本地应用的，所以我们就要自己来处理。\n\n\n```\n String url = \"http://wpa.qq.com/msgrd?v=3&uin=522648467&site=qq&menu=yes\";\n WebViewClient webViewClient = new WebViewClient() {\n            @Override\n            public boolean shouldOverrideUrlLoading(final WebView view, String url) {\n                if (url.startsWith(\"http\") || url.startsWith(\"https\")) { //http和https协议开头的执行正常的流程\n                    return false;\n                } else {  //其他的URL则会开启一个Acitity然后去调用原生APP\n                    Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n                    if (in.resolveActivity(getPackageManager()) == null) {\n                        //说明系统中不存在这个activity\n                        view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                Toast.makeText(MainActivity.this, \"应用未安装\", Toast.LENGTH_SHORT).show();\n                                view.loadUrl(failUrl);\n                            }\n                        });\n\n                    } else {\n                        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);\n                        startActivity(in);\n                        //如果想要加载成功跳转可以 这样\n                        view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                view.loadUrl(successUrl);\n                            }\n                        });\n                    }\n                    return true;\n                }\n            }\n        };\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(webViewClient);\n        webView.loadUrl(url);\n```\n网上的方法，普遍为这种：\n**通过在重定向的时候判断是否是普通的网页链接，如果不是则为scheme调用的这种，则我们自己来处理为intent跳转开启**\n\n**tips:**\n可以在成功的时候再``` view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                            view.loadUrl(successUrl);\n                            }\n                        });```然后就会自动跳转到成功的界面。successUrl是我本地的assets里面写的一个成功的html界面\n同理 可以在应用未安装失败的时候再``` //说明系统中不存在这个activity\n                        view.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                Toast.makeText(MainActivity.this,\"应用未安装\",Toast.LENGTH_SHORT).show();\n                                view.loadUrl(failUrl);\n                            }\n                        });```然后就会自动跳转到失败的提示界面。failUrl是我本地的assets里面写的一个失败提示的html界面\n\n##### 测试通过网页链接打开QQ：\n###### 注意：\n我们在打印重定向url的时候发现，qq的url重定向了几次，最终在手机浏览器上呈现的形式就是scheme的形式：**mqqwpa://im/chat?chat_type=wpa&uin=522648467**\n为什么要重定向呢？就回到了之前上面提的那个问题，网页上使用的url：**http://wpa.qq.com/msgrd?v=3&uin=793563805&site=qq&menu=yes**这个在电脑浏览器上可以直接打开PC的qq，但是在手机上，重定向就是在判断和甄别是否是手机浏览器，如果是的话就会把url重定向为scheme形式的链接。\n\n并且这里要**注意**：**如果shouldOverrideUrlLoading返回的不是true，而是super，那么你会惊奇的发现，qq直接重定向到它自己的应用宝去了，哈哈，有点恶心**\n\n测试：\n我们在本地assets里面建一个html\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <title>JavaScript HTML App</title>\n</head>\n<body>\n    <!--<h1>已经打开APP啦！！！！</h1>-->\n <a target=\"_blank\" href=\" http://wpa.qq.com/msgrd?v=3&uin=522648467&site=qq&menu=yes\">打开qq</a>\n</body>\n</html>\n```\n\n然后直接打开\n```\nwebview.loadUrl(\"file:///android_asset/index.html\");\n```\n模拟webview中点击链接打开qq应用\n\n#### 注意：\n1、我们要想打开指定qq的临时聊天界面，需要那个qq已经开通了临时聊天界面，不然会报错。\n[在这里开启](http://shang.qq.com/v3/index.html)的**推广工具**中免费开通，不然的话它重定向的url就不是mqqwpa://chat... 而是 tencent://message...去了，直接调用intent就找不对对应的activity然后crash，所以要**确保你的对应qq号是已经开通了临时聊天的（推广）**。\n2、如果你想要点击了开启应用然后跳转到别的网页链接可以这么做\n```\n//在shouldInterceptRequest中重新加载\nview.post(new Runnable() {\n                        @Override\n                        public void run() {\n                            view.loadUrl(localUrl);\n                        }\n                    });\n```\n**注意**：因为webview的拦截线程不在主线程，所以可以用\n```webview.post(new runnable(){})```\n来实现\n\n效果图：由于模拟器上面没有x86 qq 所以，效果的话，你自己运行[demo](https://github.com/fly7632785/SchemeDemo)然后在手机上试吧\n\n### 有哪些应用的scheme url\n\n我这里整理了一下，有点多，没有全部测试过(网上搜罗而来，并非原创)\n```\nQQ的url是 mqq:// \n微信是weixin:// \n淘宝taobao:// \n点评dianping://\n dianping://search\n 微博 sinaweibo:// \n名片全能王camcard:// \nweico微博weico:// \n支付宝alipay:// \n豆瓣fm：doubanradio:// \n微盘 sinavdisk:// \n网易公开课ntesopen://\n美团 imeituan:// \n京冬openapp.jdmoble:// \n人人renren://\n 我查查 wcc:// \n1号店wccbyihaodian:// \n有道词典yddictproapp:// \n知乎zhihu://\n优酷 youku://\n```\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-62f9e36a5656ab3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-6bd04773176feacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-51e2ca8fbebd771e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-7b33516711742ec4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-e6e56fe463a39b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 四、注意事项\n其实写到最后发现，那些注意事项基本都是写到各项里面去了，觉得那样会好点。\n这里就写写思路吧：\n\n我们的应用如果需要提供给别人数据，那么用的是**contentProvider内容提供者**，如果是供别人打开的话用的是**scheme url intent隐式打开**，这里就就涉及到相关的一些被别人开启和使用的知识，联想到比如**launchMode**，提供给别人使用的界面一般情况下可能是用singleTask 或者某些特殊的会使用singleInstance，再者再深一点的还有**taskAffinity**相关，哪些提供出来的独立的界面在自己的任务栈还是在指定的任务栈里面，这些统统都是跟 **提供** 有关联。\n\n### 最后\n总之，我在写博客的之前并没有想到我要写这篇博客，但是在一步一步实践探索那些知识的时候确实就是踩了一些坑，所以还是想要记录下来分享，又想不能做的太水，于是要求内容稍微饱满，就这样逐渐逐渐思维发散，然后拼接整理，最终落下此文。\n\nps:如果文中有错误，请指正，谢谢。也欢迎广提意见，思维发散。\n","slug":"android-scheme链接打开本地应用","published":1,"updated":"2018-01-21T04:51:45.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjv200080cusb4ij6wb2","content":"<p>大家都知道，如果我们想要打开手机本地的其他应用，我们可以通过<strong>intent的隐式</strong>启动，添加相关界面activity的包路径，来打开对应的应用和其界面。但这并不是万能的，因为<strong>一来别人家的APP的包路径，不通过逆向手段是无法获知的，二来如果其打开界面本就需要传递一些参数才能正常开启，字段key你也不知道</strong>。</p>\n<p>所以，Android系统也知道这种情况，所以才有了<strong>scheme</strong>这样的东西来<strong>方便</strong>我们的应用提供一个入口供别人开启。</p>\n<p>废话不多说先上<a href=\"https://github.com/fly7632785/SchemeDemo\" target=\"_blank\" rel=\"noopener\">demo地址</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e32a9849d8b9ae35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>这篇文章主要讲述<br>一、提供scheme供别人打开自己的应用<br>二、webview中的网页链接打开应用<br>三、有哪些现成的scheme url<br>四、相关注意事项</p>\n<hr>\n<h3 id=\"一、通过scheme提供开启自己应用的入口：\"><a href=\"#一、通过scheme提供开启自己应用的入口：\" class=\"headerlink\" title=\"一、通过scheme提供开启自己应用的入口：\"></a>一、通过scheme提供开启自己应用的入口：</h3><p>方法很简单：<br>在AndroidManifest.xml文件中的activity标签中添加intent-filter,并且添加data的scheme、host等，如图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1a561a637d421c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840\" alt=\"\"></p>\n<h5 id=\"注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\"><a href=\"#注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\" class=\"headerlink\" title=\"注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\"></a>注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）</h5><p>这样就可以通过以下代码打开我们自己的app了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = &quot;jafir://main.app&quot; </span><br><span class=\"line\"> Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class=\"line\">                    startActivity(in);</span><br></pre></td></tr></table></figure></p>\n<p><strong>我们还可以通过这个url链接传递参数</strong><br>传递参数有啥用呢？比如打开QQ的与某人的聊天界面，你肯定要传递一个qq号<br>所以打开qq的链接一般为：<br><strong>mqqwpa://im/chat?chat_type=wpa&amp;uin=522648467</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = &quot;jafir://main.app?key=传递的参数&quot; </span><br><span class=\"line\"> Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class=\"line\">                    startActivity(in);</span><br></pre></td></tr></table></figure></p>\n<p>然后在MainActivity中通过如下代码获得<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Intent intent = getIntent();</span><br><span class=\"line\">  String scheme = intent.getScheme();</span><br><span class=\"line\">  Uri uri = intent.getData();</span><br><span class=\"line\">  System.out.println(&quot;scheme:&quot;+scheme);</span><br><span class=\"line\">  if (uri != null) &#123;</span><br><span class=\"line\">      String host = uri.getHost();</span><br><span class=\"line\">      String dataString = intent.getDataString();</span><br><span class=\"line\">      //获得参数值</span><br><span class=\"line\">      String key1 = uri.getQueryParameter(&quot;key1&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<h3 id=\"二、-webview中链接打开应用\"><a href=\"#二、-webview中链接打开应用\" class=\"headerlink\" title=\"二、 webview中链接打开应用\"></a>二、 webview中链接打开应用</h3><p>我们都知道现在的网页web一般开启三方应用，比如开启迅雷，开启QQ临时对话等等，这些都是网页链接，但是网页链接确可以打开Android本地应用（前提是浏览器支持）。一个网页链接可以做到在电脑浏览器上打开PC软件，在手机浏览器上又是打开app，这是怎么回事呢？原因稍后解释</p>\n<p>在Android的webview中本是不支持直接打开本地应用的，所以我们就要自己来处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = &quot;http://wpa.qq.com/msgrd?v=3&amp;uin=522648467&amp;site=qq&amp;menu=yes&quot;;</span><br><span class=\"line\">WebViewClient webViewClient = new WebViewClient() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public boolean shouldOverrideUrlLoading(final WebView view, String url) &#123;</span><br><span class=\"line\">               if (url.startsWith(&quot;http&quot;) || url.startsWith(&quot;https&quot;)) &#123; //http和https协议开头的执行正常的流程</span><br><span class=\"line\">                   return false;</span><br><span class=\"line\">               &#125; else &#123;  //其他的URL则会开启一个Acitity然后去调用原生APP</span><br><span class=\"line\">                   Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class=\"line\">                   if (in.resolveActivity(getPackageManager()) == null) &#123;</span><br><span class=\"line\">                       //说明系统中不存在这个activity</span><br><span class=\"line\">                       view.post(new Runnable() &#123;</span><br><span class=\"line\">                           @Override</span><br><span class=\"line\">                           public void run() &#123;</span><br><span class=\"line\">                               Toast.makeText(MainActivity.this, &quot;应用未安装&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">                               view.loadUrl(failUrl);</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                   &#125; else &#123;</span><br><span class=\"line\">                       in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span><br><span class=\"line\">                       startActivity(in);</span><br><span class=\"line\">                       //如果想要加载成功跳转可以 这样</span><br><span class=\"line\">                       view.post(new Runnable() &#123;</span><br><span class=\"line\">                           @Override</span><br><span class=\"line\">                           public void run() &#123;</span><br><span class=\"line\">                               view.loadUrl(successUrl);</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                   return true;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       webView = (WebView) findViewById(R.id.webview);</span><br><span class=\"line\">       webView.getSettings().setJavaScriptEnabled(true);</span><br><span class=\"line\">       webView.setWebViewClient(webViewClient);</span><br><span class=\"line\">       webView.loadUrl(url);</span><br></pre></td></tr></table></figure>\n<p>网上的方法，普遍为这种：<br><strong>通过在重定向的时候判断是否是普通的网页链接，如果不是则为scheme调用的这种，则我们自己来处理为intent跳转开启</strong></p>\n<p><strong>tips:</strong><br>可以在成功的时候再<figure class=\"highlight plain\"><figcaption><span>Runnable() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            @Override</span><br><span class=\"line\">                            public void run() &#123;</span><br><span class=\"line\">                            view.loadUrl(successUrl);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);```然后就会自动跳转到成功的界面。successUrl是我本地的assets里面写的一个成功的html界面</span><br><span class=\"line\">同理 可以在应用未安装失败的时候再``` //说明系统中不存在这个activity</span><br><span class=\"line\">                        view.post(new Runnable() &#123;</span><br><span class=\"line\">                            @Override</span><br><span class=\"line\">                            public void run() &#123;</span><br><span class=\"line\">                                Toast.makeText(MainActivity.this,&quot;应用未安装&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">                                view.loadUrl(failUrl);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);```然后就会自动跳转到失败的提示界面。failUrl是我本地的assets里面写的一个失败提示的html界面</span><br><span class=\"line\"></span><br><span class=\"line\">##### 测试通过网页链接打开QQ：</span><br><span class=\"line\">###### 注意：</span><br><span class=\"line\">我们在打印重定向url的时候发现，qq的url重定向了几次，最终在手机浏览器上呈现的形式就是scheme的形式：**mqqwpa://im/chat?chat_type=wpa&amp;uin=522648467**</span><br><span class=\"line\">为什么要重定向呢？就回到了之前上面提的那个问题，网页上使用的url：**http://wpa.qq.com/msgrd?v=3&amp;uin=793563805&amp;site=qq&amp;menu=yes**这个在电脑浏览器上可以直接打开PC的qq，但是在手机上，重定向就是在判断和甄别是否是手机浏览器，如果是的话就会把url重定向为scheme形式的链接。</span><br><span class=\"line\"></span><br><span class=\"line\">并且这里要**注意**：**如果shouldOverrideUrlLoading返回的不是true，而是super，那么你会惊奇的发现，qq直接重定向到它自己的应用宝去了，哈哈，有点恶心**</span><br><span class=\"line\"></span><br><span class=\"line\">测试：</span><br><span class=\"line\">我们在本地assets里面建一个html</span><br></pre></td></tr></table></figure></p>\n<p>&lt;!DOCTYPE html&gt;</p>\n<p><html lang=\"en\"></html></p>\n<p><head><br>    <meta charset=\"utf-8\"><br>    <title>JavaScript HTML App</title><br></head></p>\n<p><body><br>    <!--<h1>已经打开APP啦！！！！</h1>--><br> <a target=\"_blank\" href=\" http://wpa.qq.com/msgrd?v=3&uin=522648467&site=qq&menu=yes\">打开qq</a><br></body><br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">然后直接打开</span><br></pre></td></tr></table></figure></p>\n<p>webview.loadUrl(“file:///android_asset/index.html”);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">模拟webview中点击链接打开qq应用</span><br><span class=\"line\"></span><br><span class=\"line\">#### 注意：</span><br><span class=\"line\">1、我们要想打开指定qq的临时聊天界面，需要那个qq已经开通了临时聊天界面，不然会报错。</span><br><span class=\"line\">[在这里开启](http://shang.qq.com/v3/index.html)的**推广工具**中免费开通，不然的话它重定向的url就不是mqqwpa://chat... 而是 tencent://message...去了，直接调用intent就找不对对应的activity然后crash，所以要**确保你的对应qq号是已经开通了临时聊天的（推广）**。</span><br><span class=\"line\">2、如果你想要点击了开启应用然后跳转到别的网页链接可以这么做</span><br></pre></td></tr></table></figure></p>\n<p>//在shouldInterceptRequest中重新加载<br>view.post(new Runnable() {<br>                        @Override<br>                        public void run() {<br>                            view.loadUrl(localUrl);<br>                        }<br>                    });<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**注意**：因为webview的拦截线程不在主线程，所以可以用</span><br><span class=\"line\">```webview.post(new runnable()&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>来实现</p>\n<p>效果图：由于模拟器上面没有x86 qq 所以，效果的话，你自己运行<a href=\"https://github.com/fly7632785/SchemeDemo\" target=\"_blank\" rel=\"noopener\">demo</a>然后在手机上试吧</p>\n<h3 id=\"有哪些应用的scheme-url\"><a href=\"#有哪些应用的scheme-url\" class=\"headerlink\" title=\"有哪些应用的scheme url\"></a>有哪些应用的scheme url</h3><p>我这里整理了一下，有点多，没有全部测试过(网上搜罗而来，并非原创)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QQ的url是 mqq:// </span><br><span class=\"line\">微信是weixin:// </span><br><span class=\"line\">淘宝taobao:// </span><br><span class=\"line\">点评dianping://</span><br><span class=\"line\"> dianping://search</span><br><span class=\"line\"> 微博 sinaweibo:// </span><br><span class=\"line\">名片全能王camcard:// </span><br><span class=\"line\">weico微博weico:// </span><br><span class=\"line\">支付宝alipay:// </span><br><span class=\"line\">豆瓣fm：doubanradio:// </span><br><span class=\"line\">微盘 sinavdisk:// </span><br><span class=\"line\">网易公开课ntesopen://</span><br><span class=\"line\">美团 imeituan:// </span><br><span class=\"line\">京冬openapp.jdmoble:// </span><br><span class=\"line\">人人renren://</span><br><span class=\"line\"> 我查查 wcc:// </span><br><span class=\"line\">1号店wccbyihaodian:// </span><br><span class=\"line\">有道词典yddictproapp:// </span><br><span class=\"line\">知乎zhihu://</span><br><span class=\"line\">优酷 youku://</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-62f9e36a5656ab3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6bd04773176feacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-51e2ca8fbebd771e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-7b33516711742ec4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e6e56fe463a39b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"四、注意事项\"><a href=\"#四、注意事项\" class=\"headerlink\" title=\"四、注意事项\"></a>四、注意事项</h3><p>其实写到最后发现，那些注意事项基本都是写到各项里面去了，觉得那样会好点。<br>这里就写写思路吧：</p>\n<p>我们的应用如果需要提供给别人数据，那么用的是<strong>contentProvider内容提供者</strong>，如果是供别人打开的话用的是<strong>scheme url intent隐式打开</strong>，这里就就涉及到相关的一些被别人开启和使用的知识，联想到比如<strong>launchMode</strong>，提供给别人使用的界面一般情况下可能是用singleTask 或者某些特殊的会使用singleInstance，再者再深一点的还有<strong>taskAffinity</strong>相关，哪些提供出来的独立的界面在自己的任务栈还是在指定的任务栈里面，这些统统都是跟 <strong>提供</strong> 有关联。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>总之，我在写博客的之前并没有想到我要写这篇博客，但是在一步一步实践探索那些知识的时候确实就是踩了一些坑，所以还是想要记录下来分享，又想不能做的太水，于是要求内容稍微饱满，就这样逐渐逐渐思维发散，然后拼接整理，最终落下此文。</p>\n<p>ps:如果文中有错误，请指正，谢谢。也欢迎广提意见，思维发散。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>大家都知道，如果我们想要打开手机本地的其他应用，我们可以通过<strong>intent的隐式</strong>启动，添加相关界面activity的包路径，来打开对应的应用和其界面。但这并不是万能的，因为<strong>一来别人家的APP的包路径，不通过逆向手段是无法获知的，二来如果其打开界面本就需要传递一些参数才能正常开启，字段key你也不知道</strong>。</p>\n<p>所以，Android系统也知道这种情况，所以才有了<strong>scheme</strong>这样的东西来<strong>方便</strong>我们的应用提供一个入口供别人开启。</p>\n<p>废话不多说先上<a href=\"https://github.com/fly7632785/SchemeDemo\" target=\"_blank\" rel=\"noopener\">demo地址</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e32a9849d8b9ae35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>这篇文章主要讲述<br>一、提供scheme供别人打开自己的应用<br>二、webview中的网页链接打开应用<br>三、有哪些现成的scheme url<br>四、相关注意事项</p>\n<hr>\n<h3 id=\"一、通过scheme提供开启自己应用的入口：\"><a href=\"#一、通过scheme提供开启自己应用的入口：\" class=\"headerlink\" title=\"一、通过scheme提供开启自己应用的入口：\"></a>一、通过scheme提供开启自己应用的入口：</h3><p>方法很简单：<br>在AndroidManifest.xml文件中的activity标签中添加intent-filter,并且添加data的scheme、host等，如图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1a561a637d421c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840\" alt=\"\"></p>\n<h5 id=\"注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\"><a href=\"#注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\" class=\"headerlink\" title=\"注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）\"></a>注意：在MainActivity中要新写一个intent-filter，如果直接写在launcher打开的filter中则会app图标消失（因为category被覆盖为DEAFAULT）</h5><p>这样就可以通过以下代码打开我们自己的app了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = &quot;jafir://main.app&quot; </span><br><span class=\"line\"> Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class=\"line\">                    startActivity(in);</span><br></pre></td></tr></table></figure></p>\n<p><strong>我们还可以通过这个url链接传递参数</strong><br>传递参数有啥用呢？比如打开QQ的与某人的聊天界面，你肯定要传递一个qq号<br>所以打开qq的链接一般为：<br><strong>mqqwpa://im/chat?chat_type=wpa&amp;uin=522648467</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = &quot;jafir://main.app?key=传递的参数&quot; </span><br><span class=\"line\"> Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class=\"line\">                    startActivity(in);</span><br></pre></td></tr></table></figure></p>\n<p>然后在MainActivity中通过如下代码获得<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Intent intent = getIntent();</span><br><span class=\"line\">  String scheme = intent.getScheme();</span><br><span class=\"line\">  Uri uri = intent.getData();</span><br><span class=\"line\">  System.out.println(&quot;scheme:&quot;+scheme);</span><br><span class=\"line\">  if (uri != null) &#123;</span><br><span class=\"line\">      String host = uri.getHost();</span><br><span class=\"line\">      String dataString = intent.getDataString();</span><br><span class=\"line\">      //获得参数值</span><br><span class=\"line\">      String key1 = uri.getQueryParameter(&quot;key1&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b96e0bee3f01d5e2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<h3 id=\"二、-webview中链接打开应用\"><a href=\"#二、-webview中链接打开应用\" class=\"headerlink\" title=\"二、 webview中链接打开应用\"></a>二、 webview中链接打开应用</h3><p>我们都知道现在的网页web一般开启三方应用，比如开启迅雷，开启QQ临时对话等等，这些都是网页链接，但是网页链接确可以打开Android本地应用（前提是浏览器支持）。一个网页链接可以做到在电脑浏览器上打开PC软件，在手机浏览器上又是打开app，这是怎么回事呢？原因稍后解释</p>\n<p>在Android的webview中本是不支持直接打开本地应用的，所以我们就要自己来处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String url = &quot;http://wpa.qq.com/msgrd?v=3&amp;uin=522648467&amp;site=qq&amp;menu=yes&quot;;</span><br><span class=\"line\">WebViewClient webViewClient = new WebViewClient() &#123;</span><br><span class=\"line\">           @Override</span><br><span class=\"line\">           public boolean shouldOverrideUrlLoading(final WebView view, String url) &#123;</span><br><span class=\"line\">               if (url.startsWith(&quot;http&quot;) || url.startsWith(&quot;https&quot;)) &#123; //http和https协议开头的执行正常的流程</span><br><span class=\"line\">                   return false;</span><br><span class=\"line\">               &#125; else &#123;  //其他的URL则会开启一个Acitity然后去调用原生APP</span><br><span class=\"line\">                   Intent in = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class=\"line\">                   if (in.resolveActivity(getPackageManager()) == null) &#123;</span><br><span class=\"line\">                       //说明系统中不存在这个activity</span><br><span class=\"line\">                       view.post(new Runnable() &#123;</span><br><span class=\"line\">                           @Override</span><br><span class=\"line\">                           public void run() &#123;</span><br><span class=\"line\">                               Toast.makeText(MainActivity.this, &quot;应用未安装&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">                               view.loadUrl(failUrl);</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                   &#125; else &#123;</span><br><span class=\"line\">                       in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);</span><br><span class=\"line\">                       startActivity(in);</span><br><span class=\"line\">                       //如果想要加载成功跳转可以 这样</span><br><span class=\"line\">                       view.post(new Runnable() &#123;</span><br><span class=\"line\">                           @Override</span><br><span class=\"line\">                           public void run() &#123;</span><br><span class=\"line\">                               view.loadUrl(successUrl);</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                   return true;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\">       webView = (WebView) findViewById(R.id.webview);</span><br><span class=\"line\">       webView.getSettings().setJavaScriptEnabled(true);</span><br><span class=\"line\">       webView.setWebViewClient(webViewClient);</span><br><span class=\"line\">       webView.loadUrl(url);</span><br></pre></td></tr></table></figure>\n<p>网上的方法，普遍为这种：<br><strong>通过在重定向的时候判断是否是普通的网页链接，如果不是则为scheme调用的这种，则我们自己来处理为intent跳转开启</strong></p>\n<p><strong>tips:</strong><br>可以在成功的时候再<figure class=\"highlight plain\"><figcaption><span>Runnable() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                            @Override</span><br><span class=\"line\">                            public void run() &#123;</span><br><span class=\"line\">                            view.loadUrl(successUrl);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);```然后就会自动跳转到成功的界面。successUrl是我本地的assets里面写的一个成功的html界面</span><br><span class=\"line\">同理 可以在应用未安装失败的时候再``` //说明系统中不存在这个activity</span><br><span class=\"line\">                        view.post(new Runnable() &#123;</span><br><span class=\"line\">                            @Override</span><br><span class=\"line\">                            public void run() &#123;</span><br><span class=\"line\">                                Toast.makeText(MainActivity.this,&quot;应用未安装&quot;,Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">                                view.loadUrl(failUrl);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);```然后就会自动跳转到失败的提示界面。failUrl是我本地的assets里面写的一个失败提示的html界面</span><br><span class=\"line\"></span><br><span class=\"line\">##### 测试通过网页链接打开QQ：</span><br><span class=\"line\">###### 注意：</span><br><span class=\"line\">我们在打印重定向url的时候发现，qq的url重定向了几次，最终在手机浏览器上呈现的形式就是scheme的形式：**mqqwpa://im/chat?chat_type=wpa&amp;uin=522648467**</span><br><span class=\"line\">为什么要重定向呢？就回到了之前上面提的那个问题，网页上使用的url：**http://wpa.qq.com/msgrd?v=3&amp;uin=793563805&amp;site=qq&amp;menu=yes**这个在电脑浏览器上可以直接打开PC的qq，但是在手机上，重定向就是在判断和甄别是否是手机浏览器，如果是的话就会把url重定向为scheme形式的链接。</span><br><span class=\"line\"></span><br><span class=\"line\">并且这里要**注意**：**如果shouldOverrideUrlLoading返回的不是true，而是super，那么你会惊奇的发现，qq直接重定向到它自己的应用宝去了，哈哈，有点恶心**</span><br><span class=\"line\"></span><br><span class=\"line\">测试：</span><br><span class=\"line\">我们在本地assets里面建一个html</span><br></pre></td></tr></table></figure></p>\n<p>&lt;!DOCTYPE html&gt;</p>\n<p><html lang=\"en\"></html></p>\n<p><head><br>    <meta charset=\"utf-8\"><br>    <title>JavaScript HTML App</title><br></head></p>\n<p><body><br>    <!--<h1>已经打开APP啦！！！！</h1>--><br> <a target=\"_blank\" href=\" http://wpa.qq.com/msgrd?v=3&uin=522648467&site=qq&menu=yes\">打开qq</a><br></body><br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">然后直接打开</span><br></pre></td></tr></table></figure></p>\n<p>webview.loadUrl(“file:///android_asset/index.html”);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">模拟webview中点击链接打开qq应用</span><br><span class=\"line\"></span><br><span class=\"line\">#### 注意：</span><br><span class=\"line\">1、我们要想打开指定qq的临时聊天界面，需要那个qq已经开通了临时聊天界面，不然会报错。</span><br><span class=\"line\">[在这里开启](http://shang.qq.com/v3/index.html)的**推广工具**中免费开通，不然的话它重定向的url就不是mqqwpa://chat... 而是 tencent://message...去了，直接调用intent就找不对对应的activity然后crash，所以要**确保你的对应qq号是已经开通了临时聊天的（推广）**。</span><br><span class=\"line\">2、如果你想要点击了开启应用然后跳转到别的网页链接可以这么做</span><br></pre></td></tr></table></figure></p>\n<p>//在shouldInterceptRequest中重新加载<br>view.post(new Runnable() {<br>                        @Override<br>                        public void run() {<br>                            view.loadUrl(localUrl);<br>                        }<br>                    });<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**注意**：因为webview的拦截线程不在主线程，所以可以用</span><br><span class=\"line\">```webview.post(new runnable()&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>来实现</p>\n<p>效果图：由于模拟器上面没有x86 qq 所以，效果的话，你自己运行<a href=\"https://github.com/fly7632785/SchemeDemo\" target=\"_blank\" rel=\"noopener\">demo</a>然后在手机上试吧</p>\n<h3 id=\"有哪些应用的scheme-url\"><a href=\"#有哪些应用的scheme-url\" class=\"headerlink\" title=\"有哪些应用的scheme url\"></a>有哪些应用的scheme url</h3><p>我这里整理了一下，有点多，没有全部测试过(网上搜罗而来，并非原创)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QQ的url是 mqq:// </span><br><span class=\"line\">微信是weixin:// </span><br><span class=\"line\">淘宝taobao:// </span><br><span class=\"line\">点评dianping://</span><br><span class=\"line\"> dianping://search</span><br><span class=\"line\"> 微博 sinaweibo:// </span><br><span class=\"line\">名片全能王camcard:// </span><br><span class=\"line\">weico微博weico:// </span><br><span class=\"line\">支付宝alipay:// </span><br><span class=\"line\">豆瓣fm：doubanradio:// </span><br><span class=\"line\">微盘 sinavdisk:// </span><br><span class=\"line\">网易公开课ntesopen://</span><br><span class=\"line\">美团 imeituan:// </span><br><span class=\"line\">京冬openapp.jdmoble:// </span><br><span class=\"line\">人人renren://</span><br><span class=\"line\"> 我查查 wcc:// </span><br><span class=\"line\">1号店wccbyihaodian:// </span><br><span class=\"line\">有道词典yddictproapp:// </span><br><span class=\"line\">知乎zhihu://</span><br><span class=\"line\">优酷 youku://</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-62f9e36a5656ab3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6bd04773176feacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-51e2ca8fbebd771e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-7b33516711742ec4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e6e56fe463a39b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"四、注意事项\"><a href=\"#四、注意事项\" class=\"headerlink\" title=\"四、注意事项\"></a>四、注意事项</h3><p>其实写到最后发现，那些注意事项基本都是写到各项里面去了，觉得那样会好点。<br>这里就写写思路吧：</p>\n<p>我们的应用如果需要提供给别人数据，那么用的是<strong>contentProvider内容提供者</strong>，如果是供别人打开的话用的是<strong>scheme url intent隐式打开</strong>，这里就就涉及到相关的一些被别人开启和使用的知识，联想到比如<strong>launchMode</strong>，提供给别人使用的界面一般情况下可能是用singleTask 或者某些特殊的会使用singleInstance，再者再深一点的还有<strong>taskAffinity</strong>相关，哪些提供出来的独立的界面在自己的任务栈还是在指定的任务栈里面，这些统统都是跟 <strong>提供</strong> 有关联。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>总之，我在写博客的之前并没有想到我要写这篇博客，但是在一步一步实践探索那些知识的时候确实就是踩了一些坑，所以还是想要记录下来分享，又想不能做的太水，于是要求内容稍微饱满，就这样逐渐逐渐思维发散，然后拼接整理，最终落下此文。</p>\n<p>ps:如果文中有错误，请指正，谢谢。也欢迎广提意见，思维发散。</p>\n"},{"layout":"android","title":"android view的多种移动方式（测试集合）","date":"2018-01-21T04:28:00.000Z","_content":"### 前言\n由于最近在写一个涉及移动方面的自定义View，在做移动的时候用到了类似offsetTopAndBottom 、setTranslationY、scrollTo、scrollBy等方法，对于他们的使用，有一些不太清晰的地方。比如，view的getX/Y、getSrollX/Y、getTranslationX/Y、getLeft/top/right/bottom、点击事件触发区域等等 是否会受到影响改变，由哪些所影响。\n\n因为View的属性有点多，所以，很多时候你不知道哪些属性受哪些方法影响，并且多种方法联合使用的时候，效果又是如何，影响又是如何。\n\n### 正题\n于是我就开始测试，实践来检验结果。\n\n目前为止大致有这几种方法可以移动view:\n**1、setTranslationX/Y\n2、scrollTo/scrollBy\n3、offsetTopAndBottom/offsetLeftAndRight\n4、平移动画\n5、设置margin\n**\n\n主要是验证一些属性：\n**1、getX()、getY()\n2、getScrollX() 、getScrollY()\n3、getTranslationX() 、getTranslationY()\n4、getLeft()、 getTop()、 getRight()、 getBottom()（坐标位置是否改变）\n5、点击事件触发区域是否改变\n6、是否会影响同层级的其他view的位置\n7、超过父View是否绘制**\n\n\n现在主要把他们用一张表列出来：\n\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-48e8976caad5939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 稍微整理一下他们各自特点：\n###### setTranslationX/Y\n- getX getY 会变\n- getTranslationXY会变 \n- 点击事件的位置也变了但是不会超过父布局\n- 会超过边界到同级View的区域去（被覆盖或者覆盖别人）\n- 这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变（跟offset不同，它是通过坐标位置改变）\n\n###### scrollTo/scrollBy\n- getScrollXY 会变 \n- 点击事件还是在原位置 （跟动画类似）\n- 但是内容区域变了（如果超出自己的区域 就显示不出来）\n- 它只是内容区域的移动，本身view是不移动的\n- scrollBy的x y 是相对移动的值\n- scrollTo的x y 是绝对移动的值\n\n###### offsetTopAndBottom/offsetLeftAndRight\n- 上下左右坐标会变 （主要是通过坐标位置的改变产生移动效果）\n- getXY会变 \n- 点击事件的位置也变了\n- 会超过边界到别人的区域去（被覆盖或者覆盖别人）\n- 它的offY是相对移动的值\n\n###### 平移动画\n- 点击事件还是在原位置\n- 如果setFillAfter位置保留 但是其他任何坐标位置没有改变 再次点击从原位置重新开始移动\n\n###### 设置margin\n- 如果父View为wrap的话，设置margin可以移动，但是可能会对同级view造成影响（比如在linear中或者relative中有关联关系）\n\n\n#### 下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\n\n![](http://upload-images.jianshu.io/upload_images/1311457-ff7b4f4cbb30765d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![默认情况log](http://upload-images.jianshu.io/upload_images/1311457-860436f7fd2ec6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n##### setTranslationXY:\n\n![](http://upload-images.jianshu.io/upload_images/1311457-49e1cf0edfa63775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-d95b41e650dd9bc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![指定了父布局](http://upload-images.jianshu.io/upload_images/1311457-0abd4457d3be1261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![不能超过父布局，会显示不出来](http://upload-images.jianshu.io/upload_images/1311457-e9e76e59fe4a8458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![会超过边界到同层view的区域去（被覆盖或者覆盖别人）](http://upload-images.jianshu.io/upload_images/1311457-95fb206b842006dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n- getX getY 会变\n- getTranslationXY会变 \n- 点击事件的位置也变了但是不会超过父布局\n- 会超过边界到同层view的区域去（被覆盖或者覆盖别人--取决于先后顺序）\n\n\n##### scrollBy:\n\n![](http://upload-images.jianshu.io/upload_images/1311457-52ba8ec93da93e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-c2db3a444192d12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n##### offsetTopAndBottom offsetLeftAndRight:\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2f3913f3dbde5552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n##### 动画+setFillAfter(true):\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-90d34cbd7e59343f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n\n##### margin:\n\n![](http://upload-images.jianshu.io/upload_images/1311457-d9c9b0b400b88616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n![](http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n## 组合\n---\n#### 比如先多点几次 offset ，然后再margin会立马回到（原位置+margin）后的状态 \n\n![](http://upload-images.jianshu.io/upload_images/1311457-fed0c848512981f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2e3045b1227ece07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n **说明：**\n margin的平移效果是以view在父View中的位置和margin值决定的，是父View通过计算margin值之后，重新给你排的位置，实现的移动。当我们设置margin之后，会触发requestLayout,所以父VIew又重新给它排了位置。\n\n----\n\n#### 如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\n\n  **说明：**\n  动画不是根据位置来移动的，可能是根据一个metrix的矩阵变换来实现平移的（请指正）\n\n#### 如果，先scrollBy，然后再动画、offset和其他移动方法，\n\n![](http://upload-images.jianshu.io/upload_images/1311457-d45bbde6af792a2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2855f1a5a6aaf40f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n  **说明：**\n  其他的平移方法，都是对于view本身在做移动，而不像scrollBy只是对其内容进行平移\n\n\n\n\n## 总结\n好了，差多就这些了，其他更多复杂的组合使用，只要你能逐一弄清楚他们各自起作用的属性和对象，你就能大致摸索出来。\n剩下的大家可以去[demo](https://github.com/fly7632785/MyBookExplore)看看，然后自己试一试。\n\n\n\n","source":"_posts/android-view的多种移动方式（测试集合）.md","raw":"layout: android\ntitle: android view的多种移动方式（测试集合）\ndate: 2018-01-21 12:28:00\ntags: android\n---\n### 前言\n由于最近在写一个涉及移动方面的自定义View，在做移动的时候用到了类似offsetTopAndBottom 、setTranslationY、scrollTo、scrollBy等方法，对于他们的使用，有一些不太清晰的地方。比如，view的getX/Y、getSrollX/Y、getTranslationX/Y、getLeft/top/right/bottom、点击事件触发区域等等 是否会受到影响改变，由哪些所影响。\n\n因为View的属性有点多，所以，很多时候你不知道哪些属性受哪些方法影响，并且多种方法联合使用的时候，效果又是如何，影响又是如何。\n\n### 正题\n于是我就开始测试，实践来检验结果。\n\n目前为止大致有这几种方法可以移动view:\n**1、setTranslationX/Y\n2、scrollTo/scrollBy\n3、offsetTopAndBottom/offsetLeftAndRight\n4、平移动画\n5、设置margin\n**\n\n主要是验证一些属性：\n**1、getX()、getY()\n2、getScrollX() 、getScrollY()\n3、getTranslationX() 、getTranslationY()\n4、getLeft()、 getTop()、 getRight()、 getBottom()（坐标位置是否改变）\n5、点击事件触发区域是否改变\n6、是否会影响同层级的其他view的位置\n7、超过父View是否绘制**\n\n\n现在主要把他们用一张表列出来：\n\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-48e8976caad5939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 稍微整理一下他们各自特点：\n###### setTranslationX/Y\n- getX getY 会变\n- getTranslationXY会变 \n- 点击事件的位置也变了但是不会超过父布局\n- 会超过边界到同级View的区域去（被覆盖或者覆盖别人）\n- 这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变（跟offset不同，它是通过坐标位置改变）\n\n###### scrollTo/scrollBy\n- getScrollXY 会变 \n- 点击事件还是在原位置 （跟动画类似）\n- 但是内容区域变了（如果超出自己的区域 就显示不出来）\n- 它只是内容区域的移动，本身view是不移动的\n- scrollBy的x y 是相对移动的值\n- scrollTo的x y 是绝对移动的值\n\n###### offsetTopAndBottom/offsetLeftAndRight\n- 上下左右坐标会变 （主要是通过坐标位置的改变产生移动效果）\n- getXY会变 \n- 点击事件的位置也变了\n- 会超过边界到别人的区域去（被覆盖或者覆盖别人）\n- 它的offY是相对移动的值\n\n###### 平移动画\n- 点击事件还是在原位置\n- 如果setFillAfter位置保留 但是其他任何坐标位置没有改变 再次点击从原位置重新开始移动\n\n###### 设置margin\n- 如果父View为wrap的话，设置margin可以移动，但是可能会对同级view造成影响（比如在linear中或者relative中有关联关系）\n\n\n#### 下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\n\n![](http://upload-images.jianshu.io/upload_images/1311457-ff7b4f4cbb30765d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![默认情况log](http://upload-images.jianshu.io/upload_images/1311457-860436f7fd2ec6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n##### setTranslationXY:\n\n![](http://upload-images.jianshu.io/upload_images/1311457-49e1cf0edfa63775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-d95b41e650dd9bc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![指定了父布局](http://upload-images.jianshu.io/upload_images/1311457-0abd4457d3be1261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![不能超过父布局，会显示不出来](http://upload-images.jianshu.io/upload_images/1311457-e9e76e59fe4a8458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![会超过边界到同层view的区域去（被覆盖或者覆盖别人）](http://upload-images.jianshu.io/upload_images/1311457-95fb206b842006dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n- getX getY 会变\n- getTranslationXY会变 \n- 点击事件的位置也变了但是不会超过父布局\n- 会超过边界到同层view的区域去（被覆盖或者覆盖别人--取决于先后顺序）\n\n\n##### scrollBy:\n\n![](http://upload-images.jianshu.io/upload_images/1311457-52ba8ec93da93e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-c2db3a444192d12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n##### offsetTopAndBottom offsetLeftAndRight:\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2f3913f3dbde5552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n##### 动画+setFillAfter(true):\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-90d34cbd7e59343f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n\n##### margin:\n\n![](http://upload-images.jianshu.io/upload_images/1311457-d9c9b0b400b88616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n![](http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n## 组合\n---\n#### 比如先多点几次 offset ，然后再margin会立马回到（原位置+margin）后的状态 \n\n![](http://upload-images.jianshu.io/upload_images/1311457-fed0c848512981f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2e3045b1227ece07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n **说明：**\n margin的平移效果是以view在父View中的位置和margin值决定的，是父View通过计算margin值之后，重新给你排的位置，实现的移动。当我们设置margin之后，会触发requestLayout,所以父VIew又重新给它排了位置。\n\n----\n\n#### 如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\n\n  **说明：**\n  动画不是根据位置来移动的，可能是根据一个metrix的矩阵变换来实现平移的（请指正）\n\n#### 如果，先scrollBy，然后再动画、offset和其他移动方法，\n\n![](http://upload-images.jianshu.io/upload_images/1311457-d45bbde6af792a2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-2855f1a5a6aaf40f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)\n  **说明：**\n  其他的平移方法，都是对于view本身在做移动，而不像scrollBy只是对其内容进行平移\n\n\n\n\n## 总结\n好了，差多就这些了，其他更多复杂的组合使用，只要你能逐一弄清楚他们各自起作用的属性和对象，你就能大致摸索出来。\n剩下的大家可以去[demo](https://github.com/fly7632785/MyBookExplore)看看，然后自己试一试。\n\n\n\n","slug":"android-view的多种移动方式（测试集合）","published":1,"updated":"2018-01-21T04:44:45.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjv400090cusu09ahlyz","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>由于最近在写一个涉及移动方面的自定义View，在做移动的时候用到了类似offsetTopAndBottom 、setTranslationY、scrollTo、scrollBy等方法，对于他们的使用，有一些不太清晰的地方。比如，view的getX/Y、getSrollX/Y、getTranslationX/Y、getLeft/top/right/bottom、点击事件触发区域等等 是否会受到影响改变，由哪些所影响。</p>\n<p>因为View的属性有点多，所以，很多时候你不知道哪些属性受哪些方法影响，并且多种方法联合使用的时候，效果又是如何，影响又是如何。</p>\n<h3 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h3><p>于是我就开始测试，实践来检验结果。</p>\n<p>目前为止大致有这几种方法可以移动view:<br><strong>1、setTranslationX/Y<br>2、scrollTo/scrollBy<br>3、offsetTopAndBottom/offsetLeftAndRight<br>4、平移动画<br>5、设置margin\n</strong></p>\n<p>主要是验证一些属性：<br><strong>1、getX()、getY()<br>2、getScrollX() 、getScrollY()<br>3、getTranslationX() 、getTranslationY()<br>4、getLeft()、 getTop()、 getRight()、 getBottom()（坐标位置是否改变）<br>5、点击事件触发区域是否改变<br>6、是否会影响同层级的其他view的位置<br>7、超过父View是否绘制</strong></p>\n<p>现在主要把他们用一张表列出来：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-48e8976caad5939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h5 id=\"稍微整理一下他们各自特点：\"><a href=\"#稍微整理一下他们各自特点：\" class=\"headerlink\" title=\"稍微整理一下他们各自特点：\"></a>稍微整理一下他们各自特点：</h5><h6 id=\"setTranslationX-Y\"><a href=\"#setTranslationX-Y\" class=\"headerlink\" title=\"setTranslationX/Y\"></a>setTranslationX/Y</h6><ul>\n<li>getX getY 会变</li>\n<li>getTranslationXY会变 </li>\n<li>点击事件的位置也变了但是不会超过父布局</li>\n<li>会超过边界到同级View的区域去（被覆盖或者覆盖别人）</li>\n<li>这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变（跟offset不同，它是通过坐标位置改变）</li>\n</ul>\n<h6 id=\"scrollTo-scrollBy\"><a href=\"#scrollTo-scrollBy\" class=\"headerlink\" title=\"scrollTo/scrollBy\"></a>scrollTo/scrollBy</h6><ul>\n<li>getScrollXY 会变 </li>\n<li>点击事件还是在原位置 （跟动画类似）</li>\n<li>但是内容区域变了（如果超出自己的区域 就显示不出来）</li>\n<li>它只是内容区域的移动，本身view是不移动的</li>\n<li>scrollBy的x y 是相对移动的值</li>\n<li>scrollTo的x y 是绝对移动的值</li>\n</ul>\n<h6 id=\"offsetTopAndBottom-offsetLeftAndRight\"><a href=\"#offsetTopAndBottom-offsetLeftAndRight\" class=\"headerlink\" title=\"offsetTopAndBottom/offsetLeftAndRight\"></a>offsetTopAndBottom/offsetLeftAndRight</h6><ul>\n<li>上下左右坐标会变 （主要是通过坐标位置的改变产生移动效果）</li>\n<li>getXY会变 </li>\n<li>点击事件的位置也变了</li>\n<li>会超过边界到别人的区域去（被覆盖或者覆盖别人）</li>\n<li>它的offY是相对移动的值</li>\n</ul>\n<h6 id=\"平移动画\"><a href=\"#平移动画\" class=\"headerlink\" title=\"平移动画\"></a>平移动画</h6><ul>\n<li>点击事件还是在原位置</li>\n<li>如果setFillAfter位置保留 但是其他任何坐标位置没有改变 再次点击从原位置重新开始移动</li>\n</ul>\n<h6 id=\"设置margin\"><a href=\"#设置margin\" class=\"headerlink\" title=\"设置margin\"></a>设置margin</h6><ul>\n<li>如果父View为wrap的话，设置margin可以移动，但是可能会对同级view造成影响（比如在linear中或者relative中有关联关系）</li>\n</ul>\n<h4 id=\"下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\"><a href=\"#下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\" class=\"headerlink\" title=\"下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\"></a>下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ff7b4f4cbb30765d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-860436f7fd2ec6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"默认情况log\"></p>\n<h5 id=\"setTranslationXY\"><a href=\"#setTranslationXY\" class=\"headerlink\" title=\"setTranslationXY:\"></a>setTranslationXY:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-49e1cf0edfa63775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d95b41e650dd9bc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0abd4457d3be1261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"指定了父布局\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e9e76e59fe4a8458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"不能超过父布局，会显示不出来\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-95fb206b842006dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"会超过边界到同层view的区域去（被覆盖或者覆盖别人）\"></p>\n<ul>\n<li>getX getY 会变</li>\n<li>getTranslationXY会变 </li>\n<li>点击事件的位置也变了但是不会超过父布局</li>\n<li>会超过边界到同层view的区域去（被覆盖或者覆盖别人–取决于先后顺序）</li>\n</ul>\n<h5 id=\"scrollBy\"><a href=\"#scrollBy\" class=\"headerlink\" title=\"scrollBy:\"></a>scrollBy:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-52ba8ec93da93e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-c2db3a444192d12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h5 id=\"offsetTopAndBottom-offsetLeftAndRight-1\"><a href=\"#offsetTopAndBottom-offsetLeftAndRight-1\" class=\"headerlink\" title=\"offsetTopAndBottom offsetLeftAndRight:\"></a>offsetTopAndBottom offsetLeftAndRight:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2f3913f3dbde5552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h5 id=\"动画-setFillAfter-true\"><a href=\"#动画-setFillAfter-true\" class=\"headerlink\" title=\"动画+setFillAfter(true):\"></a>动画+setFillAfter(true):</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-90d34cbd7e59343f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h5 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin:\"></a>margin:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d9c9b0b400b88616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h2 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h2><hr>\n<h4 id=\"比如先多点几次-offset-，然后再margin会立马回到（原位置-margin）后的状态\"><a href=\"#比如先多点几次-offset-，然后再margin会立马回到（原位置-margin）后的状态\" class=\"headerlink\" title=\"比如先多点几次 offset ，然后再margin会立马回到（原位置+margin）后的状态\"></a>比如先多点几次 offset ，然后再margin会立马回到（原位置+margin）后的状态</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-fed0c848512981f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2e3045b1227ece07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p> <strong>说明：</strong><br> margin的平移效果是以view在父View中的位置和margin值决定的，是父View通过计算margin值之后，重新给你排的位置，实现的移动。当我们设置margin之后，会触发requestLayout,所以父VIew又重新给它排了位置。</p>\n<hr>\n<h4 id=\"如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\"><a href=\"#如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\" class=\"headerlink\" title=\"如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\"></a>如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。</h4><p>  <strong>说明：</strong><br>  动画不是根据位置来移动的，可能是根据一个metrix的矩阵变换来实现平移的（请指正）</p>\n<h4 id=\"如果，先scrollBy，然后再动画、offset和其他移动方法，\"><a href=\"#如果，先scrollBy，然后再动画、offset和其他移动方法，\" class=\"headerlink\" title=\"如果，先scrollBy，然后再动画、offset和其他移动方法，\"></a>如果，先scrollBy，然后再动画、offset和其他移动方法，</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d45bbde6af792a2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2855f1a5a6aaf40f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"><br>  <strong>说明：</strong><br>  其他的平移方法，都是对于view本身在做移动，而不像scrollBy只是对其内容进行平移</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，差多就这些了，其他更多复杂的组合使用，只要你能逐一弄清楚他们各自起作用的属性和对象，你就能大致摸索出来。<br>剩下的大家可以去<a href=\"https://github.com/fly7632785/MyBookExplore\" target=\"_blank\" rel=\"noopener\">demo</a>看看，然后自己试一试。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>由于最近在写一个涉及移动方面的自定义View，在做移动的时候用到了类似offsetTopAndBottom 、setTranslationY、scrollTo、scrollBy等方法，对于他们的使用，有一些不太清晰的地方。比如，view的getX/Y、getSrollX/Y、getTranslationX/Y、getLeft/top/right/bottom、点击事件触发区域等等 是否会受到影响改变，由哪些所影响。</p>\n<p>因为View的属性有点多，所以，很多时候你不知道哪些属性受哪些方法影响，并且多种方法联合使用的时候，效果又是如何，影响又是如何。</p>\n<h3 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h3><p>于是我就开始测试，实践来检验结果。</p>\n<p>目前为止大致有这几种方法可以移动view:<br><strong>1、setTranslationX/Y<br>2、scrollTo/scrollBy<br>3、offsetTopAndBottom/offsetLeftAndRight<br>4、平移动画<br>5、设置margin\n</strong></p>\n<p>主要是验证一些属性：<br><strong>1、getX()、getY()<br>2、getScrollX() 、getScrollY()<br>3、getTranslationX() 、getTranslationY()<br>4、getLeft()、 getTop()、 getRight()、 getBottom()（坐标位置是否改变）<br>5、点击事件触发区域是否改变<br>6、是否会影响同层级的其他view的位置<br>7、超过父View是否绘制</strong></p>\n<p>现在主要把他们用一张表列出来：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-48e8976caad5939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h5 id=\"稍微整理一下他们各自特点：\"><a href=\"#稍微整理一下他们各自特点：\" class=\"headerlink\" title=\"稍微整理一下他们各自特点：\"></a>稍微整理一下他们各自特点：</h5><h6 id=\"setTranslationX-Y\"><a href=\"#setTranslationX-Y\" class=\"headerlink\" title=\"setTranslationX/Y\"></a>setTranslationX/Y</h6><ul>\n<li>getX getY 会变</li>\n<li>getTranslationXY会变 </li>\n<li>点击事件的位置也变了但是不会超过父布局</li>\n<li>会超过边界到同级View的区域去（被覆盖或者覆盖别人）</li>\n<li>这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变（跟offset不同，它是通过坐标位置改变）</li>\n</ul>\n<h6 id=\"scrollTo-scrollBy\"><a href=\"#scrollTo-scrollBy\" class=\"headerlink\" title=\"scrollTo/scrollBy\"></a>scrollTo/scrollBy</h6><ul>\n<li>getScrollXY 会变 </li>\n<li>点击事件还是在原位置 （跟动画类似）</li>\n<li>但是内容区域变了（如果超出自己的区域 就显示不出来）</li>\n<li>它只是内容区域的移动，本身view是不移动的</li>\n<li>scrollBy的x y 是相对移动的值</li>\n<li>scrollTo的x y 是绝对移动的值</li>\n</ul>\n<h6 id=\"offsetTopAndBottom-offsetLeftAndRight\"><a href=\"#offsetTopAndBottom-offsetLeftAndRight\" class=\"headerlink\" title=\"offsetTopAndBottom/offsetLeftAndRight\"></a>offsetTopAndBottom/offsetLeftAndRight</h6><ul>\n<li>上下左右坐标会变 （主要是通过坐标位置的改变产生移动效果）</li>\n<li>getXY会变 </li>\n<li>点击事件的位置也变了</li>\n<li>会超过边界到别人的区域去（被覆盖或者覆盖别人）</li>\n<li>它的offY是相对移动的值</li>\n</ul>\n<h6 id=\"平移动画\"><a href=\"#平移动画\" class=\"headerlink\" title=\"平移动画\"></a>平移动画</h6><ul>\n<li>点击事件还是在原位置</li>\n<li>如果setFillAfter位置保留 但是其他任何坐标位置没有改变 再次点击从原位置重新开始移动</li>\n</ul>\n<h6 id=\"设置margin\"><a href=\"#设置margin\" class=\"headerlink\" title=\"设置margin\"></a>设置margin</h6><ul>\n<li>如果父View为wrap的话，设置margin可以移动，但是可能会对同级view造成影响（比如在linear中或者relative中有关联关系）</li>\n</ul>\n<h4 id=\"下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\"><a href=\"#下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\" class=\"headerlink\" title=\"下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）\"></a>下面是验证过程：（前方高能，多图预警！！！！！最重要的东西都罗列在前面了，没时间不用往下看了）</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ff7b4f4cbb30765d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-860436f7fd2ec6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"默认情况log\"></p>\n<h5 id=\"setTranslationXY\"><a href=\"#setTranslationXY\" class=\"headerlink\" title=\"setTranslationXY:\"></a>setTranslationXY:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-49e1cf0edfa63775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d95b41e650dd9bc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-0abd4457d3be1261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"指定了父布局\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e9e76e59fe4a8458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"不能超过父布局，会显示不出来\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-95fb206b842006dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"会超过边界到同层view的区域去（被覆盖或者覆盖别人）\"></p>\n<ul>\n<li>getX getY 会变</li>\n<li>getTranslationXY会变 </li>\n<li>点击事件的位置也变了但是不会超过父布局</li>\n<li>会超过边界到同层view的区域去（被覆盖或者覆盖别人–取决于先后顺序）</li>\n</ul>\n<h5 id=\"scrollBy\"><a href=\"#scrollBy\" class=\"headerlink\" title=\"scrollBy:\"></a>scrollBy:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-52ba8ec93da93e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-c2db3a444192d12e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h5 id=\"offsetTopAndBottom-offsetLeftAndRight-1\"><a href=\"#offsetTopAndBottom-offsetLeftAndRight-1\" class=\"headerlink\" title=\"offsetTopAndBottom offsetLeftAndRight:\"></a>offsetTopAndBottom offsetLeftAndRight:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2f3913f3dbde5552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h5 id=\"动画-setFillAfter-true\"><a href=\"#动画-setFillAfter-true\" class=\"headerlink\" title=\"动画+setFillAfter(true):\"></a>动画+setFillAfter(true):</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-90d34cbd7e59343f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h5 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin:\"></a>margin:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d9c9b0b400b88616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-5435c616ee7e5d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<h2 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h2><hr>\n<h4 id=\"比如先多点几次-offset-，然后再margin会立马回到（原位置-margin）后的状态\"><a href=\"#比如先多点几次-offset-，然后再margin会立马回到（原位置-margin）后的状态\" class=\"headerlink\" title=\"比如先多点几次 offset ，然后再margin会立马回到（原位置+margin）后的状态\"></a>比如先多点几次 offset ，然后再margin会立马回到（原位置+margin）后的状态</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-fed0c848512981f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2e3045b1227ece07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p> <strong>说明：</strong><br> margin的平移效果是以view在父View中的位置和margin值决定的，是父View通过计算margin值之后，重新给你排的位置，实现的移动。当我们设置margin之后，会触发requestLayout,所以父VIew又重新给它排了位置。</p>\n<hr>\n<h4 id=\"如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\"><a href=\"#如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\" class=\"headerlink\" title=\"如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。\"></a>如果，我先offset几次，然后再点击动画，动画会在原来的基础上，继续平移。</h4><p>  <strong>说明：</strong><br>  动画不是根据位置来移动的，可能是根据一个metrix的矩阵变换来实现平移的（请指正）</p>\n<h4 id=\"如果，先scrollBy，然后再动画、offset和其他移动方法，\"><a href=\"#如果，先scrollBy，然后再动画、offset和其他移动方法，\" class=\"headerlink\" title=\"如果，先scrollBy，然后再动画、offset和其他移动方法，\"></a>如果，先scrollBy，然后再动画、offset和其他移动方法，</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-d45bbde6af792a2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-2855f1a5a6aaf40f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440\" alt=\"\"><br>  <strong>说明：</strong><br>  其他的平移方法，都是对于view本身在做移动，而不像scrollBy只是对其内容进行平移</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，差多就这些了，其他更多复杂的组合使用，只要你能逐一弄清楚他们各自起作用的属性和对象，你就能大致摸索出来。<br>剩下的大家可以去<a href=\"https://github.com/fly7632785/MyBookExplore\" target=\"_blank\" rel=\"noopener\">demo</a>看看，然后自己试一试。</p>\n"},{"layout":"android","title":"写文件生成器的时候换行请用\\r\\n","date":"2018-01-21T04:34:19.000Z","_content":"### 前言\n最近在学习研究写文件生成器，中间遇到一个问题。\n就是，在生成了Activity之后，在Manifest文件中增加一个<activity>的标签，如果我要删除文件，也要从Manifest中清除这个标签。\n做法很简单，就是读取清单文件，然后往Application标签中插入一段新增的Activity标签。如果要删除，就读取清单文件，然后把里面这段Activity标签给移除掉。\n具体代码描述就是：\n1、生成的时候，读取file文件内容，然后indexOf Application标签，然后substring(0 - index） + activity标签代码 + sub（ index - length），然后再写入，这样就增加了代码\n2、删除的时候，读取file文件内容，然后直接replace 原来那段Activity标签代码为\"\" 空字符串\n### 问题\n逻辑很简单，但是却发现无论如何都没有达到replace的效果，测试contains，也依旧返回false，百思不得其解，调试N次，检查代码以及Activity标签代码，都无误。Android studio用对比工具进行比对也没有任何问题一模一样\n![对比1.png](http://upload-images.jianshu.io/upload_images/1311457-1887b413628bdc1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n最终无奈，只得自己亲自比对string(其实是比如charsequence,一个字符一个字符比对)，这才发现了端倪\n![对比2.png](http://upload-images.jianshu.io/upload_images/1311457-edd4441ba799a7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**原来是Android studio里面的所有文件的回车并不是单单一个\"\\n\"而是\"\\r\\n\"**\n而我们如果是单单从文件里面copy一段代码出来，然后直接放到string对象里面，转化后的换行就是**\\n**\n![copy.png](http://upload-images.jianshu.io/upload_images/1311457-6bad0cc02cd0e293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以这种情况，你需要手动加一个**\\r**才能解决问题\n### 总结\n这里再说一下\\r 和\\n的区别\n>\\r 回车是将光标移到一行的前面，\n>n 是移到下一行,相当于换行。\n\n出个简单的题：\n```\n        System.out.print(\"第一行\")\n        System.out.print(\"第1段\\r\")\n        System.out.print(\"1\")\n        System.out.print(\"第二行\")\n        System.out.print(\"第2段\\r\\n\")\n        System.out.print(\"第三行\")\n```\n打印出来是什么？\n直接说答案\n```\n1第二行第2段\n第三行\n```\n对，你没有看错。\n出现这种效果的原因是，/r是回到这行的前面，那么“第二行第二段”就从第一行开始，覆盖了原来的第一行了。\n所以，请大家以后记住，对文件的操作，如果是直接copy的，那么记得回车是**\\r\\n**！\n","source":"_posts/android-写文件生成器的时候换行请用\\r\\n.md","raw":"layout: android\ntitle: 写文件生成器的时候换行请用\\r\\n\ndate: 2018-01-21 12:34:19\ntags:\n---\n### 前言\n最近在学习研究写文件生成器，中间遇到一个问题。\n就是，在生成了Activity之后，在Manifest文件中增加一个<activity>的标签，如果我要删除文件，也要从Manifest中清除这个标签。\n做法很简单，就是读取清单文件，然后往Application标签中插入一段新增的Activity标签。如果要删除，就读取清单文件，然后把里面这段Activity标签给移除掉。\n具体代码描述就是：\n1、生成的时候，读取file文件内容，然后indexOf Application标签，然后substring(0 - index） + activity标签代码 + sub（ index - length），然后再写入，这样就增加了代码\n2、删除的时候，读取file文件内容，然后直接replace 原来那段Activity标签代码为\"\" 空字符串\n### 问题\n逻辑很简单，但是却发现无论如何都没有达到replace的效果，测试contains，也依旧返回false，百思不得其解，调试N次，检查代码以及Activity标签代码，都无误。Android studio用对比工具进行比对也没有任何问题一模一样\n![对比1.png](http://upload-images.jianshu.io/upload_images/1311457-1887b413628bdc1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n最终无奈，只得自己亲自比对string(其实是比如charsequence,一个字符一个字符比对)，这才发现了端倪\n![对比2.png](http://upload-images.jianshu.io/upload_images/1311457-edd4441ba799a7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**原来是Android studio里面的所有文件的回车并不是单单一个\"\\n\"而是\"\\r\\n\"**\n而我们如果是单单从文件里面copy一段代码出来，然后直接放到string对象里面，转化后的换行就是**\\n**\n![copy.png](http://upload-images.jianshu.io/upload_images/1311457-6bad0cc02cd0e293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以这种情况，你需要手动加一个**\\r**才能解决问题\n### 总结\n这里再说一下\\r 和\\n的区别\n>\\r 回车是将光标移到一行的前面，\n>n 是移到下一行,相当于换行。\n\n出个简单的题：\n```\n        System.out.print(\"第一行\")\n        System.out.print(\"第1段\\r\")\n        System.out.print(\"1\")\n        System.out.print(\"第二行\")\n        System.out.print(\"第2段\\r\\n\")\n        System.out.print(\"第三行\")\n```\n打印出来是什么？\n直接说答案\n```\n1第二行第2段\n第三行\n```\n对，你没有看错。\n出现这种效果的原因是，/r是回到这行的前面，那么“第二行第二段”就从第一行开始，覆盖了原来的第一行了。\n所以，请大家以后记住，对文件的操作，如果是直接copy的，那么记得回车是**\\r\\n**！\n","slug":"android-写文件生成器的时候换行请用\\r\\n","published":1,"updated":"2018-01-21T04:35:41.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjv8000c0cuss84bbidq","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在学习研究写文件生成器，中间遇到一个问题。<br>就是，在生成了Activity之后，在Manifest文件中增加一个<activity>的标签，如果我要删除文件，也要从Manifest中清除这个标签。<br>做法很简单，就是读取清单文件，然后往Application标签中插入一段新增的Activity标签。如果要删除，就读取清单文件，然后把里面这段Activity标签给移除掉。<br>具体代码描述就是：<br>1、生成的时候，读取file文件内容，然后indexOf Application标签，然后substring(0 - index） + activity标签代码 + sub（ index - length），然后再写入，这样就增加了代码<br>2、删除的时候，读取file文件内容，然后直接replace 原来那段Activity标签代码为”” 空字符串</activity></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>逻辑很简单，但是却发现无论如何都没有达到replace的效果，测试contains，也依旧返回false，百思不得其解，调试N次，检查代码以及Activity标签代码，都无误。Android studio用对比工具进行比对也没有任何问题一模一样<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1887b413628bdc1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对比1.png\"><br>最终无奈，只得自己亲自比对string(其实是比如charsequence,一个字符一个字符比对)，这才发现了端倪<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-edd4441ba799a7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对比2.png\"><br><strong>原来是Android studio里面的所有文件的回车并不是单单一个”\\n”而是”\\r\\n”</strong><br>而我们如果是单单从文件里面copy一段代码出来，然后直接放到string对象里面，转化后的换行就是<strong>\\n</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6bad0cc02cd0e293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"copy.png\"><br>所以这种情况，你需要手动加一个<strong>\\r</strong>才能解决问题</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这里再说一下\\r 和\\n的区别</p>\n<blockquote>\n<p>\\r 回车是将光标移到一行的前面，<br>n 是移到下一行,相当于换行。</p>\n</blockquote>\n<p>出个简单的题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(&quot;第一行&quot;)</span><br><span class=\"line\">System.out.print(&quot;第1段\\r&quot;)</span><br><span class=\"line\">System.out.print(&quot;1&quot;)</span><br><span class=\"line\">System.out.print(&quot;第二行&quot;)</span><br><span class=\"line\">System.out.print(&quot;第2段\\r\\n&quot;)</span><br><span class=\"line\">System.out.print(&quot;第三行&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>打印出来是什么？<br>直接说答案<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1第二行第2段</span><br><span class=\"line\">第三行</span><br></pre></td></tr></table></figure></p>\n<p>对，你没有看错。<br>出现这种效果的原因是，/r是回到这行的前面，那么“第二行第二段”就从第一行开始，覆盖了原来的第一行了。<br>所以，请大家以后记住，对文件的操作，如果是直接copy的，那么记得回车是<strong>\\r\\n</strong>！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在学习研究写文件生成器，中间遇到一个问题。<br>就是，在生成了Activity之后，在Manifest文件中增加一个<activity>的标签，如果我要删除文件，也要从Manifest中清除这个标签。<br>做法很简单，就是读取清单文件，然后往Application标签中插入一段新增的Activity标签。如果要删除，就读取清单文件，然后把里面这段Activity标签给移除掉。<br>具体代码描述就是：<br>1、生成的时候，读取file文件内容，然后indexOf Application标签，然后substring(0 - index） + activity标签代码 + sub（ index - length），然后再写入，这样就增加了代码<br>2、删除的时候，读取file文件内容，然后直接replace 原来那段Activity标签代码为”” 空字符串</activity></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>逻辑很简单，但是却发现无论如何都没有达到replace的效果，测试contains，也依旧返回false，百思不得其解，调试N次，检查代码以及Activity标签代码，都无误。Android studio用对比工具进行比对也没有任何问题一模一样<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-1887b413628bdc1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对比1.png\"><br>最终无奈，只得自己亲自比对string(其实是比如charsequence,一个字符一个字符比对)，这才发现了端倪<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-edd4441ba799a7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对比2.png\"><br><strong>原来是Android studio里面的所有文件的回车并不是单单一个”\\n”而是”\\r\\n”</strong><br>而我们如果是单单从文件里面copy一段代码出来，然后直接放到string对象里面，转化后的换行就是<strong>\\n</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-6bad0cc02cd0e293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"copy.png\"><br>所以这种情况，你需要手动加一个<strong>\\r</strong>才能解决问题</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这里再说一下\\r 和\\n的区别</p>\n<blockquote>\n<p>\\r 回车是将光标移到一行的前面，<br>n 是移到下一行,相当于换行。</p>\n</blockquote>\n<p>出个简单的题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(&quot;第一行&quot;)</span><br><span class=\"line\">System.out.print(&quot;第1段\\r&quot;)</span><br><span class=\"line\">System.out.print(&quot;1&quot;)</span><br><span class=\"line\">System.out.print(&quot;第二行&quot;)</span><br><span class=\"line\">System.out.print(&quot;第2段\\r\\n&quot;)</span><br><span class=\"line\">System.out.print(&quot;第三行&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>打印出来是什么？<br>直接说答案<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1第二行第2段</span><br><span class=\"line\">第三行</span><br></pre></td></tr></table></figure></p>\n<p>对，你没有看错。<br>出现这种效果的原因是，/r是回到这行的前面，那么“第二行第二段”就从第一行开始，覆盖了原来的第一行了。<br>所以，请大家以后记住，对文件的操作，如果是直接copy的，那么记得回车是<strong>\\r\\n</strong>！</p>\n"},{"layout":"android","title":"android greendao3.0 多表关联踩坑实践","date":"2018-01-21T04:30:32.000Z","_content":"#### 前言\n之前用过数据库框架：realm、kjdb，今天准备实践学习一下greendao 3.0。\ngreendao 3.0之前的版本有很大的不同，主要是增加了annotation注解，然后表之间和对象之间的关系也通过注解而变得更加灵活方便了。以前用过旧版本的都知道，对于多表多对象之间的关联，要写的代码不少。\n\n我在学习greendao 3.0的时候，有一个感触，网上的文章很多，但是千篇一律，大多都是翻译官方文档而来，举得例子可谓是“无一例外”。网上搜罗了半天，收藏几篇比较好的帖子。\n[史上最高效的ORM方案——GreenDao3.0详解](http://www.open-open.com/lib/view/open1480319783903.html)\n[[Android ORM——初识greenDAO 3及使用greenDAO 3前应该掌握的一些知识点（一）](http://blog.csdn.net/crazymo_/article/details/54629916)](http://blog.csdn.net/crazymo_/article/details/54629916)\n\n特别是关于3.0对象多表多对象关联的博客更是没有，所以打算自己实践学习然后总结分享一番。\n\n#### 踩坑\n主要踩了两个坑：\n- greendao的关联关系是通过**主外键（对象之间关联的id）**来构建的。realm是直接通过对象关系来自动构建的。\n- 如果属性是List<> xx,  greendao不会自动调用设置xx的值，只有**手动调用getXX的时候获取**.我在打印log的时候被坑惨了，无论怎么样都是为null.\n\n#### 发现\n- 首先bean类，会自动生成一些方法，比如get set 构造方法 getSession等\n- 如果是list或者数组类型的属性XX，只有getXX方法，没有setXX方法\n- 如果你要打印bean类的toString方法，这里**要调用getXXX方法，而不是直接打印对象**（因为没有赋值,而是在getXX的时候才赋值的）\n```\n    @Override\n    public String toString() {\n        return \"Person{\" +\n               \"students=\" + getStudents() +  //这里不是直接students\n                \", id=\" + id +\n                \", cardId=\" + cardId +\n                \", age=\" + age +\n                \", name='\" + name + '\\'' +\n                \", average=\" + average +\n                \", cid=\" + cid +\n                \", cls=\" + cls +\n                \", fid=\" + fid +\n                \", friends=\" + getFriends() +\n                '}';\n    }\n```\n- greendao支持 自身对自身的关系关联，比如\n\n![](http://upload-images.jianshu.io/upload_images/1311457-73bf8704cedd9252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n---\n\n## 正文： 多表映射关联\n\n#### 一对一：比如一个人有一个头\n如果是按照以往的对象关系数据库\n```\n#person类中\n\n   @Id(autoincrement = true)\n    private Long id;\n    private String name;\n\n//    private Long hid;\n    @ToOne\n    private Head head;\n```\n```\n  Head head = new Head();\n        head.setId(13l);\n        head.setName(\"head\");\n\n        Person p = new Person();\n        p.setId(null);\n        p.setHead(head);//直接设置对象\n        p.setName(\"jafir\");\n```\n直接写对象，然后setHead(head) 就搞定了。但是在greendao中一切对象关联关系都是通过主外键来实现的。应该改为如下：\n```\n#person类中\n  @Id(autoincrement = true)\n    private Long id;\n    private String name;\n\n    private Long hid;//这是与头关联的外键\n    @ToOne(joinProperty = \"hid\") //这个是注解绑定 hid就是上面一行的hid\n    private Head head;//对象，但是不需要setHead\n```\n\nbuild之后，就有setHid的方法了，我们的对象关联不采用setHead,而是setHid\n```\nPersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();\n        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();\n\n        Head head = new Head();\n        head.setId(13l);//这里的head id和person里的hid一样\n        head.setName(\"head\");\n\n        Person p = new Person();\n        p.setId(null);\n        p.setHid(13l);//这里的hid是head的id,就是这样通过id构建起关联的\n        p.setName(\"jafir\");\n\n        headDao.insert(head);\n        personDao.insert(p);\n\n        List<Person> persons = personDao.queryBuilder().build().list();\n        for (Person person : persons) {\n            Log.d(\"debug\",\"person:\"+person.toString());\n        }\n```\n注意：person的toString()方法系统生成的需要修改一下：\n```\n @Override\n    public String toString() {\n        return \"Person{\" +\n                \"head=\" + getHead() +//这里需要改为getHead\n                \", name='\" + name + '\\'' +\n                \", id=\" + id +\n                '}';\n    }\n```\n###### tips:\n- bean的id最好用Long类型而不是long\n```\n @Id(autoincrement = true)\nprivate Long id;\nPerson p = new Person();\n        p.setId(null);\n        p.setHid(14l);\n        p.setName(\"jafir\");\n```\n因为，如果**Long**,我们设置了id是自增长,我们可以```setId(null)```,便是自增长。如果是**long**类型，你设置```setId(null)```，就报空指针。\n\n#### 一对多：比如一个老师有多个学生\n```\n#teacher类中\n @ToMany(referencedJoinProperty = \"tid\")//指定与之关联的其他类的id\n private List<Student> studnets;\n```\n```\n#student类中\n  @Id\n  private Long id;\n  private Long tid;//这个就是外键 就是person的id\n```\n关系描述：\n多个学生都有同一个老师，所以每个学生的tid，就应该是同样的，并且tid 就是老师的id ,这样就构成了1对多的关系\n\n![](http://upload-images.jianshu.io/upload_images/1311457-ce1187ae365babec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n注意：学生的自增长id ,跟与老师关联的tid是不一样的，两码事\n\n#### 一对多：比如一个人有一群朋友（朋友也是person）\n按照我们上面的思路，那么person类里面就应该有一个外键指向自身的主键id\n```\n#person类中\n private Long id;//自身id\n private Long fid;//外键关联id\n @ToMany(referencedJoinProperty =\"fid\" )//指定与之关联的其他类的id\n private List<Person> friends;\n```\n\n![](http://upload-images.jianshu.io/upload_images/1311457-3c4924653fee9baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n如果一个人的id是1，他有3个朋友，那么friends里面person的fid都是1，这样这个人调用getFriends就能拿到自己的3个朋友。主要就是通过设置id来构建关联关系的。\n\n\n#### 多对多：\n多对多的话就比较复杂，不是两个表或者两个对象直接关联，而是要通过一个“第三者”\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-76ff459f2380e8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n#person类中\n    @Id(autoincrement = true)\n    private Long id;\n    private String name;\n   // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性\n    @ToMany\n    @JoinEntity(\n            entity = JoinStudentToPerson.class,\n            sourceProperty = \"pid\",\n            targetProperty = \"sid\"\n    )\n    private List<Student> students;\n```\n```\n//中间表   “第三者”\n@Entity\npublic class JoinStudentToPerson {\n   @Id(autoincrement = true)\n    private Long id;\n    //和person关联的id\n    private Long pid;\n    //和student关联的id\n    private Long sid;\n}\n```\n```\n@Entity\npublic class Student {\n    @Id\n    private Long id;\n    private String name;\n    // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性\n    @ToMany\n    @JoinEntity(\n            entity = JoinStudentToPerson.class,\n            sourceProperty = \"sid\",\n            targetProperty = \"pid\"\n    )\n    private List<Person> persons;\n}\n```\n然后测试代码\n```\n  private void test() {\n\n        PersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();\n        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();\n        StudentDao studentDao = GreendaoHelper.getDaoSession().getStudentDao();\n        JoinStudentToPersonDao spDao = GreendaoHelper.getDaoSession().getJoinStudentToPersonDao();\n\n//        Head head = new Head();\n//        head.setId(14l);\n//        head.setName(\"head\");\n\n        Person p1 = new Person();\n        p1.setId(1l);\n        p1.setName(\"jafir1\");\n        Person p2 = new Person();\n        p2.setId(2l);\n        p2.setName(\"jafir2\");\n        Person p3 = new Person();\n        p3.setId(3l);\n        p3.setName(\"jafir3\");\n\n\n        Student stu1 = new Student();\n        stu1.setId(1l);\n        stu1.setName(\"stu1\");\n        Student stu2 = new Student();\n        stu2.setId(2l);\n        stu2.setName(\"stu2\");\n        Student stu3 = new Student();\n        stu3.setId(3l);\n        stu3.setName(\"stu3\");\n\n\n        // 模拟 多对多关系\n        // 假如 p1有3个：stu1\\stu2\\stu3\n        //  stu1 stu2 stu3 都有2个 :p1\\p2\n\n        //p1有stu1 stu2 stu3     那么反过来stu123都有p1\n        JoinStudentToPerson sp1 = new JoinStudentToPerson();\n        sp1.setPid(1l);\n        sp1.setSid(1l);\n        JoinStudentToPerson sp2 = new JoinStudentToPerson();\n        sp2.setPid(1l);\n        sp2.setSid(2l);\n        JoinStudentToPerson sp3 = new JoinStudentToPerson();\n        sp3.setPid(1l);\n        sp3.setSid(3l);\n\n        //p2有stu1 stu2 stu3     那么反过来stu123都有p2\n        JoinStudentToPerson sp4 = new JoinStudentToPerson();\n        sp4.setPid(2l);\n        sp4.setSid(1l);\n        JoinStudentToPerson sp5 = new JoinStudentToPerson();\n        sp5.setPid(2l);\n        sp5.setSid(2l);\n        JoinStudentToPerson sp6 = new JoinStudentToPerson();\n        sp6.setPid(2l);\n        sp6.setSid(3l);\n\n        spDao.insert(sp1);\n        spDao.insert(sp2);\n        spDao.insert(sp3);\n        spDao.insert(sp4);\n        spDao.insert(sp5);\n        spDao.insert(sp6);\n\n        personDao.insert(p1);\n        personDao.insert(p2);\n        personDao.insert(p3);\n\n        studentDao.insert(stu1);\n        studentDao.insert(stu2);\n        studentDao.insert(stu3);\n\n//        headDao.insert(head);\n//        personDao.insert(p1);\n\n        List<Person> persons = personDao.queryBuilder().build().list();\n\n        for (Person person : persons) {\n            Log.d(\"debug\",\"person:\"+person.toString());\n        }\n    }\n```\n注意：在person和student的toString里面不能都写getStudents getPerson，不然会你调我，我调你，然后死循环，出现log打印Stack Overflow。只能单独打印测试结果\n```\n//打印person的测试结果\nPerson{\nstudents=[\nStudent{name='stu1', id=1}, \nStudent{name='stu2', id=2},\n Student{name='stu3', id=3}], \nhead=null, hid=null, name='jafir1', id=1}\n\nPerson{\nstudents=[\nStudent{name='stu1', id=1}, \nStudent{name='stu2', id=2}, \nStudent{name='stu3', id=3}],\n head=null, hid=null, name='jafir2', id=2}\n\nPerson{\nstudents=[], \nhead=null, hid=null, name='jafir3', id=3}\n```\nstudents的测试结果就不列出了。\n总之实现起来就是这样。\n\n#### 后记\n在探索3.0版本的时候，确实碰了不少壁，踩了很多坑，遇到了很多疑惑，但是通过自己不断地摸索探究测试，最终还是找到了解决的方法。希望对大家有用，于是分享出来，欢迎大家指正。\n\n这个还要再说一下自己的看法：\n对于greendao或者realm,个人觉得，realm确实更高级一点，是直接**对象关联**的，用起来也更方便一点，而且有很好的中文文档。greendao呢，其实还算是比较原始的数据库框架，但是它最大的优点就是**效率高**。\n\n所以，如果你的数据量大要求效率，你应该使用greendao,不然简小的数据库还是建议使用realm。\n\n","source":"_posts/android-greendao3.0 多表关联踩坑实践.md","raw":"layout: android\ntitle: android greendao3.0 多表关联踩坑实践\ndate: 2018-01-21 12:30:32\ntags: android \n---\n#### 前言\n之前用过数据库框架：realm、kjdb，今天准备实践学习一下greendao 3.0。\ngreendao 3.0之前的版本有很大的不同，主要是增加了annotation注解，然后表之间和对象之间的关系也通过注解而变得更加灵活方便了。以前用过旧版本的都知道，对于多表多对象之间的关联，要写的代码不少。\n\n我在学习greendao 3.0的时候，有一个感触，网上的文章很多，但是千篇一律，大多都是翻译官方文档而来，举得例子可谓是“无一例外”。网上搜罗了半天，收藏几篇比较好的帖子。\n[史上最高效的ORM方案——GreenDao3.0详解](http://www.open-open.com/lib/view/open1480319783903.html)\n[[Android ORM——初识greenDAO 3及使用greenDAO 3前应该掌握的一些知识点（一）](http://blog.csdn.net/crazymo_/article/details/54629916)](http://blog.csdn.net/crazymo_/article/details/54629916)\n\n特别是关于3.0对象多表多对象关联的博客更是没有，所以打算自己实践学习然后总结分享一番。\n\n#### 踩坑\n主要踩了两个坑：\n- greendao的关联关系是通过**主外键（对象之间关联的id）**来构建的。realm是直接通过对象关系来自动构建的。\n- 如果属性是List<> xx,  greendao不会自动调用设置xx的值，只有**手动调用getXX的时候获取**.我在打印log的时候被坑惨了，无论怎么样都是为null.\n\n#### 发现\n- 首先bean类，会自动生成一些方法，比如get set 构造方法 getSession等\n- 如果是list或者数组类型的属性XX，只有getXX方法，没有setXX方法\n- 如果你要打印bean类的toString方法，这里**要调用getXXX方法，而不是直接打印对象**（因为没有赋值,而是在getXX的时候才赋值的）\n```\n    @Override\n    public String toString() {\n        return \"Person{\" +\n               \"students=\" + getStudents() +  //这里不是直接students\n                \", id=\" + id +\n                \", cardId=\" + cardId +\n                \", age=\" + age +\n                \", name='\" + name + '\\'' +\n                \", average=\" + average +\n                \", cid=\" + cid +\n                \", cls=\" + cls +\n                \", fid=\" + fid +\n                \", friends=\" + getFriends() +\n                '}';\n    }\n```\n- greendao支持 自身对自身的关系关联，比如\n\n![](http://upload-images.jianshu.io/upload_images/1311457-73bf8704cedd9252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n---\n\n## 正文： 多表映射关联\n\n#### 一对一：比如一个人有一个头\n如果是按照以往的对象关系数据库\n```\n#person类中\n\n   @Id(autoincrement = true)\n    private Long id;\n    private String name;\n\n//    private Long hid;\n    @ToOne\n    private Head head;\n```\n```\n  Head head = new Head();\n        head.setId(13l);\n        head.setName(\"head\");\n\n        Person p = new Person();\n        p.setId(null);\n        p.setHead(head);//直接设置对象\n        p.setName(\"jafir\");\n```\n直接写对象，然后setHead(head) 就搞定了。但是在greendao中一切对象关联关系都是通过主外键来实现的。应该改为如下：\n```\n#person类中\n  @Id(autoincrement = true)\n    private Long id;\n    private String name;\n\n    private Long hid;//这是与头关联的外键\n    @ToOne(joinProperty = \"hid\") //这个是注解绑定 hid就是上面一行的hid\n    private Head head;//对象，但是不需要setHead\n```\n\nbuild之后，就有setHid的方法了，我们的对象关联不采用setHead,而是setHid\n```\nPersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();\n        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();\n\n        Head head = new Head();\n        head.setId(13l);//这里的head id和person里的hid一样\n        head.setName(\"head\");\n\n        Person p = new Person();\n        p.setId(null);\n        p.setHid(13l);//这里的hid是head的id,就是这样通过id构建起关联的\n        p.setName(\"jafir\");\n\n        headDao.insert(head);\n        personDao.insert(p);\n\n        List<Person> persons = personDao.queryBuilder().build().list();\n        for (Person person : persons) {\n            Log.d(\"debug\",\"person:\"+person.toString());\n        }\n```\n注意：person的toString()方法系统生成的需要修改一下：\n```\n @Override\n    public String toString() {\n        return \"Person{\" +\n                \"head=\" + getHead() +//这里需要改为getHead\n                \", name='\" + name + '\\'' +\n                \", id=\" + id +\n                '}';\n    }\n```\n###### tips:\n- bean的id最好用Long类型而不是long\n```\n @Id(autoincrement = true)\nprivate Long id;\nPerson p = new Person();\n        p.setId(null);\n        p.setHid(14l);\n        p.setName(\"jafir\");\n```\n因为，如果**Long**,我们设置了id是自增长,我们可以```setId(null)```,便是自增长。如果是**long**类型，你设置```setId(null)```，就报空指针。\n\n#### 一对多：比如一个老师有多个学生\n```\n#teacher类中\n @ToMany(referencedJoinProperty = \"tid\")//指定与之关联的其他类的id\n private List<Student> studnets;\n```\n```\n#student类中\n  @Id\n  private Long id;\n  private Long tid;//这个就是外键 就是person的id\n```\n关系描述：\n多个学生都有同一个老师，所以每个学生的tid，就应该是同样的，并且tid 就是老师的id ,这样就构成了1对多的关系\n\n![](http://upload-images.jianshu.io/upload_images/1311457-ce1187ae365babec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n\n注意：学生的自增长id ,跟与老师关联的tid是不一样的，两码事\n\n#### 一对多：比如一个人有一群朋友（朋友也是person）\n按照我们上面的思路，那么person类里面就应该有一个外键指向自身的主键id\n```\n#person类中\n private Long id;//自身id\n private Long fid;//外键关联id\n @ToMany(referencedJoinProperty =\"fid\" )//指定与之关联的其他类的id\n private List<Person> friends;\n```\n\n![](http://upload-images.jianshu.io/upload_images/1311457-3c4924653fee9baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)\n如果一个人的id是1，他有3个朋友，那么friends里面person的fid都是1，这样这个人调用getFriends就能拿到自己的3个朋友。主要就是通过设置id来构建关联关系的。\n\n\n#### 多对多：\n多对多的话就比较复杂，不是两个表或者两个对象直接关联，而是要通过一个“第三者”\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-76ff459f2380e8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n#person类中\n    @Id(autoincrement = true)\n    private Long id;\n    private String name;\n   // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性\n    @ToMany\n    @JoinEntity(\n            entity = JoinStudentToPerson.class,\n            sourceProperty = \"pid\",\n            targetProperty = \"sid\"\n    )\n    private List<Student> students;\n```\n```\n//中间表   “第三者”\n@Entity\npublic class JoinStudentToPerson {\n   @Id(autoincrement = true)\n    private Long id;\n    //和person关联的id\n    private Long pid;\n    //和student关联的id\n    private Long sid;\n}\n```\n```\n@Entity\npublic class Student {\n    @Id\n    private Long id;\n    private String name;\n    // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性\n    @ToMany\n    @JoinEntity(\n            entity = JoinStudentToPerson.class,\n            sourceProperty = \"sid\",\n            targetProperty = \"pid\"\n    )\n    private List<Person> persons;\n}\n```\n然后测试代码\n```\n  private void test() {\n\n        PersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();\n        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();\n        StudentDao studentDao = GreendaoHelper.getDaoSession().getStudentDao();\n        JoinStudentToPersonDao spDao = GreendaoHelper.getDaoSession().getJoinStudentToPersonDao();\n\n//        Head head = new Head();\n//        head.setId(14l);\n//        head.setName(\"head\");\n\n        Person p1 = new Person();\n        p1.setId(1l);\n        p1.setName(\"jafir1\");\n        Person p2 = new Person();\n        p2.setId(2l);\n        p2.setName(\"jafir2\");\n        Person p3 = new Person();\n        p3.setId(3l);\n        p3.setName(\"jafir3\");\n\n\n        Student stu1 = new Student();\n        stu1.setId(1l);\n        stu1.setName(\"stu1\");\n        Student stu2 = new Student();\n        stu2.setId(2l);\n        stu2.setName(\"stu2\");\n        Student stu3 = new Student();\n        stu3.setId(3l);\n        stu3.setName(\"stu3\");\n\n\n        // 模拟 多对多关系\n        // 假如 p1有3个：stu1\\stu2\\stu3\n        //  stu1 stu2 stu3 都有2个 :p1\\p2\n\n        //p1有stu1 stu2 stu3     那么反过来stu123都有p1\n        JoinStudentToPerson sp1 = new JoinStudentToPerson();\n        sp1.setPid(1l);\n        sp1.setSid(1l);\n        JoinStudentToPerson sp2 = new JoinStudentToPerson();\n        sp2.setPid(1l);\n        sp2.setSid(2l);\n        JoinStudentToPerson sp3 = new JoinStudentToPerson();\n        sp3.setPid(1l);\n        sp3.setSid(3l);\n\n        //p2有stu1 stu2 stu3     那么反过来stu123都有p2\n        JoinStudentToPerson sp4 = new JoinStudentToPerson();\n        sp4.setPid(2l);\n        sp4.setSid(1l);\n        JoinStudentToPerson sp5 = new JoinStudentToPerson();\n        sp5.setPid(2l);\n        sp5.setSid(2l);\n        JoinStudentToPerson sp6 = new JoinStudentToPerson();\n        sp6.setPid(2l);\n        sp6.setSid(3l);\n\n        spDao.insert(sp1);\n        spDao.insert(sp2);\n        spDao.insert(sp3);\n        spDao.insert(sp4);\n        spDao.insert(sp5);\n        spDao.insert(sp6);\n\n        personDao.insert(p1);\n        personDao.insert(p2);\n        personDao.insert(p3);\n\n        studentDao.insert(stu1);\n        studentDao.insert(stu2);\n        studentDao.insert(stu3);\n\n//        headDao.insert(head);\n//        personDao.insert(p1);\n\n        List<Person> persons = personDao.queryBuilder().build().list();\n\n        for (Person person : persons) {\n            Log.d(\"debug\",\"person:\"+person.toString());\n        }\n    }\n```\n注意：在person和student的toString里面不能都写getStudents getPerson，不然会你调我，我调你，然后死循环，出现log打印Stack Overflow。只能单独打印测试结果\n```\n//打印person的测试结果\nPerson{\nstudents=[\nStudent{name='stu1', id=1}, \nStudent{name='stu2', id=2},\n Student{name='stu3', id=3}], \nhead=null, hid=null, name='jafir1', id=1}\n\nPerson{\nstudents=[\nStudent{name='stu1', id=1}, \nStudent{name='stu2', id=2}, \nStudent{name='stu3', id=3}],\n head=null, hid=null, name='jafir2', id=2}\n\nPerson{\nstudents=[], \nhead=null, hid=null, name='jafir3', id=3}\n```\nstudents的测试结果就不列出了。\n总之实现起来就是这样。\n\n#### 后记\n在探索3.0版本的时候，确实碰了不少壁，踩了很多坑，遇到了很多疑惑，但是通过自己不断地摸索探究测试，最终还是找到了解决的方法。希望对大家有用，于是分享出来，欢迎大家指正。\n\n这个还要再说一下自己的看法：\n对于greendao或者realm,个人觉得，realm确实更高级一点，是直接**对象关联**的，用起来也更方便一点，而且有很好的中文文档。greendao呢，其实还算是比较原始的数据库框架，但是它最大的优点就是**效率高**。\n\n所以，如果你的数据量大要求效率，你应该使用greendao,不然简小的数据库还是建议使用realm。\n\n","slug":"android-greendao3.0 多表关联踩坑实践","published":1,"updated":"2018-01-21T05:05:08.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjva000e0cusfluy8gp2","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>之前用过数据库框架：realm、kjdb，今天准备实践学习一下greendao 3.0。<br>greendao 3.0之前的版本有很大的不同，主要是增加了annotation注解，然后表之间和对象之间的关系也通过注解而变得更加灵活方便了。以前用过旧版本的都知道，对于多表多对象之间的关联，要写的代码不少。</p>\n<p>我在学习greendao 3.0的时候，有一个感触，网上的文章很多，但是千篇一律，大多都是翻译官方文档而来，举得例子可谓是“无一例外”。网上搜罗了半天，收藏几篇比较好的帖子。<br><a href=\"http://www.open-open.com/lib/view/open1480319783903.html\" target=\"_blank\" rel=\"noopener\">史上最高效的ORM方案——GreenDao3.0详解</a><br><a href=\"http://blog.csdn.net/crazymo_/article/details/54629916\" target=\"_blank\" rel=\"noopener\"><a href=\"http://blog.csdn.net/crazymo_/article/details/54629916\" target=\"_blank\" rel=\"noopener\">Android ORM——初识greenDAO 3及使用greenDAO 3前应该掌握的一些知识点（一）</a></a></p>\n<p>特别是关于3.0对象多表多对象关联的博客更是没有，所以打算自己实践学习然后总结分享一番。</p>\n<h4 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h4><p>主要踩了两个坑：</p>\n<ul>\n<li>greendao的关联关系是通过<strong>主外键（对象之间关联的id）</strong>来构建的。realm是直接通过对象关系来自动构建的。</li>\n<li>如果属性是List&lt;&gt; xx,  greendao不会自动调用设置xx的值，只有<strong>手动调用getXX的时候获取</strong>.我在打印log的时候被坑惨了，无论怎么样都是为null.</li>\n</ul>\n<h4 id=\"发现\"><a href=\"#发现\" class=\"headerlink\" title=\"发现\"></a>发现</h4><ul>\n<li>首先bean类，会自动生成一些方法，比如get set 构造方法 getSession等</li>\n<li>如果是list或者数组类型的属性XX，只有getXX方法，没有setXX方法</li>\n<li><p>如果你要打印bean类的toString方法，这里<strong>要调用getXXX方法，而不是直接打印对象</strong>（因为没有赋值,而是在getXX的时候才赋值的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public String toString() &#123;</span><br><span class=\"line\">    return &quot;Person&#123;&quot; +</span><br><span class=\"line\">           &quot;students=&quot; + getStudents() +  //这里不是直接students</span><br><span class=\"line\">            &quot;, id=&quot; + id +</span><br><span class=\"line\">            &quot;, cardId=&quot; + cardId +</span><br><span class=\"line\">            &quot;, age=&quot; + age +</span><br><span class=\"line\">            &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">            &quot;, average=&quot; + average +</span><br><span class=\"line\">            &quot;, cid=&quot; + cid +</span><br><span class=\"line\">            &quot;, cls=&quot; + cls +</span><br><span class=\"line\">            &quot;, fid=&quot; + fid +</span><br><span class=\"line\">            &quot;, friends=&quot; + getFriends() +</span><br><span class=\"line\">            &apos;&#125;&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>greendao支持 自身对自身的关系关联，比如</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-73bf8704cedd9252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"></p>\n<hr>\n<h2 id=\"正文：-多表映射关联\"><a href=\"#正文：-多表映射关联\" class=\"headerlink\" title=\"正文： 多表映射关联\"></a>正文： 多表映射关联</h2><h4 id=\"一对一：比如一个人有一个头\"><a href=\"#一对一：比如一个人有一个头\" class=\"headerlink\" title=\"一对一：比如一个人有一个头\"></a>一对一：比如一个人有一个头</h4><p>如果是按照以往的对象关系数据库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\"></span><br><span class=\"line\">   @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">//    private Long hid;</span><br><span class=\"line\">    @ToOne</span><br><span class=\"line\">    private Head head;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Head head = new Head();</span><br><span class=\"line\">      head.setId(13l);</span><br><span class=\"line\">      head.setName(&quot;head&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">      Person p = new Person();</span><br><span class=\"line\">      p.setId(null);</span><br><span class=\"line\">      p.setHead(head);//直接设置对象</span><br><span class=\"line\">      p.setName(&quot;jafir&quot;);</span><br></pre></td></tr></table></figure>\n<p>直接写对象，然后setHead(head) 就搞定了。但是在greendao中一切对象关联关系都是通过主外键来实现的。应该改为如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\">  @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Long hid;//这是与头关联的外键</span><br><span class=\"line\">    @ToOne(joinProperty = &quot;hid&quot;) //这个是注解绑定 hid就是上面一行的hid</span><br><span class=\"line\">    private Head head;//对象，但是不需要setHead</span><br></pre></td></tr></table></figure></p>\n<p>build之后，就有setHid的方法了，我们的对象关联不采用setHead,而是setHid<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();</span><br><span class=\"line\">        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();</span><br><span class=\"line\"></span><br><span class=\"line\">        Head head = new Head();</span><br><span class=\"line\">        head.setId(13l);//这里的head id和person里的hid一样</span><br><span class=\"line\">        head.setName(&quot;head&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Person p = new Person();</span><br><span class=\"line\">        p.setId(null);</span><br><span class=\"line\">        p.setHid(13l);//这里的hid是head的id,就是这样通过id构建起关联的</span><br><span class=\"line\">        p.setName(&quot;jafir&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        headDao.insert(head);</span><br><span class=\"line\">        personDao.insert(p);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Person&gt; persons = personDao.queryBuilder().build().list();</span><br><span class=\"line\">        for (Person person : persons) &#123;</span><br><span class=\"line\">            Log.d(&quot;debug&quot;,&quot;person:&quot;+person.toString());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：person的toString()方法系统生成的需要修改一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public String toString() &#123;</span><br><span class=\"line\">       return &quot;Person&#123;&quot; +</span><br><span class=\"line\">               &quot;head=&quot; + getHead() +//这里需要改为getHead</span><br><span class=\"line\">               &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">               &quot;, id=&quot; + id +</span><br><span class=\"line\">               &apos;&#125;&apos;;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips:\"></a>tips:</h6><ul>\n<li>bean的id最好用Long类型而不是long<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @Id(autoincrement = true)</span><br><span class=\"line\">private Long id;</span><br><span class=\"line\">Person p = new Person();</span><br><span class=\"line\">        p.setId(null);</span><br><span class=\"line\">        p.setHid(14l);</span><br><span class=\"line\">        p.setName(&quot;jafir&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>因为，如果<strong>Long</strong>,我们设置了id是自增长,我们可以<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 一对多：比如一个老师有多个学生</span><br></pre></td></tr></table></figure></p>\n<p>#teacher类中<br> @ToMany(referencedJoinProperty = “tid”)//指定与之关联的其他类的id<br> private List<student> studnets;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">#student类中</span><br><span class=\"line\">  @Id</span><br><span class=\"line\">  private Long id;</span><br><span class=\"line\">  private Long tid;//这个就是外键 就是person的id</span><br></pre></td></tr></table></figure></student></p>\n<p>关系描述：<br>多个学生都有同一个老师，所以每个学生的tid，就应该是同样的，并且tid 就是老师的id ,这样就构成了1对多的关系</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ce1187ae365babec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"></p>\n<p>注意：学生的自增长id ,跟与老师关联的tid是不一样的，两码事</p>\n<h4 id=\"一对多：比如一个人有一群朋友（朋友也是person）\"><a href=\"#一对多：比如一个人有一群朋友（朋友也是person）\" class=\"headerlink\" title=\"一对多：比如一个人有一群朋友（朋友也是person）\"></a>一对多：比如一个人有一群朋友（朋友也是person）</h4><p>按照我们上面的思路，那么person类里面就应该有一个外键指向自身的主键id<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\"> private Long id;//自身id</span><br><span class=\"line\"> private Long fid;//外键关联id</span><br><span class=\"line\"> @ToMany(referencedJoinProperty =&quot;fid&quot; )//指定与之关联的其他类的id</span><br><span class=\"line\"> private List&lt;Person&gt; friends;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-3c4924653fee9baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"><br>如果一个人的id是1，他有3个朋友，那么friends里面person的fid都是1，这样这个人调用getFriends就能拿到自己的3个朋友。主要就是通过设置id来构建关联关系的。</p>\n<h4 id=\"多对多：\"><a href=\"#多对多：\" class=\"headerlink\" title=\"多对多：\"></a>多对多：</h4><p>多对多的话就比较复杂，不是两个表或者两个对象直接关联，而是要通过一个“第三者”</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-76ff459f2380e8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\">    @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">   // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性</span><br><span class=\"line\">    @ToMany</span><br><span class=\"line\">    @JoinEntity(</span><br><span class=\"line\">            entity = JoinStudentToPerson.class,</span><br><span class=\"line\">            sourceProperty = &quot;pid&quot;,</span><br><span class=\"line\">            targetProperty = &quot;sid&quot;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    private List&lt;Student&gt; students;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//中间表   “第三者”</span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class JoinStudentToPerson &#123;</span><br><span class=\"line\">   @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    //和person关联的id</span><br><span class=\"line\">    private Long pid;</span><br><span class=\"line\">    //和student关联的id</span><br><span class=\"line\">    private Long sid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Entity</span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性</span><br><span class=\"line\">    @ToMany</span><br><span class=\"line\">    @JoinEntity(</span><br><span class=\"line\">            entity = JoinStudentToPerson.class,</span><br><span class=\"line\">            sourceProperty = &quot;sid&quot;,</span><br><span class=\"line\">            targetProperty = &quot;pid&quot;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    private List&lt;Person&gt; persons;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后测试代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  private void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        PersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();</span><br><span class=\"line\">        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();</span><br><span class=\"line\">        StudentDao studentDao = GreendaoHelper.getDaoSession().getStudentDao();</span><br><span class=\"line\">        JoinStudentToPersonDao spDao = GreendaoHelper.getDaoSession().getJoinStudentToPersonDao();</span><br><span class=\"line\"></span><br><span class=\"line\">//        Head head = new Head();</span><br><span class=\"line\">//        head.setId(14l);</span><br><span class=\"line\">//        head.setName(&quot;head&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Person p1 = new Person();</span><br><span class=\"line\">        p1.setId(1l);</span><br><span class=\"line\">        p1.setName(&quot;jafir1&quot;);</span><br><span class=\"line\">        Person p2 = new Person();</span><br><span class=\"line\">        p2.setId(2l);</span><br><span class=\"line\">        p2.setName(&quot;jafir2&quot;);</span><br><span class=\"line\">        Person p3 = new Person();</span><br><span class=\"line\">        p3.setId(3l);</span><br><span class=\"line\">        p3.setName(&quot;jafir3&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Student stu1 = new Student();</span><br><span class=\"line\">        stu1.setId(1l);</span><br><span class=\"line\">        stu1.setName(&quot;stu1&quot;);</span><br><span class=\"line\">        Student stu2 = new Student();</span><br><span class=\"line\">        stu2.setId(2l);</span><br><span class=\"line\">        stu2.setName(&quot;stu2&quot;);</span><br><span class=\"line\">        Student stu3 = new Student();</span><br><span class=\"line\">        stu3.setId(3l);</span><br><span class=\"line\">        stu3.setName(&quot;stu3&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // 模拟 多对多关系</span><br><span class=\"line\">        // 假如 p1有3个：stu1\\stu2\\stu3</span><br><span class=\"line\">        //  stu1 stu2 stu3 都有2个 :p1\\p2</span><br><span class=\"line\"></span><br><span class=\"line\">        //p1有stu1 stu2 stu3     那么反过来stu123都有p1</span><br><span class=\"line\">        JoinStudentToPerson sp1 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp1.setPid(1l);</span><br><span class=\"line\">        sp1.setSid(1l);</span><br><span class=\"line\">        JoinStudentToPerson sp2 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp2.setPid(1l);</span><br><span class=\"line\">        sp2.setSid(2l);</span><br><span class=\"line\">        JoinStudentToPerson sp3 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp3.setPid(1l);</span><br><span class=\"line\">        sp3.setSid(3l);</span><br><span class=\"line\"></span><br><span class=\"line\">        //p2有stu1 stu2 stu3     那么反过来stu123都有p2</span><br><span class=\"line\">        JoinStudentToPerson sp4 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp4.setPid(2l);</span><br><span class=\"line\">        sp4.setSid(1l);</span><br><span class=\"line\">        JoinStudentToPerson sp5 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp5.setPid(2l);</span><br><span class=\"line\">        sp5.setSid(2l);</span><br><span class=\"line\">        JoinStudentToPerson sp6 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp6.setPid(2l);</span><br><span class=\"line\">        sp6.setSid(3l);</span><br><span class=\"line\"></span><br><span class=\"line\">        spDao.insert(sp1);</span><br><span class=\"line\">        spDao.insert(sp2);</span><br><span class=\"line\">        spDao.insert(sp3);</span><br><span class=\"line\">        spDao.insert(sp4);</span><br><span class=\"line\">        spDao.insert(sp5);</span><br><span class=\"line\">        spDao.insert(sp6);</span><br><span class=\"line\"></span><br><span class=\"line\">        personDao.insert(p1);</span><br><span class=\"line\">        personDao.insert(p2);</span><br><span class=\"line\">        personDao.insert(p3);</span><br><span class=\"line\"></span><br><span class=\"line\">        studentDao.insert(stu1);</span><br><span class=\"line\">        studentDao.insert(stu2);</span><br><span class=\"line\">        studentDao.insert(stu3);</span><br><span class=\"line\"></span><br><span class=\"line\">//        headDao.insert(head);</span><br><span class=\"line\">//        personDao.insert(p1);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Person&gt; persons = personDao.queryBuilder().build().list();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Person person : persons) &#123;</span><br><span class=\"line\">            Log.d(&quot;debug&quot;,&quot;person:&quot;+person.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：在person和student的toString里面不能都写getStudents getPerson，不然会你调我，我调你，然后死循环，出现log打印Stack Overflow。只能单独打印测试结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打印person的测试结果</span><br><span class=\"line\">Person&#123;</span><br><span class=\"line\">students=[</span><br><span class=\"line\">Student&#123;name=&apos;stu1&apos;, id=1&#125;, </span><br><span class=\"line\">Student&#123;name=&apos;stu2&apos;, id=2&#125;,</span><br><span class=\"line\"> Student&#123;name=&apos;stu3&apos;, id=3&#125;], </span><br><span class=\"line\">head=null, hid=null, name=&apos;jafir1&apos;, id=1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&#123;</span><br><span class=\"line\">students=[</span><br><span class=\"line\">Student&#123;name=&apos;stu1&apos;, id=1&#125;, </span><br><span class=\"line\">Student&#123;name=&apos;stu2&apos;, id=2&#125;, </span><br><span class=\"line\">Student&#123;name=&apos;stu3&apos;, id=3&#125;],</span><br><span class=\"line\"> head=null, hid=null, name=&apos;jafir2&apos;, id=2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&#123;</span><br><span class=\"line\">students=[], </span><br><span class=\"line\">head=null, hid=null, name=&apos;jafir3&apos;, id=3&#125;</span><br></pre></td></tr></table></figure></p>\n<p>students的测试结果就不列出了。<br>总之实现起来就是这样。</p>\n<h4 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h4><p>在探索3.0版本的时候，确实碰了不少壁，踩了很多坑，遇到了很多疑惑，但是通过自己不断地摸索探究测试，最终还是找到了解决的方法。希望对大家有用，于是分享出来，欢迎大家指正。</p>\n<p>这个还要再说一下自己的看法：<br>对于greendao或者realm,个人觉得，realm确实更高级一点，是直接<strong>对象关联</strong>的，用起来也更方便一点，而且有很好的中文文档。greendao呢，其实还算是比较原始的数据库框架，但是它最大的优点就是<strong>效率高</strong>。</p>\n<p>所以，如果你的数据量大要求效率，你应该使用greendao,不然简小的数据库还是建议使用realm。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>之前用过数据库框架：realm、kjdb，今天准备实践学习一下greendao 3.0。<br>greendao 3.0之前的版本有很大的不同，主要是增加了annotation注解，然后表之间和对象之间的关系也通过注解而变得更加灵活方便了。以前用过旧版本的都知道，对于多表多对象之间的关联，要写的代码不少。</p>\n<p>我在学习greendao 3.0的时候，有一个感触，网上的文章很多，但是千篇一律，大多都是翻译官方文档而来，举得例子可谓是“无一例外”。网上搜罗了半天，收藏几篇比较好的帖子。<br><a href=\"http://www.open-open.com/lib/view/open1480319783903.html\" target=\"_blank\" rel=\"noopener\">史上最高效的ORM方案——GreenDao3.0详解</a><br><a href=\"http://blog.csdn.net/crazymo_/article/details/54629916\" target=\"_blank\" rel=\"noopener\"><a href=\"http://blog.csdn.net/crazymo_/article/details/54629916\" target=\"_blank\" rel=\"noopener\">Android ORM——初识greenDAO 3及使用greenDAO 3前应该掌握的一些知识点（一）</a></a></p>\n<p>特别是关于3.0对象多表多对象关联的博客更是没有，所以打算自己实践学习然后总结分享一番。</p>\n<h4 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h4><p>主要踩了两个坑：</p>\n<ul>\n<li>greendao的关联关系是通过<strong>主外键（对象之间关联的id）</strong>来构建的。realm是直接通过对象关系来自动构建的。</li>\n<li>如果属性是List&lt;&gt; xx,  greendao不会自动调用设置xx的值，只有<strong>手动调用getXX的时候获取</strong>.我在打印log的时候被坑惨了，无论怎么样都是为null.</li>\n</ul>\n<h4 id=\"发现\"><a href=\"#发现\" class=\"headerlink\" title=\"发现\"></a>发现</h4><ul>\n<li>首先bean类，会自动生成一些方法，比如get set 构造方法 getSession等</li>\n<li>如果是list或者数组类型的属性XX，只有getXX方法，没有setXX方法</li>\n<li><p>如果你要打印bean类的toString方法，这里<strong>要调用getXXX方法，而不是直接打印对象</strong>（因为没有赋值,而是在getXX的时候才赋值的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public String toString() &#123;</span><br><span class=\"line\">    return &quot;Person&#123;&quot; +</span><br><span class=\"line\">           &quot;students=&quot; + getStudents() +  //这里不是直接students</span><br><span class=\"line\">            &quot;, id=&quot; + id +</span><br><span class=\"line\">            &quot;, cardId=&quot; + cardId +</span><br><span class=\"line\">            &quot;, age=&quot; + age +</span><br><span class=\"line\">            &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">            &quot;, average=&quot; + average +</span><br><span class=\"line\">            &quot;, cid=&quot; + cid +</span><br><span class=\"line\">            &quot;, cls=&quot; + cls +</span><br><span class=\"line\">            &quot;, fid=&quot; + fid +</span><br><span class=\"line\">            &quot;, friends=&quot; + getFriends() +</span><br><span class=\"line\">            &apos;&#125;&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>greendao支持 自身对自身的关系关联，比如</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-73bf8704cedd9252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"></p>\n<hr>\n<h2 id=\"正文：-多表映射关联\"><a href=\"#正文：-多表映射关联\" class=\"headerlink\" title=\"正文： 多表映射关联\"></a>正文： 多表映射关联</h2><h4 id=\"一对一：比如一个人有一个头\"><a href=\"#一对一：比如一个人有一个头\" class=\"headerlink\" title=\"一对一：比如一个人有一个头\"></a>一对一：比如一个人有一个头</h4><p>如果是按照以往的对象关系数据库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\"></span><br><span class=\"line\">   @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">//    private Long hid;</span><br><span class=\"line\">    @ToOne</span><br><span class=\"line\">    private Head head;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Head head = new Head();</span><br><span class=\"line\">      head.setId(13l);</span><br><span class=\"line\">      head.setName(&quot;head&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">      Person p = new Person();</span><br><span class=\"line\">      p.setId(null);</span><br><span class=\"line\">      p.setHead(head);//直接设置对象</span><br><span class=\"line\">      p.setName(&quot;jafir&quot;);</span><br></pre></td></tr></table></figure>\n<p>直接写对象，然后setHead(head) 就搞定了。但是在greendao中一切对象关联关系都是通过主外键来实现的。应该改为如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\">  @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Long hid;//这是与头关联的外键</span><br><span class=\"line\">    @ToOne(joinProperty = &quot;hid&quot;) //这个是注解绑定 hid就是上面一行的hid</span><br><span class=\"line\">    private Head head;//对象，但是不需要setHead</span><br></pre></td></tr></table></figure></p>\n<p>build之后，就有setHid的方法了，我们的对象关联不采用setHead,而是setHid<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();</span><br><span class=\"line\">        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();</span><br><span class=\"line\"></span><br><span class=\"line\">        Head head = new Head();</span><br><span class=\"line\">        head.setId(13l);//这里的head id和person里的hid一样</span><br><span class=\"line\">        head.setName(&quot;head&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Person p = new Person();</span><br><span class=\"line\">        p.setId(null);</span><br><span class=\"line\">        p.setHid(13l);//这里的hid是head的id,就是这样通过id构建起关联的</span><br><span class=\"line\">        p.setName(&quot;jafir&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        headDao.insert(head);</span><br><span class=\"line\">        personDao.insert(p);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Person&gt; persons = personDao.queryBuilder().build().list();</span><br><span class=\"line\">        for (Person person : persons) &#123;</span><br><span class=\"line\">            Log.d(&quot;debug&quot;,&quot;person:&quot;+person.toString());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：person的toString()方法系统生成的需要修改一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   public String toString() &#123;</span><br><span class=\"line\">       return &quot;Person&#123;&quot; +</span><br><span class=\"line\">               &quot;head=&quot; + getHead() +//这里需要改为getHead</span><br><span class=\"line\">               &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +</span><br><span class=\"line\">               &quot;, id=&quot; + id +</span><br><span class=\"line\">               &apos;&#125;&apos;;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips:\"></a>tips:</h6><ul>\n<li>bean的id最好用Long类型而不是long<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> @Id(autoincrement = true)</span><br><span class=\"line\">private Long id;</span><br><span class=\"line\">Person p = new Person();</span><br><span class=\"line\">        p.setId(null);</span><br><span class=\"line\">        p.setHid(14l);</span><br><span class=\"line\">        p.setName(&quot;jafir&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>因为，如果<strong>Long</strong>,我们设置了id是自增长,我们可以<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 一对多：比如一个老师有多个学生</span><br></pre></td></tr></table></figure></p>\n<p>#teacher类中<br> @ToMany(referencedJoinProperty = “tid”)//指定与之关联的其他类的id<br> private List<student> studnets;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">#student类中</span><br><span class=\"line\">  @Id</span><br><span class=\"line\">  private Long id;</span><br><span class=\"line\">  private Long tid;//这个就是外键 就是person的id</span><br></pre></td></tr></table></figure></student></p>\n<p>关系描述：<br>多个学生都有同一个老师，所以每个学生的tid，就应该是同样的，并且tid 就是老师的id ,这样就构成了1对多的关系</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-ce1187ae365babec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"></p>\n<p>注意：学生的自增长id ,跟与老师关联的tid是不一样的，两码事</p>\n<h4 id=\"一对多：比如一个人有一群朋友（朋友也是person）\"><a href=\"#一对多：比如一个人有一群朋友（朋友也是person）\" class=\"headerlink\" title=\"一对多：比如一个人有一群朋友（朋友也是person）\"></a>一对多：比如一个人有一群朋友（朋友也是person）</h4><p>按照我们上面的思路，那么person类里面就应该有一个外键指向自身的主键id<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\"> private Long id;//自身id</span><br><span class=\"line\"> private Long fid;//外键关联id</span><br><span class=\"line\"> @ToMany(referencedJoinProperty =&quot;fid&quot; )//指定与之关联的其他类的id</span><br><span class=\"line\"> private List&lt;Person&gt; friends;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-3c4924653fee9baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"\"><br>如果一个人的id是1，他有3个朋友，那么friends里面person的fid都是1，这样这个人调用getFriends就能拿到自己的3个朋友。主要就是通过设置id来构建关联关系的。</p>\n<h4 id=\"多对多：\"><a href=\"#多对多：\" class=\"headerlink\" title=\"多对多：\"></a>多对多：</h4><p>多对多的话就比较复杂，不是两个表或者两个对象直接关联，而是要通过一个“第三者”</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-76ff459f2380e8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#person类中</span><br><span class=\"line\">    @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">   // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性</span><br><span class=\"line\">    @ToMany</span><br><span class=\"line\">    @JoinEntity(</span><br><span class=\"line\">            entity = JoinStudentToPerson.class,</span><br><span class=\"line\">            sourceProperty = &quot;pid&quot;,</span><br><span class=\"line\">            targetProperty = &quot;sid&quot;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    private List&lt;Student&gt; students;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//中间表   “第三者”</span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class JoinStudentToPerson &#123;</span><br><span class=\"line\">   @Id(autoincrement = true)</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    //和person关联的id</span><br><span class=\"line\">    private Long pid;</span><br><span class=\"line\">    //和student关联的id</span><br><span class=\"line\">    private Long sid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Entity</span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    // 对多，@JoinEntity注解：entity 中间表；sourceProperty 实体属性；targetProperty 外链实体属性</span><br><span class=\"line\">    @ToMany</span><br><span class=\"line\">    @JoinEntity(</span><br><span class=\"line\">            entity = JoinStudentToPerson.class,</span><br><span class=\"line\">            sourceProperty = &quot;sid&quot;,</span><br><span class=\"line\">            targetProperty = &quot;pid&quot;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    private List&lt;Person&gt; persons;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后测试代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  private void test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        PersonDao personDao = GreendaoHelper.getDaoSession().getPersonDao();</span><br><span class=\"line\">        HeadDao headDao = GreendaoHelper.getDaoSession().getHeadDao();</span><br><span class=\"line\">        StudentDao studentDao = GreendaoHelper.getDaoSession().getStudentDao();</span><br><span class=\"line\">        JoinStudentToPersonDao spDao = GreendaoHelper.getDaoSession().getJoinStudentToPersonDao();</span><br><span class=\"line\"></span><br><span class=\"line\">//        Head head = new Head();</span><br><span class=\"line\">//        head.setId(14l);</span><br><span class=\"line\">//        head.setName(&quot;head&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Person p1 = new Person();</span><br><span class=\"line\">        p1.setId(1l);</span><br><span class=\"line\">        p1.setName(&quot;jafir1&quot;);</span><br><span class=\"line\">        Person p2 = new Person();</span><br><span class=\"line\">        p2.setId(2l);</span><br><span class=\"line\">        p2.setName(&quot;jafir2&quot;);</span><br><span class=\"line\">        Person p3 = new Person();</span><br><span class=\"line\">        p3.setId(3l);</span><br><span class=\"line\">        p3.setName(&quot;jafir3&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Student stu1 = new Student();</span><br><span class=\"line\">        stu1.setId(1l);</span><br><span class=\"line\">        stu1.setName(&quot;stu1&quot;);</span><br><span class=\"line\">        Student stu2 = new Student();</span><br><span class=\"line\">        stu2.setId(2l);</span><br><span class=\"line\">        stu2.setName(&quot;stu2&quot;);</span><br><span class=\"line\">        Student stu3 = new Student();</span><br><span class=\"line\">        stu3.setId(3l);</span><br><span class=\"line\">        stu3.setName(&quot;stu3&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        // 模拟 多对多关系</span><br><span class=\"line\">        // 假如 p1有3个：stu1\\stu2\\stu3</span><br><span class=\"line\">        //  stu1 stu2 stu3 都有2个 :p1\\p2</span><br><span class=\"line\"></span><br><span class=\"line\">        //p1有stu1 stu2 stu3     那么反过来stu123都有p1</span><br><span class=\"line\">        JoinStudentToPerson sp1 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp1.setPid(1l);</span><br><span class=\"line\">        sp1.setSid(1l);</span><br><span class=\"line\">        JoinStudentToPerson sp2 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp2.setPid(1l);</span><br><span class=\"line\">        sp2.setSid(2l);</span><br><span class=\"line\">        JoinStudentToPerson sp3 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp3.setPid(1l);</span><br><span class=\"line\">        sp3.setSid(3l);</span><br><span class=\"line\"></span><br><span class=\"line\">        //p2有stu1 stu2 stu3     那么反过来stu123都有p2</span><br><span class=\"line\">        JoinStudentToPerson sp4 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp4.setPid(2l);</span><br><span class=\"line\">        sp4.setSid(1l);</span><br><span class=\"line\">        JoinStudentToPerson sp5 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp5.setPid(2l);</span><br><span class=\"line\">        sp5.setSid(2l);</span><br><span class=\"line\">        JoinStudentToPerson sp6 = new JoinStudentToPerson();</span><br><span class=\"line\">        sp6.setPid(2l);</span><br><span class=\"line\">        sp6.setSid(3l);</span><br><span class=\"line\"></span><br><span class=\"line\">        spDao.insert(sp1);</span><br><span class=\"line\">        spDao.insert(sp2);</span><br><span class=\"line\">        spDao.insert(sp3);</span><br><span class=\"line\">        spDao.insert(sp4);</span><br><span class=\"line\">        spDao.insert(sp5);</span><br><span class=\"line\">        spDao.insert(sp6);</span><br><span class=\"line\"></span><br><span class=\"line\">        personDao.insert(p1);</span><br><span class=\"line\">        personDao.insert(p2);</span><br><span class=\"line\">        personDao.insert(p3);</span><br><span class=\"line\"></span><br><span class=\"line\">        studentDao.insert(stu1);</span><br><span class=\"line\">        studentDao.insert(stu2);</span><br><span class=\"line\">        studentDao.insert(stu3);</span><br><span class=\"line\"></span><br><span class=\"line\">//        headDao.insert(head);</span><br><span class=\"line\">//        personDao.insert(p1);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Person&gt; persons = personDao.queryBuilder().build().list();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Person person : persons) &#123;</span><br><span class=\"line\">            Log.d(&quot;debug&quot;,&quot;person:&quot;+person.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：在person和student的toString里面不能都写getStudents getPerson，不然会你调我，我调你，然后死循环，出现log打印Stack Overflow。只能单独打印测试结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打印person的测试结果</span><br><span class=\"line\">Person&#123;</span><br><span class=\"line\">students=[</span><br><span class=\"line\">Student&#123;name=&apos;stu1&apos;, id=1&#125;, </span><br><span class=\"line\">Student&#123;name=&apos;stu2&apos;, id=2&#125;,</span><br><span class=\"line\"> Student&#123;name=&apos;stu3&apos;, id=3&#125;], </span><br><span class=\"line\">head=null, hid=null, name=&apos;jafir1&apos;, id=1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&#123;</span><br><span class=\"line\">students=[</span><br><span class=\"line\">Student&#123;name=&apos;stu1&apos;, id=1&#125;, </span><br><span class=\"line\">Student&#123;name=&apos;stu2&apos;, id=2&#125;, </span><br><span class=\"line\">Student&#123;name=&apos;stu3&apos;, id=3&#125;],</span><br><span class=\"line\"> head=null, hid=null, name=&apos;jafir2&apos;, id=2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person&#123;</span><br><span class=\"line\">students=[], </span><br><span class=\"line\">head=null, hid=null, name=&apos;jafir3&apos;, id=3&#125;</span><br></pre></td></tr></table></figure></p>\n<p>students的测试结果就不列出了。<br>总之实现起来就是这样。</p>\n<h4 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h4><p>在探索3.0版本的时候，确实碰了不少壁，踩了很多坑，遇到了很多疑惑，但是通过自己不断地摸索探究测试，最终还是找到了解决的方法。希望对大家有用，于是分享出来，欢迎大家指正。</p>\n<p>这个还要再说一下自己的看法：<br>对于greendao或者realm,个人觉得，realm确实更高级一点，是直接<strong>对象关联</strong>的，用起来也更方便一点，而且有很好的中文文档。greendao呢，其实还算是比较原始的数据库框架，但是它最大的优点就是<strong>效率高</strong>。</p>\n<p>所以，如果你的数据量大要求效率，你应该使用greendao,不然简小的数据库还是建议使用realm。</p>\n"},{"title":"hello","date":"2017-01-18T09:22:10.000Z","_content":"### 前言\n很久以前就说弄一个自己的github.io博客，但是一直没有下决心花时间去弄，现在好了，弄了一个，\n期间遇到了很多问题呢，觉得学到了的很多东西，当然也踩了很多坑。不过最终还是选定了一个material的主题。\n\n### 踩坑\n遇到了很多问题，我是mac系统\n- 首先装node.js\n- 安装git\n- npm install hexo (最好加一个sudo因为是要安装到系统local下面)\n- 到你创建的对应的文件夹 cd /xxxx （比如cd /user/jafir/hexo）\n- hexo init\n- hexo generate(简写 hexo g)\n- hexo server (开启服务器测试本地 http://localhost:4000)\n- 如果成功，那么就创建github repository(遇到一个严重坑 xx.github.io  xx必须要跟你的username一致)\n- 如果你之前已经有过上传的经验（比如已经在本地上传过项目到github），那么你就不需要再配置ssh了\n![username 和 repository一致](http://upload-images.jianshu.io/upload_images/1945618-7e4b5b66b4e0c708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 不然，你就要获取ssh（/user/yourname/.ssh），找到id_rsa.pub 文件打开，然后复制内容\n- 到github settings -> SSH and GPG keys,添加一个ssh,title 随便填，内容粘贴 保存 ，ok \n![打开id_rsa.pub,复制内容](http://upload-images.jianshu.io/upload_images/1945618-946df6deb330f92f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![没有就要添加](http://upload-images.jianshu.io/upload_images/1945618-d17ea418f9b3df8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![粘贴](http://upload-images.jianshu.io/upload_images/1945618-70b8c4f108f217f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 配置_config.yml文件（里面有包括什么网页的标题和一些信息）\n- 主要就修改这几个地方\n![SunShineIos替换为你的username](http://upload-images.jianshu.io/upload_images/1945618-c2a79bc6c2aac85b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 这里的deploy地址就是你repository的ssh地址（可以是ssh 也可以是 https）\n![主题可以换有很大，百度搜\"hexo好看主题\"](http://upload-images.jianshu.io/upload_images/1945618-ad136a1c2a51c199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![修改language等，注意:后面都有一个空格](http://upload-images.jianshu.io/upload_images/1945618-9c243ac2ca7859f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 最后就hexo deploy(简写 hexo d, 如果没有反应那么你要执行 npm install hexo-deployer-git --save)\n- 不出意外就成功了，地址是 http://username.github.io\n- 如果你还想弄个域名，可以，直接去阿里云搜（我买了一个jafir.top,感觉.top有点高级，但还是因为头年4块）\n- 买好了域名，在域名->解析里面，添加\n- 1、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.153 ,保存\n- 2、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.154 ,保存（这俩都是github的主机地址）\n- 3、添加 记录类型：www（表示www），主机记录：CNAME ，记录值：username.github.io ,保存\n- 域名弄好了，然后在hexo的项目目录下的 source 里面加入 一个文件（没有后缀），里面写入 jafir.top(你域名，不要www)\n- 然后重新发布（可以 hexo d -g 一起）\n- 如果说你没有本地项目没有.git文件，你可以执行 git.init\n- 注意一点：生效是有一定时间的，如果你在过程中出现了一些问题，导致你加载username.github.io直接跳到你的域名，但是又还没有生效，你过一会它还是那样的，你就需要清理一下你的浏览器缓存\n- 如果不出意外，搞定，开心!\n- 如果还不行这里有两篇比较好的文章，综合一下应该没有问题\n- http://www.jianshu.com/p/fdb5d7978cdb\n- http://www.jianshu.com/p/8ec1b1e5d3b2\n\n### 总结\n还是比较喜欢总结的，因为古有温故而知新，我有总结而知新，总结是优秀的学习方法中很重要的一环，多多总结，经验才会显得牢靠，而不是泛泛而谈，没有达到脚踏实地的效果，\n 自己做的一些有意义的事情，最后总结一下，能够加深自己的理解和印象，让你烙下深深的印记，perfect！\n\n ","source":"_posts/hello.md","raw":"---\ntitle: hello\ndate: 2017-01-18 17:22:10\ntags: \n---\n### 前言\n很久以前就说弄一个自己的github.io博客，但是一直没有下决心花时间去弄，现在好了，弄了一个，\n期间遇到了很多问题呢，觉得学到了的很多东西，当然也踩了很多坑。不过最终还是选定了一个material的主题。\n\n### 踩坑\n遇到了很多问题，我是mac系统\n- 首先装node.js\n- 安装git\n- npm install hexo (最好加一个sudo因为是要安装到系统local下面)\n- 到你创建的对应的文件夹 cd /xxxx （比如cd /user/jafir/hexo）\n- hexo init\n- hexo generate(简写 hexo g)\n- hexo server (开启服务器测试本地 http://localhost:4000)\n- 如果成功，那么就创建github repository(遇到一个严重坑 xx.github.io  xx必须要跟你的username一致)\n- 如果你之前已经有过上传的经验（比如已经在本地上传过项目到github），那么你就不需要再配置ssh了\n![username 和 repository一致](http://upload-images.jianshu.io/upload_images/1945618-7e4b5b66b4e0c708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 不然，你就要获取ssh（/user/yourname/.ssh），找到id_rsa.pub 文件打开，然后复制内容\n- 到github settings -> SSH and GPG keys,添加一个ssh,title 随便填，内容粘贴 保存 ，ok \n![打开id_rsa.pub,复制内容](http://upload-images.jianshu.io/upload_images/1945618-946df6deb330f92f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![没有就要添加](http://upload-images.jianshu.io/upload_images/1945618-d17ea418f9b3df8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![粘贴](http://upload-images.jianshu.io/upload_images/1945618-70b8c4f108f217f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 配置_config.yml文件（里面有包括什么网页的标题和一些信息）\n- 主要就修改这几个地方\n![SunShineIos替换为你的username](http://upload-images.jianshu.io/upload_images/1945618-c2a79bc6c2aac85b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 这里的deploy地址就是你repository的ssh地址（可以是ssh 也可以是 https）\n![主题可以换有很大，百度搜\"hexo好看主题\"](http://upload-images.jianshu.io/upload_images/1945618-ad136a1c2a51c199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![修改language等，注意:后面都有一个空格](http://upload-images.jianshu.io/upload_images/1945618-9c243ac2ca7859f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 最后就hexo deploy(简写 hexo d, 如果没有反应那么你要执行 npm install hexo-deployer-git --save)\n- 不出意外就成功了，地址是 http://username.github.io\n- 如果你还想弄个域名，可以，直接去阿里云搜（我买了一个jafir.top,感觉.top有点高级，但还是因为头年4块）\n- 买好了域名，在域名->解析里面，添加\n- 1、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.153 ,保存\n- 2、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.154 ,保存（这俩都是github的主机地址）\n- 3、添加 记录类型：www（表示www），主机记录：CNAME ，记录值：username.github.io ,保存\n- 域名弄好了，然后在hexo的项目目录下的 source 里面加入 一个文件（没有后缀），里面写入 jafir.top(你域名，不要www)\n- 然后重新发布（可以 hexo d -g 一起）\n- 如果说你没有本地项目没有.git文件，你可以执行 git.init\n- 注意一点：生效是有一定时间的，如果你在过程中出现了一些问题，导致你加载username.github.io直接跳到你的域名，但是又还没有生效，你过一会它还是那样的，你就需要清理一下你的浏览器缓存\n- 如果不出意外，搞定，开心!\n- 如果还不行这里有两篇比较好的文章，综合一下应该没有问题\n- http://www.jianshu.com/p/fdb5d7978cdb\n- http://www.jianshu.com/p/8ec1b1e5d3b2\n\n### 总结\n还是比较喜欢总结的，因为古有温故而知新，我有总结而知新，总结是优秀的学习方法中很重要的一环，多多总结，经验才会显得牢靠，而不是泛泛而谈，没有达到脚踏实地的效果，\n 自己做的一些有意义的事情，最后总结一下，能够加深自己的理解和印象，让你烙下深深的印记，perfect！\n\n ","slug":"hello","published":1,"updated":"2018-01-21T04:44:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcozqjvd000h0cusb64ovev9","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>很久以前就说弄一个自己的github.io博客，但是一直没有下决心花时间去弄，现在好了，弄了一个，<br>期间遇到了很多问题呢，觉得学到了的很多东西，当然也踩了很多坑。不过最终还是选定了一个material的主题。</p>\n<h3 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h3><p>遇到了很多问题，我是mac系统</p>\n<ul>\n<li>首先装node.js</li>\n<li>安装git</li>\n<li>npm install hexo (最好加一个sudo因为是要安装到系统local下面)</li>\n<li>到你创建的对应的文件夹 cd /xxxx （比如cd /user/jafir/hexo）</li>\n<li>hexo init</li>\n<li>hexo generate(简写 hexo g)</li>\n<li>hexo server (开启服务器测试本地 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a>)</li>\n<li>如果成功，那么就创建github repository(遇到一个严重坑 xx.github.io  xx必须要跟你的username一致)</li>\n<li>如果你之前已经有过上传的经验（比如已经在本地上传过项目到github），那么你就不需要再配置ssh了<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-7e4b5b66b4e0c708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"username 和 repository一致\"></li>\n<li>不然，你就要获取ssh（/user/yourname/.ssh），找到id_rsa.pub 文件打开，然后复制内容</li>\n<li>到github settings -&gt; SSH and GPG keys,添加一个ssh,title 随便填，内容粘贴 保存 ，ok<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-946df6deb330f92f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打开id_rsa.pub,复制内容\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-d17ea418f9b3df8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"没有就要添加\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-70b8c4f108f217f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"粘贴\"></li>\n<li>配置_config.yml文件（里面有包括什么网页的标题和一些信息）</li>\n<li>主要就修改这几个地方<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-c2a79bc6c2aac85b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SunShineIos替换为你的username\"></li>\n<li>这里的deploy地址就是你repository的ssh地址（可以是ssh 也可以是 https）<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-ad136a1c2a51c199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"主题可以换有很大，百度搜&quot;hexo好看主题&quot;\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-9c243ac2ca7859f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改language等，注意:后面都有一个空格\"></li>\n<li>最后就hexo deploy(简写 hexo d, 如果没有反应那么你要执行 npm install hexo-deployer-git –save)</li>\n<li>不出意外就成功了，地址是 <a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a></li>\n<li>如果你还想弄个域名，可以，直接去阿里云搜（我买了一个jafir.top,感觉.top有点高级，但还是因为头年4块）</li>\n<li>买好了域名，在域名-&gt;解析里面，添加</li>\n<li>1、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.153 ,保存</li>\n<li>2、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.154 ,保存（这俩都是github的主机地址）</li>\n<li>3、添加 记录类型：www（表示www），主机记录：CNAME ，记录值：username.github.io ,保存</li>\n<li>域名弄好了，然后在hexo的项目目录下的 source 里面加入 一个文件（没有后缀），里面写入 jafir.top(你域名，不要www)</li>\n<li>然后重新发布（可以 hexo d -g 一起）</li>\n<li>如果说你没有本地项目没有.git文件，你可以执行 git.init</li>\n<li>注意一点：生效是有一定时间的，如果你在过程中出现了一些问题，导致你加载username.github.io直接跳到你的域名，但是又还没有生效，你过一会它还是那样的，你就需要清理一下你的浏览器缓存</li>\n<li>如果不出意外，搞定，开心!</li>\n<li>如果还不行这里有两篇比较好的文章，综合一下应该没有问题</li>\n<li><a href=\"http://www.jianshu.com/p/fdb5d7978cdb\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/fdb5d7978cdb</a></li>\n<li><a href=\"http://www.jianshu.com/p/8ec1b1e5d3b2\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8ec1b1e5d3b2</a></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>还是比较喜欢总结的，因为古有温故而知新，我有总结而知新，总结是优秀的学习方法中很重要的一环，多多总结，经验才会显得牢靠，而不是泛泛而谈，没有达到脚踏实地的效果，<br> 自己做的一些有意义的事情，最后总结一下，能够加深自己的理解和印象，让你烙下深深的印记，perfect！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>很久以前就说弄一个自己的github.io博客，但是一直没有下决心花时间去弄，现在好了，弄了一个，<br>期间遇到了很多问题呢，觉得学到了的很多东西，当然也踩了很多坑。不过最终还是选定了一个material的主题。</p>\n<h3 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h3><p>遇到了很多问题，我是mac系统</p>\n<ul>\n<li>首先装node.js</li>\n<li>安装git</li>\n<li>npm install hexo (最好加一个sudo因为是要安装到系统local下面)</li>\n<li>到你创建的对应的文件夹 cd /xxxx （比如cd /user/jafir/hexo）</li>\n<li>hexo init</li>\n<li>hexo generate(简写 hexo g)</li>\n<li>hexo server (开启服务器测试本地 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a>)</li>\n<li>如果成功，那么就创建github repository(遇到一个严重坑 xx.github.io  xx必须要跟你的username一致)</li>\n<li>如果你之前已经有过上传的经验（比如已经在本地上传过项目到github），那么你就不需要再配置ssh了<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-7e4b5b66b4e0c708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"username 和 repository一致\"></li>\n<li>不然，你就要获取ssh（/user/yourname/.ssh），找到id_rsa.pub 文件打开，然后复制内容</li>\n<li>到github settings -&gt; SSH and GPG keys,添加一个ssh,title 随便填，内容粘贴 保存 ，ok<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-946df6deb330f92f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打开id_rsa.pub,复制内容\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-d17ea418f9b3df8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"没有就要添加\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-70b8c4f108f217f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"粘贴\"></li>\n<li>配置_config.yml文件（里面有包括什么网页的标题和一些信息）</li>\n<li>主要就修改这几个地方<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-c2a79bc6c2aac85b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SunShineIos替换为你的username\"></li>\n<li>这里的deploy地址就是你repository的ssh地址（可以是ssh 也可以是 https）<br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-ad136a1c2a51c199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"主题可以换有很大，百度搜&quot;hexo好看主题&quot;\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1945618-9c243ac2ca7859f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改language等，注意:后面都有一个空格\"></li>\n<li>最后就hexo deploy(简写 hexo d, 如果没有反应那么你要执行 npm install hexo-deployer-git –save)</li>\n<li>不出意外就成功了，地址是 <a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">http://username.github.io</a></li>\n<li>如果你还想弄个域名，可以，直接去阿里云搜（我买了一个jafir.top,感觉.top有点高级，但还是因为头年4块）</li>\n<li>买好了域名，在域名-&gt;解析里面，添加</li>\n<li>1、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.153 ,保存</li>\n<li>2、添加 记录类型：A（表示address），主机记录：@ ，记录值：192.30.252.154 ,保存（这俩都是github的主机地址）</li>\n<li>3、添加 记录类型：www（表示www），主机记录：CNAME ，记录值：username.github.io ,保存</li>\n<li>域名弄好了，然后在hexo的项目目录下的 source 里面加入 一个文件（没有后缀），里面写入 jafir.top(你域名，不要www)</li>\n<li>然后重新发布（可以 hexo d -g 一起）</li>\n<li>如果说你没有本地项目没有.git文件，你可以执行 git.init</li>\n<li>注意一点：生效是有一定时间的，如果你在过程中出现了一些问题，导致你加载username.github.io直接跳到你的域名，但是又还没有生效，你过一会它还是那样的，你就需要清理一下你的浏览器缓存</li>\n<li>如果不出意外，搞定，开心!</li>\n<li>如果还不行这里有两篇比较好的文章，综合一下应该没有问题</li>\n<li><a href=\"http://www.jianshu.com/p/fdb5d7978cdb\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/fdb5d7978cdb</a></li>\n<li><a href=\"http://www.jianshu.com/p/8ec1b1e5d3b2\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8ec1b1e5d3b2</a></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>还是比较喜欢总结的，因为古有温故而知新，我有总结而知新，总结是优秀的学习方法中很重要的一环，多多总结，经验才会显得牢靠，而不是泛泛而谈，没有达到脚踏实地的效果，<br> 自己做的一些有意义的事情，最后总结一下，能够加深自己的理解和印象，让你烙下深深的印记，perfect！</p>\n"},{"title":"微信小程序-开发经验总结","date":"2017-02-21T09:45:03.000Z","_content":"最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。\n废话不多说，先上图和地址\n[github地址](https://github.com/fly7632785/Weixin-joke-demo)\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n\n----------\n数据是来源于[易源数据](http://www.showapi.com)\n各自去下载吧，里面有注释。\n\n####**这里也说一些我这两天以来学习的感受和踩过的坑**\n\n###### 踩坑：\n- 首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的\n- **有时候赋值粘贴的代码**，没有效果。解决：**把那个文件最好手动再修改一下，然后重启IDE**，有时候copy不管用，还是手动敲一下\n- 有时候CSS文件修改没有效果。解决：**对应文件手动修改然后保存，command+B重新加载**。\n- 还有，文件的赋值粘贴也有问题，实际上你**不可以直接复制文件**，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE\n\n###### 技术点:\n- 我是从Android过来的，发现它最大的不同就是，它**确实有点像react**，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在**page的data里面**，如果加载好了数据，只需要修改page的data里的xxx，**对应的页面就会动态响应式的修改数据**。\n- 小程序比较方便的地方就是它已经被**封装的比较好了**，很多操作都包含在了**API里面**，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等\n- **app类的文件，可以全局使用**。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:**globleData**，每个页面都可以getApp()获得app对象\n\n\n\n###### 注意：\n- 在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载\n- 在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的\n```\n/**\n *page之外的函数\n page \b的data 就是前面的data\n page就是Page的对象\n */\nvar getJokeData = function () {\n  console.log(\"page:\" + page.data.pageIndex);\n  wx.request({\n    url: 'http://route.showapi.com/341-2',\n    data: {\n      // 这里要填填 page对象的data里面的page\n      \"page\": page.data.pageIndex,\n      \"showapi_appid\": showapi_appid,\n      \"showapi_sign\": showapi_sign\n    },\n    method: 'GET',\n    success: function (res) {\n\n      // success\n      wx.hideToast();\n      console.log(that.data.list);\n      console.log(res.data.showapi_res_body.contentlist);\n      //这里可以填page.data.list 也可以that.data.list\n      //因为that就指向page\b\b\n      var list = page.data.list;\n      for (var i = 0; i < res.data.showapi_res_body.contentlist.length; i++) {\n        list.push(res.data.showapi_res_body.contentlist[i]);\n      }\n      console.log(list);\n      //但是这里的that不能换成page 至于page和that的关系\n      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n      that.setData({\n        list: list,\n        isRefresh: false,\n        isLoadMore: false\n      })**\n\n    },\n    fail: function () {\n      // fail\n    },\n    complete: function () {\n      // complete\n    }\n  })\n}\n```\n里面要使用page的data。\n两种方法：\n1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）\n2、把this作为形参传给外部的方法使用\n\n- 我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data\n\n```\nvar page =\n{\nxxxx\n}\nPage(page)\n\n这样可以使用page.data.xxx的数据，但是不可以使用page.setData({\nxxx:xxx\n})\n\n但是我们可以使用上面的that.data.xxx的数据，也要用that.setData({\nxxx:xxx\n})\n\n原因：现在的这个page对象 确实不= that ,\nthat才是真正page对象的上下文对象，也就是page对象本身。\n而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n```\n\n#### 总结\n这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。**但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过1M，搜索没有关键字，每个账号只能发布5个，发布还要300块，**使得我们做的东西都不能随意发布展示。。。\n\n对比**Android**而言：\n确实，这种程序只能叫做** 小程序**，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的1M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远\n\n对于**运营推广**而言：\n小程序确实在**张小龙的N个不**下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。","source":"_posts/微信小程序-开发经验总结.md","raw":"---\ntitle: 微信小程序-开发经验总结\ndate: 2017-02-21 17:45:03\ntags:\n---\n最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。\n废话不多说，先上图和地址\n[github地址](https://github.com/fly7632785/Weixin-joke-demo)\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n\n----------\n数据是来源于[易源数据](http://www.showapi.com)\n各自去下载吧，里面有注释。\n\n####**这里也说一些我这两天以来学习的感受和踩过的坑**\n\n###### 踩坑：\n- 首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的\n- **有时候赋值粘贴的代码**，没有效果。解决：**把那个文件最好手动再修改一下，然后重启IDE**，有时候copy不管用，还是手动敲一下\n- 有时候CSS文件修改没有效果。解决：**对应文件手动修改然后保存，command+B重新加载**。\n- 还有，文件的赋值粘贴也有问题，实际上你**不可以直接复制文件**，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE\n\n###### 技术点:\n- 我是从Android过来的，发现它最大的不同就是，它**确实有点像react**，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在**page的data里面**，如果加载好了数据，只需要修改page的data里的xxx，**对应的页面就会动态响应式的修改数据**。\n- 小程序比较方便的地方就是它已经被**封装的比较好了**，很多操作都包含在了**API里面**，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等\n- **app类的文件，可以全局使用**。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:**globleData**，每个页面都可以getApp()获得app对象\n\n\n\n###### 注意：\n- 在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载\n- 在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的\n```\n/**\n *page之外的函数\n page \b的data 就是前面的data\n page就是Page的对象\n */\nvar getJokeData = function () {\n  console.log(\"page:\" + page.data.pageIndex);\n  wx.request({\n    url: 'http://route.showapi.com/341-2',\n    data: {\n      // 这里要填填 page对象的data里面的page\n      \"page\": page.data.pageIndex,\n      \"showapi_appid\": showapi_appid,\n      \"showapi_sign\": showapi_sign\n    },\n    method: 'GET',\n    success: function (res) {\n\n      // success\n      wx.hideToast();\n      console.log(that.data.list);\n      console.log(res.data.showapi_res_body.contentlist);\n      //这里可以填page.data.list 也可以that.data.list\n      //因为that就指向page\b\b\n      var list = page.data.list;\n      for (var i = 0; i < res.data.showapi_res_body.contentlist.length; i++) {\n        list.push(res.data.showapi_res_body.contentlist[i]);\n      }\n      console.log(list);\n      //但是这里的that不能换成page 至于page和that的关系\n      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n      that.setData({\n        list: list,\n        isRefresh: false,\n        isLoadMore: false\n      })**\n\n    },\n    fail: function () {\n      // fail\n    },\n    complete: function () {\n      // complete\n    }\n  })\n}\n```\n里面要使用page的data。\n两种方法：\n1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）\n2、把this作为形参传给外部的方法使用\n\n- 我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data\n\n```\nvar page =\n{\nxxxx\n}\nPage(page)\n\n这样可以使用page.data.xxx的数据，但是不可以使用page.setData({\nxxx:xxx\n})\n\n但是我们可以使用上面的that.data.xxx的数据，也要用that.setData({\nxxx:xxx\n})\n\n原因：现在的这个page对象 确实不= that ,\nthat才是真正page对象的上下文对象，也就是page对象本身。\n而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n```\n\n#### 总结\n这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。**但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过1M，搜索没有关键字，每个账号只能发布5个，发布还要300块，**使得我们做的东西都不能随意发布展示。。。\n\n对比**Android**而言：\n确实，这种程序只能叫做** 小程序**，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的1M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远\n\n对于**运营推广**而言：\n小程序确实在**张小龙的N个不**下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。","slug":"微信小程序-开发经验总结","published":1,"updated":"2017-02-21T11:51:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcozqjvg000j0cushv9tlt3x","content":"<p>最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。<br>废话不多说，先上图和地址<br><a href=\"https://github.com/fly7632785/Weixin-joke-demo\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<hr>\n<p>数据是来源于<a href=\"http://www.showapi.com\" target=\"_blank\" rel=\"noopener\">易源数据</a><br>各自去下载吧，里面有注释。</p>\n<p>####<strong>这里也说一些我这两天以来学习的感受和踩过的坑</strong></p>\n<h6 id=\"踩坑：\"><a href=\"#踩坑：\" class=\"headerlink\" title=\"踩坑：\"></a>踩坑：</h6><ul>\n<li>首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的</li>\n<li><strong>有时候赋值粘贴的代码</strong>，没有效果。解决：<strong>把那个文件最好手动再修改一下，然后重启IDE</strong>，有时候copy不管用，还是手动敲一下</li>\n<li>有时候CSS文件修改没有效果。解决：<strong>对应文件手动修改然后保存，command+B重新加载</strong>。</li>\n<li>还有，文件的赋值粘贴也有问题，实际上你<strong>不可以直接复制文件</strong>，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE</li>\n</ul>\n<h6 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点:\"></a>技术点:</h6><ul>\n<li>我是从Android过来的，发现它最大的不同就是，它<strong>确实有点像react</strong>，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在<strong>page的data里面</strong>，如果加载好了数据，只需要修改page的data里的xxx，<strong>对应的页面就会动态响应式的修改数据</strong>。</li>\n<li>小程序比较方便的地方就是它已经被<strong>封装的比较好了</strong>，很多操作都包含在了<strong>API里面</strong>，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等</li>\n<li><strong>app类的文件，可以全局使用</strong>。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:<strong>globleData</strong>，每个页面都可以getApp()获得app对象</li>\n</ul>\n<h6 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h6><ul>\n<li>在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载</li>\n<li>在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *page之外的函数</span><br><span class=\"line\"> page \b的data 就是前面的data</span><br><span class=\"line\"> page就是Page的对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">var getJokeData = function () &#123;</span><br><span class=\"line\">  console.log(&quot;page:&quot; + page.data.pageIndex);</span><br><span class=\"line\">  wx.request(&#123;</span><br><span class=\"line\">    url: &apos;http://route.showapi.com/341-2&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      // 这里要填填 page对象的data里面的page</span><br><span class=\"line\">      &quot;page&quot;: page.data.pageIndex,</span><br><span class=\"line\">      &quot;showapi_appid&quot;: showapi_appid,</span><br><span class=\"line\">      &quot;showapi_sign&quot;: showapi_sign</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    success: function (res) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // success</span><br><span class=\"line\">      wx.hideToast();</span><br><span class=\"line\">      console.log(that.data.list);</span><br><span class=\"line\">      console.log(res.data.showapi_res_body.contentlist);</span><br><span class=\"line\">      //这里可以填page.data.list 也可以that.data.list</span><br><span class=\"line\">      //因为that就指向page\b\b</span><br><span class=\"line\">      var list = page.data.list;</span><br><span class=\"line\">      for (var i = 0; i &lt; res.data.showapi_res_body.contentlist.length; i++) &#123;</span><br><span class=\"line\">        list.push(res.data.showapi_res_body.contentlist[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(list);</span><br><span class=\"line\">      //但是这里的that不能换成page 至于page和that的关系</span><br><span class=\"line\">      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        list: list,</span><br><span class=\"line\">        isRefresh: false,</span><br><span class=\"line\">        isLoadMore: false</span><br><span class=\"line\">      &#125;)**</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fail: function () &#123;</span><br><span class=\"line\">      // fail</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    complete: function () &#123;</span><br><span class=\"line\">      // complete</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>里面要使用page的data。<br>两种方法：<br>1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）<br>2、把this作为形参传给外部的方法使用</p>\n<ul>\n<li>我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var page =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">xxxx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Page(page)</span><br><span class=\"line\"></span><br><span class=\"line\">这样可以使用page.data.xxx的数据，但是不可以使用page.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">但是我们可以使用上面的that.data.xxx的数据，也要用that.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">原因：现在的这个page对象 确实不= that ,</span><br><span class=\"line\">that才是真正page对象的上下文对象，也就是page对象本身。</span><br><span class=\"line\">而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。<strong>但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过1M，搜索没有关键字，每个账号只能发布5个，发布还要300块，</strong>使得我们做的东西都不能随意发布展示。。。</p>\n<p>对比<strong>Android</strong>而言：<br>确实，这种程序只能叫做<strong> 小程序</strong>，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的1M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远</p>\n<p>对于<strong>运营推广</strong>而言：<br>小程序确实在<strong>张小龙的N个不</strong>下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。<br>废话不多说，先上图和地址<br><a href=\"https://github.com/fly7632785/Weixin-joke-demo\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<hr>\n<p>数据是来源于<a href=\"http://www.showapi.com\" target=\"_blank\" rel=\"noopener\">易源数据</a><br>各自去下载吧，里面有注释。</p>\n<p>####<strong>这里也说一些我这两天以来学习的感受和踩过的坑</strong></p>\n<h6 id=\"踩坑：\"><a href=\"#踩坑：\" class=\"headerlink\" title=\"踩坑：\"></a>踩坑：</h6><ul>\n<li>首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的</li>\n<li><strong>有时候赋值粘贴的代码</strong>，没有效果。解决：<strong>把那个文件最好手动再修改一下，然后重启IDE</strong>，有时候copy不管用，还是手动敲一下</li>\n<li>有时候CSS文件修改没有效果。解决：<strong>对应文件手动修改然后保存，command+B重新加载</strong>。</li>\n<li>还有，文件的赋值粘贴也有问题，实际上你<strong>不可以直接复制文件</strong>，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE</li>\n</ul>\n<h6 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点:\"></a>技术点:</h6><ul>\n<li>我是从Android过来的，发现它最大的不同就是，它<strong>确实有点像react</strong>，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在<strong>page的data里面</strong>，如果加载好了数据，只需要修改page的data里的xxx，<strong>对应的页面就会动态响应式的修改数据</strong>。</li>\n<li>小程序比较方便的地方就是它已经被<strong>封装的比较好了</strong>，很多操作都包含在了<strong>API里面</strong>，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等</li>\n<li><strong>app类的文件，可以全局使用</strong>。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:<strong>globleData</strong>，每个页面都可以getApp()获得app对象</li>\n</ul>\n<h6 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h6><ul>\n<li>在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载</li>\n<li>在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *page之外的函数</span><br><span class=\"line\"> page \b的data 就是前面的data</span><br><span class=\"line\"> page就是Page的对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">var getJokeData = function () &#123;</span><br><span class=\"line\">  console.log(&quot;page:&quot; + page.data.pageIndex);</span><br><span class=\"line\">  wx.request(&#123;</span><br><span class=\"line\">    url: &apos;http://route.showapi.com/341-2&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      // 这里要填填 page对象的data里面的page</span><br><span class=\"line\">      &quot;page&quot;: page.data.pageIndex,</span><br><span class=\"line\">      &quot;showapi_appid&quot;: showapi_appid,</span><br><span class=\"line\">      &quot;showapi_sign&quot;: showapi_sign</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    success: function (res) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // success</span><br><span class=\"line\">      wx.hideToast();</span><br><span class=\"line\">      console.log(that.data.list);</span><br><span class=\"line\">      console.log(res.data.showapi_res_body.contentlist);</span><br><span class=\"line\">      //这里可以填page.data.list 也可以that.data.list</span><br><span class=\"line\">      //因为that就指向page\b\b</span><br><span class=\"line\">      var list = page.data.list;</span><br><span class=\"line\">      for (var i = 0; i &lt; res.data.showapi_res_body.contentlist.length; i++) &#123;</span><br><span class=\"line\">        list.push(res.data.showapi_res_body.contentlist[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(list);</span><br><span class=\"line\">      //但是这里的that不能换成page 至于page和that的关系</span><br><span class=\"line\">      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        list: list,</span><br><span class=\"line\">        isRefresh: false,</span><br><span class=\"line\">        isLoadMore: false</span><br><span class=\"line\">      &#125;)**</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fail: function () &#123;</span><br><span class=\"line\">      // fail</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    complete: function () &#123;</span><br><span class=\"line\">      // complete</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>里面要使用page的data。<br>两种方法：<br>1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）<br>2、把this作为形参传给外部的方法使用</p>\n<ul>\n<li>我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var page =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">xxxx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Page(page)</span><br><span class=\"line\"></span><br><span class=\"line\">这样可以使用page.data.xxx的数据，但是不可以使用page.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">但是我们可以使用上面的that.data.xxx的数据，也要用that.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">原因：现在的这个page对象 确实不= that ,</span><br><span class=\"line\">that才是真正page对象的上下文对象，也就是page对象本身。</span><br><span class=\"line\">而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。<strong>但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过1M，搜索没有关键字，每个账号只能发布5个，发布还要300块，</strong>使得我们做的东西都不能随意发布展示。。。</p>\n<p>对比<strong>Android</strong>而言：<br>确实，这种程序只能叫做<strong> 小程序</strong>，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的1M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远</p>\n<p>对于<strong>运营推广</strong>而言：<br>小程序确实在<strong>张小龙的N个不</strong>下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。</p>\n"},{"title":"微信小程序--搞笑图片app","date":"2017-01-19T01:51:17.000Z","_content":"\n最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。\n废话不多说，先上图和地址\n[github地址](https://github.com/fly7632785/Weixin-joke-demo)\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n\n----------\n数据是来源于[易源数据](http://www.showapi.com)\n各自去下载吧，里面有注释。\n\n#### **这里也说一些我这两天以来学习的感受和踩过的坑**\n\n###### 踩坑：\n- 首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的\n- **有时候赋值粘贴的代码**，没有效果。解决：**把那个文件最好手动再修改一下，然后重启IDE**，有时候copy不管用，还是手动敲一下\n- 有时候CSS文件修改没有效果。解决：**对应文件手动修改然后保存，command+B重新加载**。\n- 还有，文件的赋值粘贴也有问题，实际上你**不可以直接复制文件**，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE\n\n###### 技术点:\n- 我是从Android过来的，发现它最大的不同就是，它**确实有点像react**，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在**page的data里面**，如果加载好了数据，只需要修改page的data里的xxx，**对应的页面就会动态响应式的修改数据**。\n- 小程序比较方便的地方就是它已经被**封装的比较好了**，很多操作都包含在了**API里面**，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等\n- **app类的文件，可以全局使用**。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:**globleData**，每个页面都可以getApp()获得app对象\n\n\n\n###### 注意：\n- 在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载\n- 在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的\n```\n/**\n *page之外的函数\n page \b的data 就是前面的data\n page就是Page的对象\n */\nvar getJokeData = function () {\n  console.log(\"page:\" + page.data.pageIndex);\n  wx.request({\n    url: 'http://route.showapi.com/341-2',\n    data: {\n      // 这里要填填 page对象的data里面的page\n      \"page\": page.data.pageIndex,\n      \"showapi_appid\": showapi_appid,\n      \"showapi_sign\": showapi_sign\n    },\n    method: 'GET',\n    success: function (res) {\n\n      // success\n      wx.hideToast();\n      console.log(that.data.list);\n      console.log(res.data.showapi_res_body.contentlist);\n      //这里可以填page.data.list 也可以that.data.list\n      //因为that就指向page\b\b\n      var list = page.data.list;\n      for (var i = 0; i < res.data.showapi_res_body.contentlist.length; i++) {\n        list.push(res.data.showapi_res_body.contentlist[i]);\n      }\n      console.log(list);\n      //但是这里的that不能换成page 至于page和that的关系\n      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n      that.setData({\n        list: list,\n        isRefresh: false,\n        isLoadMore: false\n      })**\n\n    },\n    fail: function () {\n      // fail\n    },\n    complete: function () {\n      // complete\n    }\n  })\n}\n```\n里面要使用page的data。\n两种方法：\n1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）\n2、把this作为形参传给外部的方法使用\n\n- 我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data\n\n```\nvar page =\n{\nxxxx\n}\nPage(page)\n\n这样可以使用page.data.xxx的数据，但是不可以使用page.setData({\nxxx:xxx\n})\n\n但是我们可以使用上面的that.data.xxx的数据，也要用that.setData({\nxxx:xxx\n})\n\n原因：现在的这个page对象 确实不= that ,\nthat才是真正page对象的上下文对象，也就是page对象本身。\n而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n```\n\n#### 总结\n这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。**但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过5M，搜索没有关键字，每个账号只能发布1个，发布还要300块，**使得我们做的东西都不能随意发布展示。。。\n\n对比**Android**而言：\n确实，这种程序只能叫做** 小程序**，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的5M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远\n\n对于**运营推广**而言：\n小程序确实在**张小龙的N个不**下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。\n","source":"_posts/微信小程序.md","raw":"---\ntitle: 微信小程序--搞笑图片app\ndate: 2017-01-19 09:51:17\ntags:\n---\n\n最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。\n废话不多说，先上图和地址\n[github地址](https://github.com/fly7632785/Weixin-joke-demo)\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n<img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"/>\n\n\n----------\n数据是来源于[易源数据](http://www.showapi.com)\n各自去下载吧，里面有注释。\n\n#### **这里也说一些我这两天以来学习的感受和踩过的坑**\n\n###### 踩坑：\n- 首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的\n- **有时候赋值粘贴的代码**，没有效果。解决：**把那个文件最好手动再修改一下，然后重启IDE**，有时候copy不管用，还是手动敲一下\n- 有时候CSS文件修改没有效果。解决：**对应文件手动修改然后保存，command+B重新加载**。\n- 还有，文件的赋值粘贴也有问题，实际上你**不可以直接复制文件**，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE\n\n###### 技术点:\n- 我是从Android过来的，发现它最大的不同就是，它**确实有点像react**，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在**page的data里面**，如果加载好了数据，只需要修改page的data里的xxx，**对应的页面就会动态响应式的修改数据**。\n- 小程序比较方便的地方就是它已经被**封装的比较好了**，很多操作都包含在了**API里面**，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等\n- **app类的文件，可以全局使用**。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:**globleData**，每个页面都可以getApp()获得app对象\n\n\n\n###### 注意：\n- 在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载\n- 在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的\n```\n/**\n *page之外的函数\n page \b的data 就是前面的data\n page就是Page的对象\n */\nvar getJokeData = function () {\n  console.log(\"page:\" + page.data.pageIndex);\n  wx.request({\n    url: 'http://route.showapi.com/341-2',\n    data: {\n      // 这里要填填 page对象的data里面的page\n      \"page\": page.data.pageIndex,\n      \"showapi_appid\": showapi_appid,\n      \"showapi_sign\": showapi_sign\n    },\n    method: 'GET',\n    success: function (res) {\n\n      // success\n      wx.hideToast();\n      console.log(that.data.list);\n      console.log(res.data.showapi_res_body.contentlist);\n      //这里可以填page.data.list 也可以that.data.list\n      //因为that就指向page\b\b\n      var list = page.data.list;\n      for (var i = 0; i < res.data.showapi_res_body.contentlist.length; i++) {\n        list.push(res.data.showapi_res_body.contentlist[i]);\n      }\n      console.log(list);\n      //但是这里的that不能换成page 至于page和that的关系\n      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n      that.setData({\n        list: list,\n        isRefresh: false,\n        isLoadMore: false\n      })**\n\n    },\n    fail: function () {\n      // fail\n    },\n    complete: function () {\n      // complete\n    }\n  })\n}\n```\n里面要使用page的data。\n两种方法：\n1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）\n2、把this作为形参传给外部的方法使用\n\n- 我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data\n\n```\nvar page =\n{\nxxxx\n}\nPage(page)\n\n这样可以使用page.data.xxx的数据，但是不可以使用page.setData({\nxxx:xxx\n})\n\n但是我们可以使用上面的that.data.xxx的数据，也要用that.setData({\nxxx:xxx\n})\n\n原因：现在的这个page对象 确实不= that ,\nthat才是真正page对象的上下文对象，也就是page对象本身。\n而，我的page只是作为一个形参传入，并没有初始化  所以page！=that\n```\n\n#### 总结\n这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。**但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过5M，搜索没有关键字，每个账号只能发布1个，发布还要300块，**使得我们做的东西都不能随意发布展示。。。\n\n对比**Android**而言：\n确实，这种程序只能叫做** 小程序**，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的5M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远\n\n对于**运营推广**而言：\n小程序确实在**张小龙的N个不**下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。\n","slug":"微信小程序","published":1,"updated":"2017-01-19T01:54:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcozqjvj000m0cus1od1cgwi","content":"<p>最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。<br>废话不多说，先上图和地址<br><a href=\"https://github.com/fly7632785/Weixin-joke-demo\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<hr>\n<p>数据是来源于<a href=\"http://www.showapi.com\" target=\"_blank\" rel=\"noopener\">易源数据</a><br>各自去下载吧，里面有注释。</p>\n<h4 id=\"这里也说一些我这两天以来学习的感受和踩过的坑\"><a href=\"#这里也说一些我这两天以来学习的感受和踩过的坑\" class=\"headerlink\" title=\"这里也说一些我这两天以来学习的感受和踩过的坑\"></a><strong>这里也说一些我这两天以来学习的感受和踩过的坑</strong></h4><h6 id=\"踩坑：\"><a href=\"#踩坑：\" class=\"headerlink\" title=\"踩坑：\"></a>踩坑：</h6><ul>\n<li>首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的</li>\n<li><strong>有时候赋值粘贴的代码</strong>，没有效果。解决：<strong>把那个文件最好手动再修改一下，然后重启IDE</strong>，有时候copy不管用，还是手动敲一下</li>\n<li>有时候CSS文件修改没有效果。解决：<strong>对应文件手动修改然后保存，command+B重新加载</strong>。</li>\n<li>还有，文件的赋值粘贴也有问题，实际上你<strong>不可以直接复制文件</strong>，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE</li>\n</ul>\n<h6 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点:\"></a>技术点:</h6><ul>\n<li>我是从Android过来的，发现它最大的不同就是，它<strong>确实有点像react</strong>，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在<strong>page的data里面</strong>，如果加载好了数据，只需要修改page的data里的xxx，<strong>对应的页面就会动态响应式的修改数据</strong>。</li>\n<li>小程序比较方便的地方就是它已经被<strong>封装的比较好了</strong>，很多操作都包含在了<strong>API里面</strong>，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等</li>\n<li><strong>app类的文件，可以全局使用</strong>。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:<strong>globleData</strong>，每个页面都可以getApp()获得app对象</li>\n</ul>\n<h6 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h6><ul>\n<li>在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载</li>\n<li>在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *page之外的函数</span><br><span class=\"line\"> page \b的data 就是前面的data</span><br><span class=\"line\"> page就是Page的对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">var getJokeData = function () &#123;</span><br><span class=\"line\">  console.log(&quot;page:&quot; + page.data.pageIndex);</span><br><span class=\"line\">  wx.request(&#123;</span><br><span class=\"line\">    url: &apos;http://route.showapi.com/341-2&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      // 这里要填填 page对象的data里面的page</span><br><span class=\"line\">      &quot;page&quot;: page.data.pageIndex,</span><br><span class=\"line\">      &quot;showapi_appid&quot;: showapi_appid,</span><br><span class=\"line\">      &quot;showapi_sign&quot;: showapi_sign</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    success: function (res) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // success</span><br><span class=\"line\">      wx.hideToast();</span><br><span class=\"line\">      console.log(that.data.list);</span><br><span class=\"line\">      console.log(res.data.showapi_res_body.contentlist);</span><br><span class=\"line\">      //这里可以填page.data.list 也可以that.data.list</span><br><span class=\"line\">      //因为that就指向page\b\b</span><br><span class=\"line\">      var list = page.data.list;</span><br><span class=\"line\">      for (var i = 0; i &lt; res.data.showapi_res_body.contentlist.length; i++) &#123;</span><br><span class=\"line\">        list.push(res.data.showapi_res_body.contentlist[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(list);</span><br><span class=\"line\">      //但是这里的that不能换成page 至于page和that的关系</span><br><span class=\"line\">      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        list: list,</span><br><span class=\"line\">        isRefresh: false,</span><br><span class=\"line\">        isLoadMore: false</span><br><span class=\"line\">      &#125;)**</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fail: function () &#123;</span><br><span class=\"line\">      // fail</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    complete: function () &#123;</span><br><span class=\"line\">      // complete</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>里面要使用page的data。<br>两种方法：<br>1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）<br>2、把this作为形参传给外部的方法使用</p>\n<ul>\n<li>我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var page =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">xxxx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Page(page)</span><br><span class=\"line\"></span><br><span class=\"line\">这样可以使用page.data.xxx的数据，但是不可以使用page.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">但是我们可以使用上面的that.data.xxx的数据，也要用that.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">原因：现在的这个page对象 确实不= that ,</span><br><span class=\"line\">that才是真正page对象的上下文对象，也就是page对象本身。</span><br><span class=\"line\">而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。<strong>但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过5M，搜索没有关键字，每个账号只能发布1个，发布还要300块，</strong>使得我们做的东西都不能随意发布展示。。。</p>\n<p>对比<strong>Android</strong>而言：<br>确实，这种程序只能叫做<strong> 小程序</strong>，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的5M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远</p>\n<p>对于<strong>运营推广</strong>而言：<br>小程序确实在<strong>张小龙的N个不</strong>下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近小程序一公测，我也来学习了一下，然后玩了个简单的APP。<br>废话不多说，先上图和地址<br><a href=\"https://github.com/fly7632785/Weixin-joke-demo\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-52595180d53b4701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-a12647866a1172b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e75926df78ca62c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340\" width=\"30%\"></p>\n<hr>\n<p>数据是来源于<a href=\"http://www.showapi.com\" target=\"_blank\" rel=\"noopener\">易源数据</a><br>各自去下载吧，里面有注释。</p>\n<h4 id=\"这里也说一些我这两天以来学习的感受和踩过的坑\"><a href=\"#这里也说一些我这两天以来学习的感受和踩过的坑\" class=\"headerlink\" title=\"这里也说一些我这两天以来学习的感受和踩过的坑\"></a><strong>这里也说一些我这两天以来学习的感受和踩过的坑</strong></h4><h6 id=\"踩坑：\"><a href=\"#踩坑：\" class=\"headerlink\" title=\"踩坑：\"></a>踩坑：</h6><ul>\n<li>首先是IDE不好用，有很多BUG，比如打开项目窗口很小，保存没有效果，而且文件显示有问题等的</li>\n<li><strong>有时候赋值粘贴的代码</strong>，没有效果。解决：<strong>把那个文件最好手动再修改一下，然后重启IDE</strong>，有时候copy不管用，还是手动敲一下</li>\n<li>有时候CSS文件修改没有效果。解决：<strong>对应文件手动修改然后保存，command+B重新加载</strong>。</li>\n<li>还有，文件的赋值粘贴也有问题，实际上你<strong>不可以直接复制文件</strong>，然后在IDE里面直接粘贴。只有先打开硬盘，然后赋值粘贴，有时候你复制粘贴了之后，没有效果。重新修改保存一下文件，重启IDE</li>\n</ul>\n<h6 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点:\"></a>技术点:</h6><ul>\n<li>我是从Android过来的，发现它最大的不同就是，它<strong>确实有点像react</strong>，听说好想内核算法机制那些用的就是react的。比如页面的数据来源，一般是在<strong>page的data里面</strong>，如果加载好了数据，只需要修改page的data里的xxx，<strong>对应的页面就会动态响应式的修改数据</strong>。</li>\n<li>小程序比较方便的地方就是它已经被<strong>封装的比较好了</strong>，很多操作都包含在了<strong>API里面</strong>，微信已经把自身和小程序一起封装在了一起，比如什么上传图片，调用相机，客服消息，通知消息等等</li>\n<li><strong>app类的文件，可以全局使用</strong>。比如app.wxss里面的样式可以全局使用，app.json可以配置整个app的一些属性，app.js里面可以写全局的数据:<strong>globleData</strong>，每个页面都可以getApp()获得app对象</li>\n</ul>\n<h6 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h6><ul>\n<li>在实现上下拉刷新加载，最好是用scroll-view的bindscrolltoupper、bindscrolltolower然后触发对应的方法进行刷新和加载</li>\n<li>在实现请求数据的时候，是写了一个方法，这个方法是在Page{}外面的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *page之外的函数</span><br><span class=\"line\"> page \b的data 就是前面的data</span><br><span class=\"line\"> page就是Page的对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">var getJokeData = function () &#123;</span><br><span class=\"line\">  console.log(&quot;page:&quot; + page.data.pageIndex);</span><br><span class=\"line\">  wx.request(&#123;</span><br><span class=\"line\">    url: &apos;http://route.showapi.com/341-2&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      // 这里要填填 page对象的data里面的page</span><br><span class=\"line\">      &quot;page&quot;: page.data.pageIndex,</span><br><span class=\"line\">      &quot;showapi_appid&quot;: showapi_appid,</span><br><span class=\"line\">      &quot;showapi_sign&quot;: showapi_sign</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    success: function (res) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      // success</span><br><span class=\"line\">      wx.hideToast();</span><br><span class=\"line\">      console.log(that.data.list);</span><br><span class=\"line\">      console.log(res.data.showapi_res_body.contentlist);</span><br><span class=\"line\">      //这里可以填page.data.list 也可以that.data.list</span><br><span class=\"line\">      //因为that就指向page\b\b</span><br><span class=\"line\">      var list = page.data.list;</span><br><span class=\"line\">      for (var i = 0; i &lt; res.data.showapi_res_body.contentlist.length; i++) &#123;</span><br><span class=\"line\">        list.push(res.data.showapi_res_body.contentlist[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(list);</span><br><span class=\"line\">      //但是这里的that不能换成page 至于page和that的关系</span><br><span class=\"line\">      //因为现在的这个page对象 确实不= that ,that才是真正page对象的上下文对象，也就是page对象本身。 而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        list: list,</span><br><span class=\"line\">        isRefresh: false,</span><br><span class=\"line\">        isLoadMore: false</span><br><span class=\"line\">      &#125;)**</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fail: function () &#123;</span><br><span class=\"line\">      // fail</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    complete: function () &#123;</span><br><span class=\"line\">      // complete</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>里面要使用page的data。<br>两种方法：<br>1、定义一个全局that ，在page中去赋值，这样外部的方法就可以调用that.setData赋值了（我用的是这种）<br>2、把this作为形参传给外部的方法使用</p>\n<ul>\n<li>我看到很多demo里面把page对象定义成一个对象提出来，然后使用其data</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var page =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">xxxx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Page(page)</span><br><span class=\"line\"></span><br><span class=\"line\">这样可以使用page.data.xxx的数据，但是不可以使用page.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">但是我们可以使用上面的that.data.xxx的数据，也要用that.setData(&#123;</span><br><span class=\"line\">xxx:xxx</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">原因：现在的这个page对象 确实不= that ,</span><br><span class=\"line\">that才是真正page对象的上下文对象，也就是page对象本身。</span><br><span class=\"line\">而，我的page只是作为一个形参传入，并没有初始化  所以page！=that</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这两天学习小程序，就开发者而言发现，它确实开发起来比较简单，而且很多东西依赖微信，而微信又封装了，所以调用API就能解决很多问题。<strong>但是，有一些个性化定制的问题现在有很多坑，因为微信小程序有一些限制存在：不能超过5M，搜索没有关键字，每个账号只能发布1个，发布还要300块，</strong>使得我们做的东西都不能随意发布展示。。。</p>\n<p>对比<strong>Android</strong>而言：<br>确实，这种程序只能叫做<strong> 小程序</strong>，拿来玩一玩，因为它只能实现一些很简单的展示型功能，在交互上面有很大的限制，并且它的5M比65535可难受多了。性能上面，我觉得跟webApp差不多，但是webApp由于发展了这么久，肯定比它的优势还大得多。但是跟原生比，性能上面还是差得太远</p>\n<p>对于<strong>运营推广</strong>而言：<br>小程序确实在<strong>张小龙的N个不</strong>下面难以发挥我们所期盼它发挥的作用（赚取第一桶金的热头），但是张小龙的战略机会，未来的微信的生态圈趋势发展如何，我们还没有太多的看法，只有顺应局势，等待机会啦。</p>\n"},{"title":"你的三观是什么","date":"2017-01-20T08:33:47.000Z","_content":"![](http://upload-images.jianshu.io/upload_images/1311457-af2e20094e1a0ac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我觉得在现在这个网络时代，这个信息充斥的时代，甄别是非真假的能力是需要的，不能随意听之便信之。别人说什么，不能轻易相信。就拿“毁三观”、“三观不正”来说吧。\n\n现在说的“三观”在网上流行之后，变了味道。好像已经不是指的以前的三观：**爱情观、价值观、人生观**了。好像已经变成了，**你处事的态度、对事情的看法、对某些现象的理解、做事情的方式等等**。有时候有人说你“三观不正”，可能并不是那么严肃，并不是指的你的人生观、价值观、世界观有问题，而是指的你的某些看法、方式、做法、态度有问题。这种现象出现呢，并不是没有原因的，就像这个时代，网络时代追求的是**新鲜、新奇、新颖**，如果没有**“创新”**那么就会淘汰。\n\n比如，现在很多宣传广告等，会把某些成语进行篡改。类似：其（骑）乐无穷 、食全食美（十全十美 ）、“咳”不容缓(止咳药广告) 刻不容缓等等。这样就算是推陈出新了，看起来真是“两全其美”啊。\n\n但是我个人觉得，这样东西的出现是无可避免的，我们也没有办法阻止，但是，从自身出发，如果我们**拥有甄别是非真假的能力**，辨别哪些东西是别出了心样，哪些东西还是原来的意思，我们就能更好的掌握和保持时代前进一致的步伐。\n\n就像，我跟我女朋友吵架。不是因为别的，就是因为我个人对“三观不正”的理解没有跟很多网络人士一样”与时俱进“，虽然我本来是个做互联网的人，但是，我对于三观这个严肃的东西还是**保持着应有的尊敬和不懈怠的态度**。所以，我认为她说我”三观不正“就是指的我的**人生观、价值观、世界观**有问题了。所以，我就有点不开心了。可能我有些言重了。我说：”每个人都有每个人的底线，你说我三观不正，对于男生而言就是触及了他们的底线，就相当于是人格的侮辱，如果你骂我是傻逼 说我傻  说我幼稚 我一点都不会在意，但是这个不行。三观 算是很重要的东西了把，一个人活在世上很多都是与三观相关，**如果有人告诉他他的三观不正，那么他就会开始怀疑自己，怀疑人生，怀疑这个世界**。  所以，我奉劝你不要轻易说这些话。“\n\n后面看看，可能我却是太过于言重和严肃了。也可能就是我没有跟上时代的脚步，没有把”三观不正“的现在意思给理解到位吧。后来她也跟我说，她不是那个意思，而是指的我对事情的看法有问题。所以，**在这里跟她道个歉**，我太过于严肃，也言重了。\n\n当我和她谈及三观的之后，我就在思考，**三观到底是什么**。然后我就开始百度搜索，想看看大家的看法。看了百度百科，有了大致的印象，就是人生观、价值观、世界观这三大观。然后看了知乎，发现**每个人对三大观又细分的理解都有点不一样**。\n\n确实，如事实所表现的那样，**每个人的三观都有所不同**，每个人**都有自己独特的三观意识**，可能不是每个人都整理过思考过自己的三观，但是潜意识里和平常行为处理的过程中都若隐若现着，每个人都三观都是跟自己所处的环境、所见所闻所感有关联的，所以可能都不太一样。说实话，我也在思考我的三观，非要我说，如果在没有整理过的情况下，我也说不太清楚。\n\n所以，**在对于三观这个问题的理解上，各有千秋**。我想就算是真正的大师、大哲学家他们的三观也肯定是不同的，他们自己对于自己三观的理解上肯定也不同。我想，**正 与 不正 这一说，应该是没有实质性、准确性的划分的**。希特勒有自己的三观、毛主席有自己的三观，纳粹党人有他们的三观，共产党人也有他们的三观，正 与 不正，可能在普世眼里大多数人都觉得希特勒三观不正、毛主席三观正。但是，可能纳粹党人就会觉得共产党人三观不正，共产党人也觉得纳粹三观不正。（这里抛开那些残暴血腥的非人类行为而言）\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-22d73419880b218f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n正 与 不正，我想应该用一个辩证的眼光来看吧。我猜，那些大哲学家、大师也没有能轻易地说谁谁谁的三观不正吧，因为这个东西要是**以严肃、哲学的眼光和角度来看待**，那就不是轻易能够评判得清楚的了。我们在这是信息云集的时代，语言、含义、表象都不同于往日，我们要有甄别是非真假的能力，是非常重要的。\n\n这里的**甄别是非真假，并不仅仅指的是甄别网络上的骗局、假消息、错误言论、有色舆论等等，而更多的指的是我们能够”与时俱进“地更新自己对于这个时代的认识**，**更具体一点说就是，我们要在语言文学方面不落后，在发展的潮流中不随波逐流，在人云亦云的社会中要保持自己的本真，最好是能够出淤泥而不染濯青莲而不妖**。不能觉得现在好像大大小小的人物都在玩出轨什么的，你也觉得出轨好像已经变成可以被理解和认同的事情，要有坚定的意识和正确的三观，这样才能让你保持清醒的意识，不陷入社会淤泥的漩涡。\n\n谈了这么多是是而非的话，好像也没多大用，多半都是说给我自己听，让我理清思路用的，你们就看过且过吧。不过，我也开始思考和整理自己的三观，让自己也能够在别人询问你”你的三观是什么“的时候不至于慌了阵脚。\n\n- 世界观：\n**就我个人而言，我觉得这个世界还是一个美好的世界，有很多美好的东西值得我们去领略争取，在某些方面是相对公平的，得到与得不到就是努力与不努力的最公平印证。**\n\n- 人生观:\n**我认为，人活一辈子，不应该白活，应该通过自己的能力去推动整个人类社会的走向美好的发展，学会去创造，而不是摧毁。在自己有限的生命里，应该去做一些有意义的事情来体现自身应有的价值。**\n\n- 价值观:\n**我认为，所有美好的事物都值得我们通过自己的努力去追求获得，每个人都有获得的权利。每个人都有存在和体现的价值，物质的价值和精神的价值是不可比拟的，对于我个人而言，我更多是在追求精神层面的价值，也希望能够体现自身对于人类社会的价值。**\n\n以上也就算是我**此时此人生阶段的三观**。不和别人比，也肯定和别人不同，我只需要恪守自己的三观就好。\n\n谢谢观阅。\n\nps:希望来此评论的人，都整理一下自己的三观，让大家看一看。","source":"_posts/你的三观是什么.md","raw":"---\ntitle: 你的三观是什么\ndate: 2017-01-20 16:33:47\ntags:\n---\n![](http://upload-images.jianshu.io/upload_images/1311457-af2e20094e1a0ac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我觉得在现在这个网络时代，这个信息充斥的时代，甄别是非真假的能力是需要的，不能随意听之便信之。别人说什么，不能轻易相信。就拿“毁三观”、“三观不正”来说吧。\n\n现在说的“三观”在网上流行之后，变了味道。好像已经不是指的以前的三观：**爱情观、价值观、人生观**了。好像已经变成了，**你处事的态度、对事情的看法、对某些现象的理解、做事情的方式等等**。有时候有人说你“三观不正”，可能并不是那么严肃，并不是指的你的人生观、价值观、世界观有问题，而是指的你的某些看法、方式、做法、态度有问题。这种现象出现呢，并不是没有原因的，就像这个时代，网络时代追求的是**新鲜、新奇、新颖**，如果没有**“创新”**那么就会淘汰。\n\n比如，现在很多宣传广告等，会把某些成语进行篡改。类似：其（骑）乐无穷 、食全食美（十全十美 ）、“咳”不容缓(止咳药广告) 刻不容缓等等。这样就算是推陈出新了，看起来真是“两全其美”啊。\n\n但是我个人觉得，这样东西的出现是无可避免的，我们也没有办法阻止，但是，从自身出发，如果我们**拥有甄别是非真假的能力**，辨别哪些东西是别出了心样，哪些东西还是原来的意思，我们就能更好的掌握和保持时代前进一致的步伐。\n\n就像，我跟我女朋友吵架。不是因为别的，就是因为我个人对“三观不正”的理解没有跟很多网络人士一样”与时俱进“，虽然我本来是个做互联网的人，但是，我对于三观这个严肃的东西还是**保持着应有的尊敬和不懈怠的态度**。所以，我认为她说我”三观不正“就是指的我的**人生观、价值观、世界观**有问题了。所以，我就有点不开心了。可能我有些言重了。我说：”每个人都有每个人的底线，你说我三观不正，对于男生而言就是触及了他们的底线，就相当于是人格的侮辱，如果你骂我是傻逼 说我傻  说我幼稚 我一点都不会在意，但是这个不行。三观 算是很重要的东西了把，一个人活在世上很多都是与三观相关，**如果有人告诉他他的三观不正，那么他就会开始怀疑自己，怀疑人生，怀疑这个世界**。  所以，我奉劝你不要轻易说这些话。“\n\n后面看看，可能我却是太过于言重和严肃了。也可能就是我没有跟上时代的脚步，没有把”三观不正“的现在意思给理解到位吧。后来她也跟我说，她不是那个意思，而是指的我对事情的看法有问题。所以，**在这里跟她道个歉**，我太过于严肃，也言重了。\n\n当我和她谈及三观的之后，我就在思考，**三观到底是什么**。然后我就开始百度搜索，想看看大家的看法。看了百度百科，有了大致的印象，就是人生观、价值观、世界观这三大观。然后看了知乎，发现**每个人对三大观又细分的理解都有点不一样**。\n\n确实，如事实所表现的那样，**每个人的三观都有所不同**，每个人**都有自己独特的三观意识**，可能不是每个人都整理过思考过自己的三观，但是潜意识里和平常行为处理的过程中都若隐若现着，每个人都三观都是跟自己所处的环境、所见所闻所感有关联的，所以可能都不太一样。说实话，我也在思考我的三观，非要我说，如果在没有整理过的情况下，我也说不太清楚。\n\n所以，**在对于三观这个问题的理解上，各有千秋**。我想就算是真正的大师、大哲学家他们的三观也肯定是不同的，他们自己对于自己三观的理解上肯定也不同。我想，**正 与 不正 这一说，应该是没有实质性、准确性的划分的**。希特勒有自己的三观、毛主席有自己的三观，纳粹党人有他们的三观，共产党人也有他们的三观，正 与 不正，可能在普世眼里大多数人都觉得希特勒三观不正、毛主席三观正。但是，可能纳粹党人就会觉得共产党人三观不正，共产党人也觉得纳粹三观不正。（这里抛开那些残暴血腥的非人类行为而言）\n\n\n![](http://upload-images.jianshu.io/upload_images/1311457-22d73419880b218f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n正 与 不正，我想应该用一个辩证的眼光来看吧。我猜，那些大哲学家、大师也没有能轻易地说谁谁谁的三观不正吧，因为这个东西要是**以严肃、哲学的眼光和角度来看待**，那就不是轻易能够评判得清楚的了。我们在这是信息云集的时代，语言、含义、表象都不同于往日，我们要有甄别是非真假的能力，是非常重要的。\n\n这里的**甄别是非真假，并不仅仅指的是甄别网络上的骗局、假消息、错误言论、有色舆论等等，而更多的指的是我们能够”与时俱进“地更新自己对于这个时代的认识**，**更具体一点说就是，我们要在语言文学方面不落后，在发展的潮流中不随波逐流，在人云亦云的社会中要保持自己的本真，最好是能够出淤泥而不染濯青莲而不妖**。不能觉得现在好像大大小小的人物都在玩出轨什么的，你也觉得出轨好像已经变成可以被理解和认同的事情，要有坚定的意识和正确的三观，这样才能让你保持清醒的意识，不陷入社会淤泥的漩涡。\n\n谈了这么多是是而非的话，好像也没多大用，多半都是说给我自己听，让我理清思路用的，你们就看过且过吧。不过，我也开始思考和整理自己的三观，让自己也能够在别人询问你”你的三观是什么“的时候不至于慌了阵脚。\n\n- 世界观：\n**就我个人而言，我觉得这个世界还是一个美好的世界，有很多美好的东西值得我们去领略争取，在某些方面是相对公平的，得到与得不到就是努力与不努力的最公平印证。**\n\n- 人生观:\n**我认为，人活一辈子，不应该白活，应该通过自己的能力去推动整个人类社会的走向美好的发展，学会去创造，而不是摧毁。在自己有限的生命里，应该去做一些有意义的事情来体现自身应有的价值。**\n\n- 价值观:\n**我认为，所有美好的事物都值得我们通过自己的努力去追求获得，每个人都有获得的权利。每个人都有存在和体现的价值，物质的价值和精神的价值是不可比拟的，对于我个人而言，我更多是在追求精神层面的价值，也希望能够体现自身对于人类社会的价值。**\n\n以上也就算是我**此时此人生阶段的三观**。不和别人比，也肯定和别人不同，我只需要恪守自己的三观就好。\n\n谢谢观阅。\n\nps:希望来此评论的人，都整理一下自己的三观，让大家看一看。","slug":"你的三观是什么","published":1,"updated":"2017-01-20T08:37:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcozqjvm000o0cusi9lwo00d","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-af2e20094e1a0ac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我觉得在现在这个网络时代，这个信息充斥的时代，甄别是非真假的能力是需要的，不能随意听之便信之。别人说什么，不能轻易相信。就拿“毁三观”、“三观不正”来说吧。</p>\n<p>现在说的“三观”在网上流行之后，变了味道。好像已经不是指的以前的三观：<strong>爱情观、价值观、人生观</strong>了。好像已经变成了，<strong>你处事的态度、对事情的看法、对某些现象的理解、做事情的方式等等</strong>。有时候有人说你“三观不正”，可能并不是那么严肃，并不是指的你的人生观、价值观、世界观有问题，而是指的你的某些看法、方式、做法、态度有问题。这种现象出现呢，并不是没有原因的，就像这个时代，网络时代追求的是<strong>新鲜、新奇、新颖</strong>，如果没有<strong>“创新”</strong>那么就会淘汰。</p>\n<p>比如，现在很多宣传广告等，会把某些成语进行篡改。类似：其（骑）乐无穷 、食全食美（十全十美 ）、“咳”不容缓(止咳药广告) 刻不容缓等等。这样就算是推陈出新了，看起来真是“两全其美”啊。</p>\n<p>但是我个人觉得，这样东西的出现是无可避免的，我们也没有办法阻止，但是，从自身出发，如果我们<strong>拥有甄别是非真假的能力</strong>，辨别哪些东西是别出了心样，哪些东西还是原来的意思，我们就能更好的掌握和保持时代前进一致的步伐。</p>\n<p>就像，我跟我女朋友吵架。不是因为别的，就是因为我个人对“三观不正”的理解没有跟很多网络人士一样”与时俱进“，虽然我本来是个做互联网的人，但是，我对于三观这个严肃的东西还是<strong>保持着应有的尊敬和不懈怠的态度</strong>。所以，我认为她说我”三观不正“就是指的我的<strong>人生观、价值观、世界观</strong>有问题了。所以，我就有点不开心了。可能我有些言重了。我说：”每个人都有每个人的底线，你说我三观不正，对于男生而言就是触及了他们的底线，就相当于是人格的侮辱，如果你骂我是傻逼 说我傻  说我幼稚 我一点都不会在意，但是这个不行。三观 算是很重要的东西了把，一个人活在世上很多都是与三观相关，<strong>如果有人告诉他他的三观不正，那么他就会开始怀疑自己，怀疑人生，怀疑这个世界</strong>。  所以，我奉劝你不要轻易说这些话。“</p>\n<p>后面看看，可能我却是太过于言重和严肃了。也可能就是我没有跟上时代的脚步，没有把”三观不正“的现在意思给理解到位吧。后来她也跟我说，她不是那个意思，而是指的我对事情的看法有问题。所以，<strong>在这里跟她道个歉</strong>，我太过于严肃，也言重了。</p>\n<p>当我和她谈及三观的之后，我就在思考，<strong>三观到底是什么</strong>。然后我就开始百度搜索，想看看大家的看法。看了百度百科，有了大致的印象，就是人生观、价值观、世界观这三大观。然后看了知乎，发现<strong>每个人对三大观又细分的理解都有点不一样</strong>。</p>\n<p>确实，如事实所表现的那样，<strong>每个人的三观都有所不同</strong>，每个人<strong>都有自己独特的三观意识</strong>，可能不是每个人都整理过思考过自己的三观，但是潜意识里和平常行为处理的过程中都若隐若现着，每个人都三观都是跟自己所处的环境、所见所闻所感有关联的，所以可能都不太一样。说实话，我也在思考我的三观，非要我说，如果在没有整理过的情况下，我也说不太清楚。</p>\n<p>所以，<strong>在对于三观这个问题的理解上，各有千秋</strong>。我想就算是真正的大师、大哲学家他们的三观也肯定是不同的，他们自己对于自己三观的理解上肯定也不同。我想，<strong>正 与 不正 这一说，应该是没有实质性、准确性的划分的</strong>。希特勒有自己的三观、毛主席有自己的三观，纳粹党人有他们的三观，共产党人也有他们的三观，正 与 不正，可能在普世眼里大多数人都觉得希特勒三观不正、毛主席三观正。但是，可能纳粹党人就会觉得共产党人三观不正，共产党人也觉得纳粹三观不正。（这里抛开那些残暴血腥的非人类行为而言）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-22d73419880b218f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>正 与 不正，我想应该用一个辩证的眼光来看吧。我猜，那些大哲学家、大师也没有能轻易地说谁谁谁的三观不正吧，因为这个东西要是<strong>以严肃、哲学的眼光和角度来看待</strong>，那就不是轻易能够评判得清楚的了。我们在这是信息云集的时代，语言、含义、表象都不同于往日，我们要有甄别是非真假的能力，是非常重要的。</p>\n<p>这里的<strong>甄别是非真假，并不仅仅指的是甄别网络上的骗局、假消息、错误言论、有色舆论等等，而更多的指的是我们能够”与时俱进“地更新自己对于这个时代的认识</strong>，<strong>更具体一点说就是，我们要在语言文学方面不落后，在发展的潮流中不随波逐流，在人云亦云的社会中要保持自己的本真，最好是能够出淤泥而不染濯青莲而不妖</strong>。不能觉得现在好像大大小小的人物都在玩出轨什么的，你也觉得出轨好像已经变成可以被理解和认同的事情，要有坚定的意识和正确的三观，这样才能让你保持清醒的意识，不陷入社会淤泥的漩涡。</p>\n<p>谈了这么多是是而非的话，好像也没多大用，多半都是说给我自己听，让我理清思路用的，你们就看过且过吧。不过，我也开始思考和整理自己的三观，让自己也能够在别人询问你”你的三观是什么“的时候不至于慌了阵脚。</p>\n<ul>\n<li><p>世界观：<br><strong>就我个人而言，我觉得这个世界还是一个美好的世界，有很多美好的东西值得我们去领略争取，在某些方面是相对公平的，得到与得不到就是努力与不努力的最公平印证。</strong></p>\n</li>\n<li><p>人生观:<br><strong>我认为，人活一辈子，不应该白活，应该通过自己的能力去推动整个人类社会的走向美好的发展，学会去创造，而不是摧毁。在自己有限的生命里，应该去做一些有意义的事情来体现自身应有的价值。</strong></p>\n</li>\n<li><p>价值观:<br><strong>我认为，所有美好的事物都值得我们通过自己的努力去追求获得，每个人都有获得的权利。每个人都有存在和体现的价值，物质的价值和精神的价值是不可比拟的，对于我个人而言，我更多是在追求精神层面的价值，也希望能够体现自身对于人类社会的价值。</strong></p>\n</li>\n</ul>\n<p>以上也就算是我<strong>此时此人生阶段的三观</strong>。不和别人比，也肯定和别人不同，我只需要恪守自己的三观就好。</p>\n<p>谢谢观阅。</p>\n<p>ps:希望来此评论的人，都整理一下自己的三观，让大家看一看。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-af2e20094e1a0ac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我觉得在现在这个网络时代，这个信息充斥的时代，甄别是非真假的能力是需要的，不能随意听之便信之。别人说什么，不能轻易相信。就拿“毁三观”、“三观不正”来说吧。</p>\n<p>现在说的“三观”在网上流行之后，变了味道。好像已经不是指的以前的三观：<strong>爱情观、价值观、人生观</strong>了。好像已经变成了，<strong>你处事的态度、对事情的看法、对某些现象的理解、做事情的方式等等</strong>。有时候有人说你“三观不正”，可能并不是那么严肃，并不是指的你的人生观、价值观、世界观有问题，而是指的你的某些看法、方式、做法、态度有问题。这种现象出现呢，并不是没有原因的，就像这个时代，网络时代追求的是<strong>新鲜、新奇、新颖</strong>，如果没有<strong>“创新”</strong>那么就会淘汰。</p>\n<p>比如，现在很多宣传广告等，会把某些成语进行篡改。类似：其（骑）乐无穷 、食全食美（十全十美 ）、“咳”不容缓(止咳药广告) 刻不容缓等等。这样就算是推陈出新了，看起来真是“两全其美”啊。</p>\n<p>但是我个人觉得，这样东西的出现是无可避免的，我们也没有办法阻止，但是，从自身出发，如果我们<strong>拥有甄别是非真假的能力</strong>，辨别哪些东西是别出了心样，哪些东西还是原来的意思，我们就能更好的掌握和保持时代前进一致的步伐。</p>\n<p>就像，我跟我女朋友吵架。不是因为别的，就是因为我个人对“三观不正”的理解没有跟很多网络人士一样”与时俱进“，虽然我本来是个做互联网的人，但是，我对于三观这个严肃的东西还是<strong>保持着应有的尊敬和不懈怠的态度</strong>。所以，我认为她说我”三观不正“就是指的我的<strong>人生观、价值观、世界观</strong>有问题了。所以，我就有点不开心了。可能我有些言重了。我说：”每个人都有每个人的底线，你说我三观不正，对于男生而言就是触及了他们的底线，就相当于是人格的侮辱，如果你骂我是傻逼 说我傻  说我幼稚 我一点都不会在意，但是这个不行。三观 算是很重要的东西了把，一个人活在世上很多都是与三观相关，<strong>如果有人告诉他他的三观不正，那么他就会开始怀疑自己，怀疑人生，怀疑这个世界</strong>。  所以，我奉劝你不要轻易说这些话。“</p>\n<p>后面看看，可能我却是太过于言重和严肃了。也可能就是我没有跟上时代的脚步，没有把”三观不正“的现在意思给理解到位吧。后来她也跟我说，她不是那个意思，而是指的我对事情的看法有问题。所以，<strong>在这里跟她道个歉</strong>，我太过于严肃，也言重了。</p>\n<p>当我和她谈及三观的之后，我就在思考，<strong>三观到底是什么</strong>。然后我就开始百度搜索，想看看大家的看法。看了百度百科，有了大致的印象，就是人生观、价值观、世界观这三大观。然后看了知乎，发现<strong>每个人对三大观又细分的理解都有点不一样</strong>。</p>\n<p>确实，如事实所表现的那样，<strong>每个人的三观都有所不同</strong>，每个人<strong>都有自己独特的三观意识</strong>，可能不是每个人都整理过思考过自己的三观，但是潜意识里和平常行为处理的过程中都若隐若现着，每个人都三观都是跟自己所处的环境、所见所闻所感有关联的，所以可能都不太一样。说实话，我也在思考我的三观，非要我说，如果在没有整理过的情况下，我也说不太清楚。</p>\n<p>所以，<strong>在对于三观这个问题的理解上，各有千秋</strong>。我想就算是真正的大师、大哲学家他们的三观也肯定是不同的，他们自己对于自己三观的理解上肯定也不同。我想，<strong>正 与 不正 这一说，应该是没有实质性、准确性的划分的</strong>。希特勒有自己的三观、毛主席有自己的三观，纳粹党人有他们的三观，共产党人也有他们的三观，正 与 不正，可能在普世眼里大多数人都觉得希特勒三观不正、毛主席三观正。但是，可能纳粹党人就会觉得共产党人三观不正，共产党人也觉得纳粹三观不正。（这里抛开那些残暴血腥的非人类行为而言）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-22d73419880b218f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>正 与 不正，我想应该用一个辩证的眼光来看吧。我猜，那些大哲学家、大师也没有能轻易地说谁谁谁的三观不正吧，因为这个东西要是<strong>以严肃、哲学的眼光和角度来看待</strong>，那就不是轻易能够评判得清楚的了。我们在这是信息云集的时代，语言、含义、表象都不同于往日，我们要有甄别是非真假的能力，是非常重要的。</p>\n<p>这里的<strong>甄别是非真假，并不仅仅指的是甄别网络上的骗局、假消息、错误言论、有色舆论等等，而更多的指的是我们能够”与时俱进“地更新自己对于这个时代的认识</strong>，<strong>更具体一点说就是，我们要在语言文学方面不落后，在发展的潮流中不随波逐流，在人云亦云的社会中要保持自己的本真，最好是能够出淤泥而不染濯青莲而不妖</strong>。不能觉得现在好像大大小小的人物都在玩出轨什么的，你也觉得出轨好像已经变成可以被理解和认同的事情，要有坚定的意识和正确的三观，这样才能让你保持清醒的意识，不陷入社会淤泥的漩涡。</p>\n<p>谈了这么多是是而非的话，好像也没多大用，多半都是说给我自己听，让我理清思路用的，你们就看过且过吧。不过，我也开始思考和整理自己的三观，让自己也能够在别人询问你”你的三观是什么“的时候不至于慌了阵脚。</p>\n<ul>\n<li><p>世界观：<br><strong>就我个人而言，我觉得这个世界还是一个美好的世界，有很多美好的东西值得我们去领略争取，在某些方面是相对公平的，得到与得不到就是努力与不努力的最公平印证。</strong></p>\n</li>\n<li><p>人生观:<br><strong>我认为，人活一辈子，不应该白活，应该通过自己的能力去推动整个人类社会的走向美好的发展，学会去创造，而不是摧毁。在自己有限的生命里，应该去做一些有意义的事情来体现自身应有的价值。</strong></p>\n</li>\n<li><p>价值观:<br><strong>我认为，所有美好的事物都值得我们通过自己的努力去追求获得，每个人都有获得的权利。每个人都有存在和体现的价值，物质的价值和精神的价值是不可比拟的，对于我个人而言，我更多是在追求精神层面的价值，也希望能够体现自身对于人类社会的价值。</strong></p>\n</li>\n</ul>\n<p>以上也就算是我<strong>此时此人生阶段的三观</strong>。不和别人比，也肯定和别人不同，我只需要恪守自己的三观就好。</p>\n<p>谢谢观阅。</p>\n<p>ps:希望来此评论的人，都整理一下自己的三观，让大家看一看。</p>\n"},{"layout":"android","title":"解决NestedScrollView包裹横向RecyclerView导致behavior回调方法没有执行及源码分析","date":"2018-01-21T04:33:43.000Z","_content":"### 前言\n如题，现在有一种behavior的使用场景：NestedScrollView下面包裹横向的RecyclerView，behavior的滚动回调方法不执行。详细可见[demo](https://github.com/fly7632785/BehaviorScrolltest),  建议最好clone下来自己试一试，因为你总有一天会用到behavior！\n看看问题\n![滚动下面bottomView没有跟着动](http://upload-images.jianshu.io/upload_images/1311457-7f39e4338cd244cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 先来看看demo的布局层级\n￼![main_activity](http://upload-images.jianshu.io/upload_images/1311457-0af6bbe2a89e7c5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nCoordinatorLayout包含两个子View: Viewpager和View(注入behavior关联滚动的view)\n- 再看看viewpager_item\n![viewpager_item](http://upload-images.jianshu.io/upload_images/1311457-3ee1618cb7a76f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n里面是一层NestedScrollView，里面包含几个子Linear, Linear里面包裹横向的RecyclerView\n- 最终层级图\n\n![效果希望滚动里面的nestedscrollView然后显示和隐藏bottomView](http://upload-images.jianshu.io/upload_images/1311457-cd62403cdca36fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个层级还是简化后的demo的，实际开发中我们遇到的情况比这个更加复杂，但是就算层级再多再复杂，只要符合behavior的使用规则，那么一切皆可以实现。\n- 再看看behavior\n```\npublic class MyBehavior extends CoordinatorLayout.Behavior<View> {\n    private boolean isHide = false;\n    public MyBehavior(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type) {\n        return true;\n    }\n\n    @Override\n    public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type) {\n        Log.e(\"test\", \"onNS\");\n        if(dyConsumed >0 ) {\n            if (!isHide) {\n                child.offsetTopAndBottom(child.getHeight());\n                isHide = true;\n            }\n        }else {\n            if(isHide){\n                child.offsetTopAndBottom(-child.getHeight());\n                isHide = false;\n            }\n        }\n    }\n}\n```\n也超级简单就是判断一下滚动方向，然后显示和隐藏bottomView而已。\n### 但是\n我们这样简单的代码却有着问题，我们实际运行发现，貌似滚动的关联“不太灵敏”，打log发现，有时候onNestedScroll方法不会调用。这是为什么呢？\n### 问题\n于是提出两个问题：\n**1、为什么onNestedScroll方法不会调用？\n2、为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？**\n\n另外后面会进行更深层次的源码分析，附加几个问题：\n**1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\n2、判断子View是否能够接收事件从哪里体现？\n3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？\n4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？\n5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？**\n\n### 正题\n######  首先我们解决第一个问题，**“为什么onNestedScroll没有调用？”**\n这需要大家对behavior有一定的了解，我们都知道coordinatorLayout和behavior联合使用可以实现许多花哨的效果，很牛逼。\n\nbehavior的工作原理就是:\n1、coordinatorLayout下面的所有子view(包含子孙view),实现了滚动接口(包括NestedScrollingChild、NestedScrollingParent等等)的view, 如果有滑动事件的消耗，就会一层一层向上传递，直到coordinatorLayout\n2、然后coordinatorLayout再对注入了behavior的子View传递滚动回调事件，这样，behavior就能拿到滚动的值，进而进行对View的一些关联滚动操作\n如果用最通俗的例子来讲就是：\n父亲是CoordinatorLayout，它有两个儿子，一个是NestedScrollView，一个是BottomView，behavior绑在BottomView身上（父亲比较偏爱他）。NestedScrollView发年终奖了（滚动了），发了红包给父亲（通知给了父亲），然后父亲又把钱分给了喜爱的儿子BottomView（父亲又通知了BottomView）\n贴点重要代码\nrecycler->linear->nestedScroll->coordinator:\n![传递过程，其他非滚动view“透明”](http://upload-images.jianshu.io/upload_images/1311457-8a6da7866ef19d91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![异常中返回false](http://upload-images.jianshu.io/upload_images/1311457-7890bfac9e10c40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n为什么onNestedScroll没有回调呢？\n***PS: 这里的源码是对应26的，support是26.1***\n通过在代码里面打断点发现：\n- ![RecyclerView中自己消费了consumedY](http://upload-images.jianshu.io/upload_images/1311457-32e7ccd4255cc480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nRecyclerView中自己消费了consumedY，uncomsumed = y - consumeY = 0 ，然后\n![NestedScrollView中拿到的dyUnConsumed为0](http://upload-images.jianshu.io/upload_images/1311457-8b373d479b685fd3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nNestedScrollView中拿到的dyUnConsumed为0，调用dispatchNestedScroll方法也就传入0\n![NestedScrollingChildHelper中if分支进不去](http://upload-images.jianshu.io/upload_images/1311457-b1f5a63b62fd33e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这样的话，NestedScrollingChildHelper中if分支进不去，就没法向上层传递消费的y值（相当于它并没有滚动），ViewParentCompat.onNestedScroll没法调用，所以没能传递到顶层的CoordinatorLayout，自然behavior里面也不会收到回调了。\n\n从源码上来看是这样的，如果从宏观上来讲，其实就是RecyclerView和NestedScrollView的事件处理有冲突，RecyclerView消费了事件，从而NestedScrollView没能把自己消费的事件往上传递。\n按道理，我们都知道，如果竖向的RecyclerView和NestedScrollView或者ScrollView联合使用的话（虽然，这样联合使用没有意义，也不建议这样做），会出现事件冲突。但是，横向的RecyclerView和NestedScrollView一起使用，在事件处理上面是没有问题的，没有冲突，但是，在使用到behavior，希望nestedScrollView能够把自己滚动消费的事件往上传递的时候就会出问题了。\n（我们都希望behavior的使用是在没有嵌套滚动冲突的情况下，兄弟滚动，然后父亲知道，父亲通知另外一个兄弟做出相应的行为，而如果是子孙滚动，往上传给父亲，这期间出了问题，就没法正常工作了）\n\n###### 接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？”\n看看效果\n![OK,可能转gif帧率不够有点卡](http://upload-images.jianshu.io/upload_images/1311457-9ffc92ff78aa70cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第二个问题就需要大家对于事件分发机制有一定的了解，这里就大致贴张图。\n![事件分发机制](http://upload-images.jianshu.io/upload_images/1311457-e3d5fe3ad2c86848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n另外，贴几个认为比较不错的链接：\n1、[图解 Android 事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)\n2、[Android事件分发机制详解：史上最全面、最易懂](http://www.jianshu.com/p/38015afcdb58)\n3、[Android6.0源码解读之View点击事件分发机制](http://blog.csdn.net/mynameishuangshuai/article/details/52912641)\n4、[Android 事件分发机制-试着读懂每一行源码-View](http://www.jianshu.com/p/383bae6b6487)\n5、[ScrollView与头+RecycleView嵌套冲突源码分析](http://www.jianshu.com/p/7e17e48e6baf)\n\n我们看看setNestedScrollingEnabled\n```\n// RecyclerView\n   @Override\n    public void setNestedScrollingEnabled(boolean enabled) {\n        getScrollingChildHelper().setNestedScrollingEnabled(enabled);\n    }\n```\n调用了辅助类\n```\n// NestedScrollingChildHelper\n   public void setNestedScrollingEnabled(boolean enabled) {\n        if (mIsNestedScrollingEnabled) {\n            ViewCompat.stopNestedScroll(mView);\n        }\n        mIsNestedScrollingEnabled = enabled;\n    }\n```\n辅助类设置mIsNestedScrollingEnabled为false，并且调用了 ViewCompat.stopNestedScroll(mView);传入了自己\n```\n// NestedScrollingChildHelper\n public boolean isNestedScrollingEnabled() {\n        return mIsNestedScrollingEnabled;\n    }\n```\n这样isNestedScrollingEnabled返回false了，以后behavior的回调方法里面的if(isNestedScrollingEnabled())就进不去了\n接着：\n```\n//ViewCompat\n public static void stopNestedScroll(@NonNull View view) {\n        IMPL.stopNestedScroll(view);\n    }\n```\n这里，ViewCompat就是一个兼容类，兼容各个版本api的使用，因为有一些新版本的api，实现的是NestedScrollingParent2等方法。\n```\n//ViewCompat\n public void stopNestedScroll(View view) {\n            if (view instanceof NestedScrollingChild) {\n                ((NestedScrollingChild) view).stopNestedScroll();\n            }\n        }\n```\n这里是相当于调用view的stopNestedScroll，也就是RecyclerView的。\n```\n//RecyclerView\n  @Override\n    public void stopNestedScroll() {\n        getScrollingChildHelper().stopNestedScroll();\n    }\n```\n```\n//NestedScrollingChildHelper\n   public void stopNestedScroll() {\n        stopNestedScroll(TYPE_TOUCH);\n    }\n```\n```\n//NestedScrollingChildHelper\n public void stopNestedScroll(@NestedScrollType int type) {\n        ViewParent parent = getNestedScrollingParentForType(type);\n        if (parent != null) {\n            ViewParentCompat.onStopNestedScroll(parent, mView, type);\n            setNestedScrollingParentForType(type, null);\n        }\n    }\n```\n这里就比较重要了，这里通过getNestedScrollingParenForType获得了parent，然后调用了ViewParentCompat.onStopNestedScroll(parent, mView, type);\n```\n//viewParentCompat\n  public static void onStopNestedScroll(ViewParent parent, View target, int type) {\n        if (parent instanceof NestedScrollingParent2) {\n            // First try the NestedScrollingParent2 API\n            ((NestedScrollingParent2) parent).onStopNestedScroll(target, type);\n        } else if (type == ViewCompat.TYPE_TOUCH) {\n            // Else if the type is the default (touch), try the NestedScrollingParent API\n            IMPL.onStopNestedScroll(parent, target);\n        }\n    }\n```\n这个方法会又调用IMPL.onStopNestedScroll(parent, target);这样类似的方法其实就是把事件一层一层往上传，当然，其他onPreNestedScroll、onNestedScroll这些也都是这样的。\n```\n//NestesScrollView\n  @Override\n    public void onStopNestedScroll(View target) {\n        mParentHelper.onStopNestedScroll(target);\n        stopNestedScroll();\n    }\n```\n我们又看NestedScrollView里面的onStopNestedScroll\n```stopNestedScroll();```是继续往上调用传递\n``` mParentHelper.onStopNestedScroll(target);```就比较关键了\n```\n//NestedScrollingParentHelper\n  public void onStopNestedScroll(@NonNull View target) {\n        onStopNestedScroll(target, ViewCompat.TYPE_TOUCH);\n    }\n```\n```\n public void onStopNestedScroll(@NonNull View target, @NestedScrollType int type) {\n        mNestedScrollAxes = 0;\n    }\n```\n这个就关键了，mNestedScrollAxes = 0\n```  public int getNestedScrollAxes() {\n        return mNestedScrollAxes;\n    }\n```\n这个方法返回0了，看看它在哪被调用\n```\n//NestedScrollVIew#onIntercept#move\n    final int yDiff = Math.abs(y - mLastMotionY);\n                if (yDiff > mTouchSlop\n                        && (getNestedScrollAxes() & ViewCompat.SCROLL_AXIS_VERTICAL) == 0) {\n                    mIsBeingDragged = true;\n                    mLastMotionY = y;\n                    initVelocityTrackerIfNotExists();\n                    mVelocityTracker.addMovement(ev);\n                    mNestedYOffset = 0;\n                    final ViewParent parent = getParent();\n                    if (parent != null) {\n                        parent.requestDisallowInterceptTouchEvent(true);\n                    }\n                }\n                break;\n```\n在move的时候，它返回为0，那么走入分支的话，mIsBeingDragged =true\nonInterceptTouchEvent就返回true, 就会拦截了。\n这就说明，在move的时候，nestedScrollView就完全拦截了事件，里面的子孙view（包括横向的RecyclerView就不会有事件了，更不用谈什么它自己消费掉了consumeY，NestedScrollView自己全权处理了），这样的话它自己的滚动事件就能够再往上一直传递到coordinatorLayout，然后behavior也就肯定能够执行回到方法了！\n啊，原来如此，恍然大悟！\n\n### 5个小问题\n前面两个大问题终于解决了，下面来搞清楚后面提的那5个小问题。\n**1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\n2、判断子View是否能够接收事件从哪里体现？\n3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？\n4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？\n5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？**\n这几个问题全是关于事件分发的，大家可以把那几个链接的文章都看了，如果还不能解决，那么再往下看。\n\n```\n//ViewGroup#dispatchTouchEvent  代码有省略\n @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n      boolean handled = false;\n            // Handle an initial down.\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n    ##### 重点\n              // 这里mFirstTouchTarget置为null\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n            }\n\n            // Check for interception.\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n            final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n            TouchTarget newTouchTarget = null;\n            boolean alreadyDispatchedToNewTouchTarget = false;\n   ##### 重要 if分支1\n            if (!canceled && !intercepted) {\n                        final View[] children = mChildren;\n                        for (int i = childrenCount - 1; i >= 0; i--) {\n                            final int childIndex = getAndVerifyPreorderedIndex(\n                                    childrenCount, i, customOrder);\n                            final View child = getAndVerifyPreorderedView(\n                                    preorderedList, children, childIndex);\n\n                            // If there is a view that has accessibility focus we want it\n                            // to get the event first and if not handled we will perform a\n                            // normal dispatch. We may do a double iteration but this is\n                            // safer given the timeframe.\n                            if (childWithAccessibilityFocus != null) {\n                                if (childWithAccessibilityFocus != child) {\n                                    continue;\n                                }\n                                childWithAccessibilityFocus = null;\n                                i = childrenCount - 1;\n                            }\n\n    ##### 重点\n                            if (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n\n                            resetCancelNextUpFlag(child);\n    ##### 重点\n                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                                // Child wants to receive touch within its bounds.\n                                mLastTouchDownTime = ev.getDownTime();\n                                if (preorderedList != null) {\n                                    // childIndex points into presorted list, find original index\n                                    for (int j = 0; j < childrenCount; j++) {\n                                        if (children[childIndex] == mChildren[j]) {\n                                            mLastTouchDownIndex = j;\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    mLastTouchDownIndex = childIndex;\n                                }\n                                mLastTouchDownX = ev.getX();\n                                mLastTouchDownY = ev.getY();\n    ##### 重点\n                                newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                                alreadyDispatchedToNewTouchTarget = true;\n                                break;\n                            }\n\n                            // The accessibility focus didn't handle the event, so clear\n                            // the flag and do a normal dispatch to all children.\n                            ev.setTargetAccessibilityFocus(false);\n                        }\n                        if (preorderedList != null) preorderedList.clear();\n                    }\n            }\n\n            // Dispatch to touch targets.\n   ##### 重要 if分支2\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n                // Dispatch to touch targets, excluding the new touch target if we already\n                // dispatched to it.  Cancel touch targets if necessary.\n                TouchTarget predecessor = null;\n                TouchTarget target = mFirstTouchTarget;\n                while (target != null) {\n                    final TouchTarget next = target.next;\n                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n                        handled = true;\n                    } else {\n                        final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                                || intercepted;\n    ##### 重点\n                        if (dispatchTransformedTouchEvent(ev, cancelChild,\n                                target.child, target.pointerIdBits)) {\n                            handled = true;\n                        }\n                        if (cancelChild) {\n                            if (predecessor == null) {\n                                mFirstTouchTarget = next;\n                            } else {\n                                predecessor.next = next;\n                            }\n                            target.recycle();\n                            target = next;\n                            continue;\n                        }\n                    }\n                    predecessor = target;\n                    target = next;\n                }\n            }\n      ...\n        return handled;\n    }\n```\n```\n//ViewGroup#dispatchTransformedTouchEvent  代码有省略\n private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n        final boolean handled;\n        final int oldAction = event.getAction();\n        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n            event.setAction(MotionEvent.ACTION_CANCEL);\n            if (child == null) {\n                handled = super.dispatchTouchEvent(event);\n            } else {\n                handled = child.dispatchTouchEvent(event);\n            }\n            event.setAction(oldAction);\n            return handled;\n        }\n\n        final MotionEvent transformedEvent;\n        if (newPointerIdBits == oldPointerIdBits) {\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n              handled = child.dispatchTouchEvent(event);\n                }\n                return handled;\n            }\n            transformedEvent = MotionEvent.obtain(event);\n        } else {\n            transformedEvent = event.split(newPointerIdBits);\n        }\n\n        // Perform any necessary transformations and dispatch.\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        } else {\n         handled = child.dispatchTouchEvent(transformedEvent);\n        }\n\n        // Done.\n        transformedEvent.recycle();\n        return handled;\n    }\n```\n#### 1 、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\n如果onIntercep返回true，那么interceped变量为true，那么不会走入【重要 if分支1】（里面分发事件，设置mFirstTouchTarget等），mFirstTouchTarget依旧为null, 于是走入【重要 if分支2】的```dispatchTransformedTouchEvent(ev, canceled, null,TouchTarget.ALL_POINTER_IDS)``` 并且传入child为null, \n在dispatchTransformedTouchEvent中如果child为null,就会走super.dispatch, super就是view，这样的话，就会走view的dispatch（view本身的dispatch会调onTouch），就会走到onTouch去了\n#### 2、判断子View是否能够接收事件从哪里体现？\n在viewgroup的dispatch中的走入if分支之后，里面有个判断\n ```\nif (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n```\n有个方法canViewReceivePointerEvents，里面主要是判断是否Visible\nisTransformedTouchPointInView主要是判断事件的位置是否在子VIew的区域内\n如果不行，就continue，后续的事件分发就不进行\n#### 3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？\ndispatchTransformedTouchEvent主要就是对于事件分发的处理，比如什么时候调用自己的super.dispatch，什么时候调用child.disaptch分发给子View, 这个判断方法的主要根据就是child是否为null, 而这个又跟mFirstTouchTarget有关联\n#### 4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？\n这个问题也跟第1个问题有点类似，如果子View的dispatch返回false，那么dispatchTransformedTouchEvent的handled就会是false返回，然后【重要 if分支1】就走不进去，addTouchTarget这个方法也不执行（主要是给mFirstTarget赋值）\n```\n  private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\n        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\n        target.next = mFirstTouchTarget;\n        mFirstTouchTarget = target;\n        return target;\n    }\n```\n前面说了，如果mFirstTarget为null, 【重要 if分支2】就会进入dispatchTransformedTouchEvent的时候传入为null的child, 这样就会调用super.dispatch，就是view的dispatch，然后就调用了onTouch咯\n\n#### viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？\n如果看到这，希望第5个问题我已经不用解释了，因为前面4个问题已经把它囊括在内了。\n\n### 最后\n为了解决这个问题，最近一直在源码的黑洞里遨游，打了N个断点来回跳，梳理逻辑。最后一句，最终想要深刻地理解事件分发机制、behavior机制这些玩意儿，RTFSC。\n","source":"_posts/解决NestedScrollView包裹横向RecyclerView导致behavior回调方法没有执行及源码分析.md","raw":"layout: android\ntitle: 解决NestedScrollView包裹横向RecyclerView导致behavior回调方法没有执行及源码分析\ndate: 2018-01-21 12:33:43\ntags:\n---\n### 前言\n如题，现在有一种behavior的使用场景：NestedScrollView下面包裹横向的RecyclerView，behavior的滚动回调方法不执行。详细可见[demo](https://github.com/fly7632785/BehaviorScrolltest),  建议最好clone下来自己试一试，因为你总有一天会用到behavior！\n看看问题\n![滚动下面bottomView没有跟着动](http://upload-images.jianshu.io/upload_images/1311457-7f39e4338cd244cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 先来看看demo的布局层级\n￼![main_activity](http://upload-images.jianshu.io/upload_images/1311457-0af6bbe2a89e7c5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nCoordinatorLayout包含两个子View: Viewpager和View(注入behavior关联滚动的view)\n- 再看看viewpager_item\n![viewpager_item](http://upload-images.jianshu.io/upload_images/1311457-3ee1618cb7a76f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n里面是一层NestedScrollView，里面包含几个子Linear, Linear里面包裹横向的RecyclerView\n- 最终层级图\n\n![效果希望滚动里面的nestedscrollView然后显示和隐藏bottomView](http://upload-images.jianshu.io/upload_images/1311457-cd62403cdca36fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个层级还是简化后的demo的，实际开发中我们遇到的情况比这个更加复杂，但是就算层级再多再复杂，只要符合behavior的使用规则，那么一切皆可以实现。\n- 再看看behavior\n```\npublic class MyBehavior extends CoordinatorLayout.Behavior<View> {\n    private boolean isHide = false;\n    public MyBehavior(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type) {\n        return true;\n    }\n\n    @Override\n    public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type) {\n        Log.e(\"test\", \"onNS\");\n        if(dyConsumed >0 ) {\n            if (!isHide) {\n                child.offsetTopAndBottom(child.getHeight());\n                isHide = true;\n            }\n        }else {\n            if(isHide){\n                child.offsetTopAndBottom(-child.getHeight());\n                isHide = false;\n            }\n        }\n    }\n}\n```\n也超级简单就是判断一下滚动方向，然后显示和隐藏bottomView而已。\n### 但是\n我们这样简单的代码却有着问题，我们实际运行发现，貌似滚动的关联“不太灵敏”，打log发现，有时候onNestedScroll方法不会调用。这是为什么呢？\n### 问题\n于是提出两个问题：\n**1、为什么onNestedScroll方法不会调用？\n2、为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？**\n\n另外后面会进行更深层次的源码分析，附加几个问题：\n**1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\n2、判断子View是否能够接收事件从哪里体现？\n3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？\n4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？\n5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？**\n\n### 正题\n######  首先我们解决第一个问题，**“为什么onNestedScroll没有调用？”**\n这需要大家对behavior有一定的了解，我们都知道coordinatorLayout和behavior联合使用可以实现许多花哨的效果，很牛逼。\n\nbehavior的工作原理就是:\n1、coordinatorLayout下面的所有子view(包含子孙view),实现了滚动接口(包括NestedScrollingChild、NestedScrollingParent等等)的view, 如果有滑动事件的消耗，就会一层一层向上传递，直到coordinatorLayout\n2、然后coordinatorLayout再对注入了behavior的子View传递滚动回调事件，这样，behavior就能拿到滚动的值，进而进行对View的一些关联滚动操作\n如果用最通俗的例子来讲就是：\n父亲是CoordinatorLayout，它有两个儿子，一个是NestedScrollView，一个是BottomView，behavior绑在BottomView身上（父亲比较偏爱他）。NestedScrollView发年终奖了（滚动了），发了红包给父亲（通知给了父亲），然后父亲又把钱分给了喜爱的儿子BottomView（父亲又通知了BottomView）\n贴点重要代码\nrecycler->linear->nestedScroll->coordinator:\n![传递过程，其他非滚动view“透明”](http://upload-images.jianshu.io/upload_images/1311457-8a6da7866ef19d91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![异常中返回false](http://upload-images.jianshu.io/upload_images/1311457-7890bfac9e10c40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n为什么onNestedScroll没有回调呢？\n***PS: 这里的源码是对应26的，support是26.1***\n通过在代码里面打断点发现：\n- ![RecyclerView中自己消费了consumedY](http://upload-images.jianshu.io/upload_images/1311457-32e7ccd4255cc480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nRecyclerView中自己消费了consumedY，uncomsumed = y - consumeY = 0 ，然后\n![NestedScrollView中拿到的dyUnConsumed为0](http://upload-images.jianshu.io/upload_images/1311457-8b373d479b685fd3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nNestedScrollView中拿到的dyUnConsumed为0，调用dispatchNestedScroll方法也就传入0\n![NestedScrollingChildHelper中if分支进不去](http://upload-images.jianshu.io/upload_images/1311457-b1f5a63b62fd33e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这样的话，NestedScrollingChildHelper中if分支进不去，就没法向上层传递消费的y值（相当于它并没有滚动），ViewParentCompat.onNestedScroll没法调用，所以没能传递到顶层的CoordinatorLayout，自然behavior里面也不会收到回调了。\n\n从源码上来看是这样的，如果从宏观上来讲，其实就是RecyclerView和NestedScrollView的事件处理有冲突，RecyclerView消费了事件，从而NestedScrollView没能把自己消费的事件往上传递。\n按道理，我们都知道，如果竖向的RecyclerView和NestedScrollView或者ScrollView联合使用的话（虽然，这样联合使用没有意义，也不建议这样做），会出现事件冲突。但是，横向的RecyclerView和NestedScrollView一起使用，在事件处理上面是没有问题的，没有冲突，但是，在使用到behavior，希望nestedScrollView能够把自己滚动消费的事件往上传递的时候就会出问题了。\n（我们都希望behavior的使用是在没有嵌套滚动冲突的情况下，兄弟滚动，然后父亲知道，父亲通知另外一个兄弟做出相应的行为，而如果是子孙滚动，往上传给父亲，这期间出了问题，就没法正常工作了）\n\n###### 接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？”\n看看效果\n![OK,可能转gif帧率不够有点卡](http://upload-images.jianshu.io/upload_images/1311457-9ffc92ff78aa70cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第二个问题就需要大家对于事件分发机制有一定的了解，这里就大致贴张图。\n![事件分发机制](http://upload-images.jianshu.io/upload_images/1311457-e3d5fe3ad2c86848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n另外，贴几个认为比较不错的链接：\n1、[图解 Android 事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)\n2、[Android事件分发机制详解：史上最全面、最易懂](http://www.jianshu.com/p/38015afcdb58)\n3、[Android6.0源码解读之View点击事件分发机制](http://blog.csdn.net/mynameishuangshuai/article/details/52912641)\n4、[Android 事件分发机制-试着读懂每一行源码-View](http://www.jianshu.com/p/383bae6b6487)\n5、[ScrollView与头+RecycleView嵌套冲突源码分析](http://www.jianshu.com/p/7e17e48e6baf)\n\n我们看看setNestedScrollingEnabled\n```\n// RecyclerView\n   @Override\n    public void setNestedScrollingEnabled(boolean enabled) {\n        getScrollingChildHelper().setNestedScrollingEnabled(enabled);\n    }\n```\n调用了辅助类\n```\n// NestedScrollingChildHelper\n   public void setNestedScrollingEnabled(boolean enabled) {\n        if (mIsNestedScrollingEnabled) {\n            ViewCompat.stopNestedScroll(mView);\n        }\n        mIsNestedScrollingEnabled = enabled;\n    }\n```\n辅助类设置mIsNestedScrollingEnabled为false，并且调用了 ViewCompat.stopNestedScroll(mView);传入了自己\n```\n// NestedScrollingChildHelper\n public boolean isNestedScrollingEnabled() {\n        return mIsNestedScrollingEnabled;\n    }\n```\n这样isNestedScrollingEnabled返回false了，以后behavior的回调方法里面的if(isNestedScrollingEnabled())就进不去了\n接着：\n```\n//ViewCompat\n public static void stopNestedScroll(@NonNull View view) {\n        IMPL.stopNestedScroll(view);\n    }\n```\n这里，ViewCompat就是一个兼容类，兼容各个版本api的使用，因为有一些新版本的api，实现的是NestedScrollingParent2等方法。\n```\n//ViewCompat\n public void stopNestedScroll(View view) {\n            if (view instanceof NestedScrollingChild) {\n                ((NestedScrollingChild) view).stopNestedScroll();\n            }\n        }\n```\n这里是相当于调用view的stopNestedScroll，也就是RecyclerView的。\n```\n//RecyclerView\n  @Override\n    public void stopNestedScroll() {\n        getScrollingChildHelper().stopNestedScroll();\n    }\n```\n```\n//NestedScrollingChildHelper\n   public void stopNestedScroll() {\n        stopNestedScroll(TYPE_TOUCH);\n    }\n```\n```\n//NestedScrollingChildHelper\n public void stopNestedScroll(@NestedScrollType int type) {\n        ViewParent parent = getNestedScrollingParentForType(type);\n        if (parent != null) {\n            ViewParentCompat.onStopNestedScroll(parent, mView, type);\n            setNestedScrollingParentForType(type, null);\n        }\n    }\n```\n这里就比较重要了，这里通过getNestedScrollingParenForType获得了parent，然后调用了ViewParentCompat.onStopNestedScroll(parent, mView, type);\n```\n//viewParentCompat\n  public static void onStopNestedScroll(ViewParent parent, View target, int type) {\n        if (parent instanceof NestedScrollingParent2) {\n            // First try the NestedScrollingParent2 API\n            ((NestedScrollingParent2) parent).onStopNestedScroll(target, type);\n        } else if (type == ViewCompat.TYPE_TOUCH) {\n            // Else if the type is the default (touch), try the NestedScrollingParent API\n            IMPL.onStopNestedScroll(parent, target);\n        }\n    }\n```\n这个方法会又调用IMPL.onStopNestedScroll(parent, target);这样类似的方法其实就是把事件一层一层往上传，当然，其他onPreNestedScroll、onNestedScroll这些也都是这样的。\n```\n//NestesScrollView\n  @Override\n    public void onStopNestedScroll(View target) {\n        mParentHelper.onStopNestedScroll(target);\n        stopNestedScroll();\n    }\n```\n我们又看NestedScrollView里面的onStopNestedScroll\n```stopNestedScroll();```是继续往上调用传递\n``` mParentHelper.onStopNestedScroll(target);```就比较关键了\n```\n//NestedScrollingParentHelper\n  public void onStopNestedScroll(@NonNull View target) {\n        onStopNestedScroll(target, ViewCompat.TYPE_TOUCH);\n    }\n```\n```\n public void onStopNestedScroll(@NonNull View target, @NestedScrollType int type) {\n        mNestedScrollAxes = 0;\n    }\n```\n这个就关键了，mNestedScrollAxes = 0\n```  public int getNestedScrollAxes() {\n        return mNestedScrollAxes;\n    }\n```\n这个方法返回0了，看看它在哪被调用\n```\n//NestedScrollVIew#onIntercept#move\n    final int yDiff = Math.abs(y - mLastMotionY);\n                if (yDiff > mTouchSlop\n                        && (getNestedScrollAxes() & ViewCompat.SCROLL_AXIS_VERTICAL) == 0) {\n                    mIsBeingDragged = true;\n                    mLastMotionY = y;\n                    initVelocityTrackerIfNotExists();\n                    mVelocityTracker.addMovement(ev);\n                    mNestedYOffset = 0;\n                    final ViewParent parent = getParent();\n                    if (parent != null) {\n                        parent.requestDisallowInterceptTouchEvent(true);\n                    }\n                }\n                break;\n```\n在move的时候，它返回为0，那么走入分支的话，mIsBeingDragged =true\nonInterceptTouchEvent就返回true, 就会拦截了。\n这就说明，在move的时候，nestedScrollView就完全拦截了事件，里面的子孙view（包括横向的RecyclerView就不会有事件了，更不用谈什么它自己消费掉了consumeY，NestedScrollView自己全权处理了），这样的话它自己的滚动事件就能够再往上一直传递到coordinatorLayout，然后behavior也就肯定能够执行回到方法了！\n啊，原来如此，恍然大悟！\n\n### 5个小问题\n前面两个大问题终于解决了，下面来搞清楚后面提的那5个小问题。\n**1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\n2、判断子View是否能够接收事件从哪里体现？\n3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？\n4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？\n5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？**\n这几个问题全是关于事件分发的，大家可以把那几个链接的文章都看了，如果还不能解决，那么再往下看。\n\n```\n//ViewGroup#dispatchTouchEvent  代码有省略\n @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n      boolean handled = false;\n            // Handle an initial down.\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n    ##### 重点\n              // 这里mFirstTouchTarget置为null\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n            }\n\n            // Check for interception.\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n            final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n            TouchTarget newTouchTarget = null;\n            boolean alreadyDispatchedToNewTouchTarget = false;\n   ##### 重要 if分支1\n            if (!canceled && !intercepted) {\n                        final View[] children = mChildren;\n                        for (int i = childrenCount - 1; i >= 0; i--) {\n                            final int childIndex = getAndVerifyPreorderedIndex(\n                                    childrenCount, i, customOrder);\n                            final View child = getAndVerifyPreorderedView(\n                                    preorderedList, children, childIndex);\n\n                            // If there is a view that has accessibility focus we want it\n                            // to get the event first and if not handled we will perform a\n                            // normal dispatch. We may do a double iteration but this is\n                            // safer given the timeframe.\n                            if (childWithAccessibilityFocus != null) {\n                                if (childWithAccessibilityFocus != child) {\n                                    continue;\n                                }\n                                childWithAccessibilityFocus = null;\n                                i = childrenCount - 1;\n                            }\n\n    ##### 重点\n                            if (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n\n                            resetCancelNextUpFlag(child);\n    ##### 重点\n                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                                // Child wants to receive touch within its bounds.\n                                mLastTouchDownTime = ev.getDownTime();\n                                if (preorderedList != null) {\n                                    // childIndex points into presorted list, find original index\n                                    for (int j = 0; j < childrenCount; j++) {\n                                        if (children[childIndex] == mChildren[j]) {\n                                            mLastTouchDownIndex = j;\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    mLastTouchDownIndex = childIndex;\n                                }\n                                mLastTouchDownX = ev.getX();\n                                mLastTouchDownY = ev.getY();\n    ##### 重点\n                                newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                                alreadyDispatchedToNewTouchTarget = true;\n                                break;\n                            }\n\n                            // The accessibility focus didn't handle the event, so clear\n                            // the flag and do a normal dispatch to all children.\n                            ev.setTargetAccessibilityFocus(false);\n                        }\n                        if (preorderedList != null) preorderedList.clear();\n                    }\n            }\n\n            // Dispatch to touch targets.\n   ##### 重要 if分支2\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n                // Dispatch to touch targets, excluding the new touch target if we already\n                // dispatched to it.  Cancel touch targets if necessary.\n                TouchTarget predecessor = null;\n                TouchTarget target = mFirstTouchTarget;\n                while (target != null) {\n                    final TouchTarget next = target.next;\n                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n                        handled = true;\n                    } else {\n                        final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                                || intercepted;\n    ##### 重点\n                        if (dispatchTransformedTouchEvent(ev, cancelChild,\n                                target.child, target.pointerIdBits)) {\n                            handled = true;\n                        }\n                        if (cancelChild) {\n                            if (predecessor == null) {\n                                mFirstTouchTarget = next;\n                            } else {\n                                predecessor.next = next;\n                            }\n                            target.recycle();\n                            target = next;\n                            continue;\n                        }\n                    }\n                    predecessor = target;\n                    target = next;\n                }\n            }\n      ...\n        return handled;\n    }\n```\n```\n//ViewGroup#dispatchTransformedTouchEvent  代码有省略\n private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n        final boolean handled;\n        final int oldAction = event.getAction();\n        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n            event.setAction(MotionEvent.ACTION_CANCEL);\n            if (child == null) {\n                handled = super.dispatchTouchEvent(event);\n            } else {\n                handled = child.dispatchTouchEvent(event);\n            }\n            event.setAction(oldAction);\n            return handled;\n        }\n\n        final MotionEvent transformedEvent;\n        if (newPointerIdBits == oldPointerIdBits) {\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n              handled = child.dispatchTouchEvent(event);\n                }\n                return handled;\n            }\n            transformedEvent = MotionEvent.obtain(event);\n        } else {\n            transformedEvent = event.split(newPointerIdBits);\n        }\n\n        // Perform any necessary transformations and dispatch.\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        } else {\n         handled = child.dispatchTouchEvent(transformedEvent);\n        }\n\n        // Done.\n        transformedEvent.recycle();\n        return handled;\n    }\n```\n#### 1 、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\n如果onIntercep返回true，那么interceped变量为true，那么不会走入【重要 if分支1】（里面分发事件，设置mFirstTouchTarget等），mFirstTouchTarget依旧为null, 于是走入【重要 if分支2】的```dispatchTransformedTouchEvent(ev, canceled, null,TouchTarget.ALL_POINTER_IDS)``` 并且传入child为null, \n在dispatchTransformedTouchEvent中如果child为null,就会走super.dispatch, super就是view，这样的话，就会走view的dispatch（view本身的dispatch会调onTouch），就会走到onTouch去了\n#### 2、判断子View是否能够接收事件从哪里体现？\n在viewgroup的dispatch中的走入if分支之后，里面有个判断\n ```\nif (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n```\n有个方法canViewReceivePointerEvents，里面主要是判断是否Visible\nisTransformedTouchPointInView主要是判断事件的位置是否在子VIew的区域内\n如果不行，就continue，后续的事件分发就不进行\n#### 3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？\ndispatchTransformedTouchEvent主要就是对于事件分发的处理，比如什么时候调用自己的super.dispatch，什么时候调用child.disaptch分发给子View, 这个判断方法的主要根据就是child是否为null, 而这个又跟mFirstTouchTarget有关联\n#### 4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？\n这个问题也跟第1个问题有点类似，如果子View的dispatch返回false，那么dispatchTransformedTouchEvent的handled就会是false返回，然后【重要 if分支1】就走不进去，addTouchTarget这个方法也不执行（主要是给mFirstTarget赋值）\n```\n  private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\n        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\n        target.next = mFirstTouchTarget;\n        mFirstTouchTarget = target;\n        return target;\n    }\n```\n前面说了，如果mFirstTarget为null, 【重要 if分支2】就会进入dispatchTransformedTouchEvent的时候传入为null的child, 这样就会调用super.dispatch，就是view的dispatch，然后就调用了onTouch咯\n\n#### viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？\n如果看到这，希望第5个问题我已经不用解释了，因为前面4个问题已经把它囊括在内了。\n\n### 最后\n为了解决这个问题，最近一直在源码的黑洞里遨游，打了N个断点来回跳，梳理逻辑。最后一句，最终想要深刻地理解事件分发机制、behavior机制这些玩意儿，RTFSC。\n","slug":"解决NestedScrollView包裹横向RecyclerView导致behavior回调方法没有执行及源码分析","published":1,"updated":"2018-01-21T05:09:36.000Z","comments":1,"photos":[],"link":"","_id":"cjcozqjvo000p0cus729j2oh9","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>如题，现在有一种behavior的使用场景：NestedScrollView下面包裹横向的RecyclerView，behavior的滚动回调方法不执行。详细可见<a href=\"https://github.com/fly7632785/BehaviorScrolltest\" target=\"_blank\" rel=\"noopener\">demo</a>,  建议最好clone下来自己试一试，因为你总有一天会用到behavior！<br>看看问题<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-7f39e4338cd244cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"滚动下面bottomView没有跟着动\"></p>\n<ul>\n<li>先来看看demo的布局层级<br>￼<img src=\"http://upload-images.jianshu.io/upload_images/1311457-0af6bbe2a89e7c5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"main_activity\"><br>CoordinatorLayout包含两个子View: Viewpager和View(注入behavior关联滚动的view)</li>\n<li>再看看viewpager_item<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-3ee1618cb7a76f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"viewpager_item\"><br>里面是一层NestedScrollView，里面包含几个子Linear, Linear里面包裹横向的RecyclerView</li>\n<li>最终层级图</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-cd62403cdca36fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果希望滚动里面的nestedscrollView然后显示和隐藏bottomView\"><br>这个层级还是简化后的demo的，实际开发中我们遇到的情况比这个更加复杂，但是就算层级再多再复杂，只要符合behavior的使用规则，那么一切皆可以实现。</p>\n<ul>\n<li>再看看behavior<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class=\"line\">    private boolean isHide = false;</span><br><span class=\"line\">    public MyBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type) &#123;</span><br><span class=\"line\">        Log.e(&quot;test&quot;, &quot;onNS&quot;);</span><br><span class=\"line\">        if(dyConsumed &gt;0 ) &#123;</span><br><span class=\"line\">            if (!isHide) &#123;</span><br><span class=\"line\">                child.offsetTopAndBottom(child.getHeight());</span><br><span class=\"line\">                isHide = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            if(isHide)&#123;</span><br><span class=\"line\">                child.offsetTopAndBottom(-child.getHeight());</span><br><span class=\"line\">                isHide = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>也超级简单就是判断一下滚动方向，然后显示和隐藏bottomView而已。</p>\n<h3 id=\"但是\"><a href=\"#但是\" class=\"headerlink\" title=\"但是\"></a>但是</h3><p>我们这样简单的代码却有着问题，我们实际运行发现，貌似滚动的关联“不太灵敏”，打log发现，有时候onNestedScroll方法不会调用。这是为什么呢？</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>于是提出两个问题：<br><strong>1、为什么onNestedScroll方法不会调用？<br>2、为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？</strong></p>\n<p>另外后面会进行更深层次的源码分析，附加几个问题：<br><strong>1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？<br>2、判断子View是否能够接收事件从哪里体现？<br>3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？<br>4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？<br>5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？</strong></p>\n<h3 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h3><h6 id=\"首先我们解决第一个问题，“为什么onNestedScroll没有调用？”\"><a href=\"#首先我们解决第一个问题，“为什么onNestedScroll没有调用？”\" class=\"headerlink\" title=\"首先我们解决第一个问题，“为什么onNestedScroll没有调用？”\"></a>首先我们解决第一个问题，<strong>“为什么onNestedScroll没有调用？”</strong></h6><p>这需要大家对behavior有一定的了解，我们都知道coordinatorLayout和behavior联合使用可以实现许多花哨的效果，很牛逼。</p>\n<p>behavior的工作原理就是:<br>1、coordinatorLayout下面的所有子view(包含子孙view),实现了滚动接口(包括NestedScrollingChild、NestedScrollingParent等等)的view, 如果有滑动事件的消耗，就会一层一层向上传递，直到coordinatorLayout<br>2、然后coordinatorLayout再对注入了behavior的子View传递滚动回调事件，这样，behavior就能拿到滚动的值，进而进行对View的一些关联滚动操作<br>如果用最通俗的例子来讲就是：<br>父亲是CoordinatorLayout，它有两个儿子，一个是NestedScrollView，一个是BottomView，behavior绑在BottomView身上（父亲比较偏爱他）。NestedScrollView发年终奖了（滚动了），发了红包给父亲（通知给了父亲），然后父亲又把钱分给了喜爱的儿子BottomView（父亲又通知了BottomView）<br>贴点重要代码<br>recycler-&gt;linear-&gt;nestedScroll-&gt;coordinator:<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-8a6da7866ef19d91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"传递过程，其他非滚动view“透明”\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-7890bfac9e10c40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"异常中返回false\"></p>\n<p>为什么onNestedScroll没有回调呢？<br><strong><em>PS: 这里的源码是对应26的，support是26.1</em></strong><br>通过在代码里面打断点发现：</p>\n<ul>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1311457-32e7ccd4255cc480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RecyclerView中自己消费了consumedY\"></li>\n</ul>\n<p>RecyclerView中自己消费了consumedY，uncomsumed = y - consumeY = 0 ，然后<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-8b373d479b685fd3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NestedScrollView中拿到的dyUnConsumed为0\"></p>\n<p>NestedScrollView中拿到的dyUnConsumed为0，调用dispatchNestedScroll方法也就传入0<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b1f5a63b62fd33e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NestedScrollingChildHelper中if分支进不去\"><br>这样的话，NestedScrollingChildHelper中if分支进不去，就没法向上层传递消费的y值（相当于它并没有滚动），ViewParentCompat.onNestedScroll没法调用，所以没能传递到顶层的CoordinatorLayout，自然behavior里面也不会收到回调了。</p>\n<p>从源码上来看是这样的，如果从宏观上来讲，其实就是RecyclerView和NestedScrollView的事件处理有冲突，RecyclerView消费了事件，从而NestedScrollView没能把自己消费的事件往上传递。<br>按道理，我们都知道，如果竖向的RecyclerView和NestedScrollView或者ScrollView联合使用的话（虽然，这样联合使用没有意义，也不建议这样做），会出现事件冲突。但是，横向的RecyclerView和NestedScrollView一起使用，在事件处理上面是没有问题的，没有冲突，但是，在使用到behavior，希望nestedScrollView能够把自己滚动消费的事件往上传递的时候就会出问题了。<br>（我们都希望behavior的使用是在没有嵌套滚动冲突的情况下，兄弟滚动，然后父亲知道，父亲通知另外一个兄弟做出相应的行为，而如果是子孙滚动，往上传给父亲，这期间出了问题，就没法正常工作了）</p>\n<h6 id=\"接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable-false-就能够正常使用？”\"><a href=\"#接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable-false-就能够正常使用？”\" class=\"headerlink\" title=\"接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？”\"></a>接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？”</h6><p>看看效果<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9ffc92ff78aa70cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"OK,可能转gif帧率不够有点卡\"></p>\n<p>第二个问题就需要大家对于事件分发机制有一定的了解，这里就大致贴张图。<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e3d5fe3ad2c86848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"事件分发机制\"><br>另外，贴几个认为比较不错的链接：<br>1、<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\" target=\"_blank\" rel=\"noopener\">图解 Android 事件分发机制</a><br>2、<a href=\"http://www.jianshu.com/p/38015afcdb58\" target=\"_blank\" rel=\"noopener\">Android事件分发机制详解：史上最全面、最易懂</a><br>3、<a href=\"http://blog.csdn.net/mynameishuangshuai/article/details/52912641\" target=\"_blank\" rel=\"noopener\">Android6.0源码解读之View点击事件分发机制</a><br>4、<a href=\"http://www.jianshu.com/p/383bae6b6487\" target=\"_blank\" rel=\"noopener\">Android 事件分发机制-试着读懂每一行源码-View</a><br>5、<a href=\"http://www.jianshu.com/p/7e17e48e6baf\" target=\"_blank\" rel=\"noopener\">ScrollView与头+RecycleView嵌套冲突源码分析</a></p>\n<p>我们看看setNestedScrollingEnabled<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RecyclerView</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">    public void setNestedScrollingEnabled(boolean enabled) &#123;</span><br><span class=\"line\">        getScrollingChildHelper().setNestedScrollingEnabled(enabled);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了辅助类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NestedScrollingChildHelper</span><br><span class=\"line\">   public void setNestedScrollingEnabled(boolean enabled) &#123;</span><br><span class=\"line\">        if (mIsNestedScrollingEnabled) &#123;</span><br><span class=\"line\">            ViewCompat.stopNestedScroll(mView);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsNestedScrollingEnabled = enabled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>辅助类设置mIsNestedScrollingEnabled为false，并且调用了 ViewCompat.stopNestedScroll(mView);传入了自己<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NestedScrollingChildHelper</span><br><span class=\"line\"> public boolean isNestedScrollingEnabled() &#123;</span><br><span class=\"line\">        return mIsNestedScrollingEnabled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样isNestedScrollingEnabled返回false了，以后behavior的回调方法里面的if(isNestedScrollingEnabled())就进不去了<br>接着：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewCompat</span><br><span class=\"line\"> public static void stopNestedScroll(@NonNull View view) &#123;</span><br><span class=\"line\">        IMPL.stopNestedScroll(view);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里，ViewCompat就是一个兼容类，兼容各个版本api的使用，因为有一些新版本的api，实现的是NestedScrollingParent2等方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewCompat</span><br><span class=\"line\"> public void stopNestedScroll(View view) &#123;</span><br><span class=\"line\">            if (view instanceof NestedScrollingChild) &#123;</span><br><span class=\"line\">                ((NestedScrollingChild) view).stopNestedScroll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里是相当于调用view的stopNestedScroll，也就是RecyclerView的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//RecyclerView</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">    public void stopNestedScroll() &#123;</span><br><span class=\"line\">        getScrollingChildHelper().stopNestedScroll();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestedScrollingChildHelper</span><br><span class=\"line\">   public void stopNestedScroll() &#123;</span><br><span class=\"line\">        stopNestedScroll(TYPE_TOUCH);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestedScrollingChildHelper</span><br><span class=\"line\"> public void stopNestedScroll(@NestedScrollType int type) &#123;</span><br><span class=\"line\">        ViewParent parent = getNestedScrollingParentForType(type);</span><br><span class=\"line\">        if (parent != null) &#123;</span><br><span class=\"line\">            ViewParentCompat.onStopNestedScroll(parent, mView, type);</span><br><span class=\"line\">            setNestedScrollingParentForType(type, null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里就比较重要了，这里通过getNestedScrollingParenForType获得了parent，然后调用了ViewParentCompat.onStopNestedScroll(parent, mView, type);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//viewParentCompat</span><br><span class=\"line\">  public static void onStopNestedScroll(ViewParent parent, View target, int type) &#123;</span><br><span class=\"line\">        if (parent instanceof NestedScrollingParent2) &#123;</span><br><span class=\"line\">            // First try the NestedScrollingParent2 API</span><br><span class=\"line\">            ((NestedScrollingParent2) parent).onStopNestedScroll(target, type);</span><br><span class=\"line\">        &#125; else if (type == ViewCompat.TYPE_TOUCH) &#123;</span><br><span class=\"line\">            // Else if the type is the default (touch), try the NestedScrollingParent API</span><br><span class=\"line\">            IMPL.onStopNestedScroll(parent, target);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法会又调用IMPL.onStopNestedScroll(parent, target);这样类似的方法其实就是把事件一层一层往上传，当然，其他onPreNestedScroll、onNestedScroll这些也都是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestesScrollView</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">    public void onStopNestedScroll(View target) &#123;</span><br><span class=\"line\">        mParentHelper.onStopNestedScroll(target);</span><br><span class=\"line\">        stopNestedScroll();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们又看NestedScrollView里面的onStopNestedScroll<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">``` mParentHelper.onStopNestedScroll(target);```就比较关键了</span><br></pre></td></tr></table></figure></p>\n<p>//NestedScrollingParentHelper<br>  public void onStopNestedScroll(@NonNull View target) {<br>        onStopNestedScroll(target, ViewCompat.TYPE_TOUCH);<br>    }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"> public void onStopNestedScroll(@NonNull View target, @NestedScrollType int type) &#123;</span><br><span class=\"line\">        mNestedScrollAxes = 0;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个就关键了，mNestedScrollAxes = 0<br><figure class=\"highlight plain\"><figcaption><span>int getNestedScrollAxes() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    return mNestedScrollAxes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法返回0了，看看它在哪被调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestedScrollVIew#onIntercept#move</span><br><span class=\"line\">    final int yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\">                if (yDiff &gt; mTouchSlop</span><br><span class=\"line\">                        &amp;&amp; (getNestedScrollAxes() &amp; ViewCompat.SCROLL_AXIS_VERTICAL) == 0) &#123;</span><br><span class=\"line\">                    mIsBeingDragged = true;</span><br><span class=\"line\">                    mLastMotionY = y;</span><br><span class=\"line\">                    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">                    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">                    mNestedYOffset = 0;</span><br><span class=\"line\">                    final ViewParent parent = getParent();</span><br><span class=\"line\">                    if (parent != null) &#123;</span><br><span class=\"line\">                        parent.requestDisallowInterceptTouchEvent(true);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                break;</span><br></pre></td></tr></table></figure></p>\n<p>在move的时候，它返回为0，那么走入分支的话，mIsBeingDragged =true<br>onInterceptTouchEvent就返回true, 就会拦截了。<br>这就说明，在move的时候，nestedScrollView就完全拦截了事件，里面的子孙view（包括横向的RecyclerView就不会有事件了，更不用谈什么它自己消费掉了consumeY，NestedScrollView自己全权处理了），这样的话它自己的滚动事件就能够再往上一直传递到coordinatorLayout，然后behavior也就肯定能够执行回到方法了！<br>啊，原来如此，恍然大悟！</p>\n<h3 id=\"5个小问题\"><a href=\"#5个小问题\" class=\"headerlink\" title=\"5个小问题\"></a>5个小问题</h3><p>前面两个大问题终于解决了，下面来搞清楚后面提的那5个小问题。<br><strong>1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？<br>2、判断子View是否能够接收事件从哪里体现？<br>3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？<br>4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？<br>5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？</strong><br>这几个问题全是关于事件分发的，大家可以把那几个链接的文章都看了，如果还不能解决，那么再往下看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewGroup#dispatchTouchEvent  代码有省略</span><br><span class=\"line\"> @Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">      boolean handled = false;</span><br><span class=\"line\">            // Handle an initial down.</span><br><span class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">              // 这里mFirstTouchTarget置为null</span><br><span class=\"line\">                cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">                resetTouchState();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Check for interception.</span><br><span class=\"line\">            final boolean intercepted;</span><br><span class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">                    || mFirstTouchTarget != null) &#123;</span><br><span class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class=\"line\">                if (!disallowIntercept) &#123;</span><br><span class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class=\"line\">                    ev.setAction(action); // restore action in case it was changed</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    intercepted = false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                // There are no touch targets and this action is not an initial down</span><br><span class=\"line\">                // so this view group continues to intercept touches.</span><br><span class=\"line\">                intercepted = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class=\"line\">            TouchTarget newTouchTarget = null;</span><br><span class=\"line\">            boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class=\"line\">   ##### 重要 if分支1</span><br><span class=\"line\">            if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">                        final View[] children = mChildren;</span><br><span class=\"line\">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">                            final int childIndex = getAndVerifyPreorderedIndex(</span><br><span class=\"line\">                                    childrenCount, i, customOrder);</span><br><span class=\"line\">                            final View child = getAndVerifyPreorderedView(</span><br><span class=\"line\">                                    preorderedList, children, childIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">                            // If there is a view that has accessibility focus we want it</span><br><span class=\"line\">                            // to get the event first and if not handled we will perform a</span><br><span class=\"line\">                            // normal dispatch. We may do a double iteration but this is</span><br><span class=\"line\">                            // safer given the timeframe.</span><br><span class=\"line\">                            if (childWithAccessibilityFocus != null) &#123;</span><br><span class=\"line\">                                if (childWithAccessibilityFocus != child) &#123;</span><br><span class=\"line\">                                    continue;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                childWithAccessibilityFocus = null;</span><br><span class=\"line\">                                i = childrenCount - 1;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                            if (!canViewReceivePointerEvents(child)</span><br><span class=\"line\">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class=\"line\">                                ev.setTargetAccessibilityFocus(false);</span><br><span class=\"line\">                                continue;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            resetCancelNextUpFlag(child);</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">                                // Child wants to receive touch within its bounds.</span><br><span class=\"line\">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class=\"line\">                                if (preorderedList != null) &#123;</span><br><span class=\"line\">                                    // childIndex points into presorted list, find original index</span><br><span class=\"line\">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</span><br><span class=\"line\">                                        if (children[childIndex] == mChildren[j]) &#123;</span><br><span class=\"line\">                                            mLastTouchDownIndex = j;</span><br><span class=\"line\">                                            break;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125; else &#123;</span><br><span class=\"line\">                                    mLastTouchDownIndex = childIndex;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                mLastTouchDownX = ev.getX();</span><br><span class=\"line\">                                mLastTouchDownY = ev.getY();</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">                                alreadyDispatchedToNewTouchTarget = true;</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            // The accessibility focus didn&apos;t handle the event, so clear</span><br><span class=\"line\">                            // the flag and do a normal dispatch to all children.</span><br><span class=\"line\">                            ev.setTargetAccessibilityFocus(false);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (preorderedList != null) preorderedList.clear();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Dispatch to touch targets.</span><br><span class=\"line\">   ##### 重要 if分支2</span><br><span class=\"line\">            if (mFirstTouchTarget == null) &#123;</span><br><span class=\"line\">                // No touch targets so treat this as an ordinary view.</span><br><span class=\"line\">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class=\"line\">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                // Dispatch to touch targets, excluding the new touch target if we already</span><br><span class=\"line\">                // dispatched to it.  Cancel touch targets if necessary.</span><br><span class=\"line\">                TouchTarget predecessor = null;</span><br><span class=\"line\">                TouchTarget target = mFirstTouchTarget;</span><br><span class=\"line\">                while (target != null) &#123;</span><br><span class=\"line\">                    final TouchTarget next = target.next;</span><br><span class=\"line\">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class=\"line\">                        handled = true;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class=\"line\">                                || intercepted;</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class=\"line\">                                target.child, target.pointerIdBits)) &#123;</span><br><span class=\"line\">                            handled = true;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (cancelChild) &#123;</span><br><span class=\"line\">                            if (predecessor == null) &#123;</span><br><span class=\"line\">                                mFirstTouchTarget = next;</span><br><span class=\"line\">                            &#125; else &#123;</span><br><span class=\"line\">                                predecessor.next = next;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            target.recycle();</span><br><span class=\"line\">                            target = next;</span><br><span class=\"line\">                            continue;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    predecessor = target;</span><br><span class=\"line\">                    target = next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">        return handled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewGroup#dispatchTransformedTouchEvent  代码有省略</span><br><span class=\"line\"> private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class=\"line\">            View child, int desiredPointerIdBits) &#123;</span><br><span class=\"line\">        final boolean handled;</span><br><span class=\"line\">        final int oldAction = event.getAction();</span><br><span class=\"line\">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class=\"line\">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class=\"line\">            if (child == null) &#123;</span><br><span class=\"line\">                handled = super.dispatchTouchEvent(event);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            event.setAction(oldAction);</span><br><span class=\"line\">            return handled;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        final MotionEvent transformedEvent;</span><br><span class=\"line\">        if (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class=\"line\">            if (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class=\"line\">                if (child == null) &#123;</span><br><span class=\"line\">                    handled = super.dispatchTouchEvent(event);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">              handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return handled;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            transformedEvent = MotionEvent.obtain(event);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            transformedEvent = event.split(newPointerIdBits);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Perform any necessary transformations and dispatch.</span><br><span class=\"line\">        if (child == null) &#123;</span><br><span class=\"line\">            handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">         handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Done.</span><br><span class=\"line\">        transformedEvent.recycle();</span><br><span class=\"line\">        return handled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\"><a href=\"#1-、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\" class=\"headerlink\" title=\"1 、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\"></a>1 、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？</h4><p>如果onIntercep返回true，那么interceped变量为true，那么不会走入【重要 if分支1】（里面分发事件，设置mFirstTouchTarget等），mFirstTouchTarget依旧为null, 于是走入【重要 if分支2】的<figure class=\"highlight plain\"><figcaption><span>canceled, null,TouchTarget.ALL_POINTER_IDS)``` 并且传入child为null, </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在dispatchTransformedTouchEvent中如果child为null,就会走super.dispatch, super就是view，这样的话，就会走view的dispatch（view本身的dispatch会调onTouch），就会走到onTouch去了</span><br><span class=\"line\">#### 2、判断子View是否能够接收事件从哪里体现？</span><br><span class=\"line\">在viewgroup的dispatch中的走入if分支之后，里面有个判断</span><br></pre></td></tr></table></figure></p>\n<p>if (!canViewReceivePointerEvents(child)<br>                                    || !isTransformedTouchPointInView(x, y, child, null)) {<br>                                ev.setTargetAccessibilityFocus(false);<br>                                continue;<br>                            }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有个方法canViewReceivePointerEvents，里面主要是判断是否Visible</span><br><span class=\"line\">isTransformedTouchPointInView主要是判断事件的位置是否在子VIew的区域内</span><br><span class=\"line\">如果不行，就continue，后续的事件分发就不进行</span><br><span class=\"line\">#### 3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？</span><br><span class=\"line\">dispatchTransformedTouchEvent主要就是对于事件分发的处理，比如什么时候调用自己的super.dispatch，什么时候调用child.disaptch分发给子View, 这个判断方法的主要根据就是child是否为null, 而这个又跟mFirstTouchTarget有关联</span><br><span class=\"line\">#### 4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？</span><br><span class=\"line\">这个问题也跟第1个问题有点类似，如果子View的dispatch返回false，那么dispatchTransformedTouchEvent的handled就会是false返回，然后【重要 if分支1】就走不进去，addTouchTarget这个方法也不执行（主要是给mFirstTarget赋值）</span><br></pre></td></tr></table></figure></p>\n<p>  private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {<br>        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);<br>        target.next = mFirstTouchTarget;<br>        mFirstTouchTarget = target;<br>        return target;<br>    }<br>```<br>前面说了，如果mFirstTarget为null, 【重要 if分支2】就会进入dispatchTransformedTouchEvent的时候传入为null的child, 这样就会调用super.dispatch，就是view的dispatch，然后就调用了onTouch咯</p>\n<h4 id=\"viewGroup重写了dispatch但是没有调用super-那么它在哪里调用自己的onTouch的呢？\"><a href=\"#viewGroup重写了dispatch但是没有调用super-那么它在哪里调用自己的onTouch的呢？\" class=\"headerlink\" title=\"viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？\"></a>viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？</h4><p>如果看到这，希望第5个问题我已经不用解释了，因为前面4个问题已经把它囊括在内了。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>为了解决这个问题，最近一直在源码的黑洞里遨游，打了N个断点来回跳，梳理逻辑。最后一句，最终想要深刻地理解事件分发机制、behavior机制这些玩意儿，RTFSC。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>如题，现在有一种behavior的使用场景：NestedScrollView下面包裹横向的RecyclerView，behavior的滚动回调方法不执行。详细可见<a href=\"https://github.com/fly7632785/BehaviorScrolltest\" target=\"_blank\" rel=\"noopener\">demo</a>,  建议最好clone下来自己试一试，因为你总有一天会用到behavior！<br>看看问题<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-7f39e4338cd244cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"滚动下面bottomView没有跟着动\"></p>\n<ul>\n<li>先来看看demo的布局层级<br>￼<img src=\"http://upload-images.jianshu.io/upload_images/1311457-0af6bbe2a89e7c5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"main_activity\"><br>CoordinatorLayout包含两个子View: Viewpager和View(注入behavior关联滚动的view)</li>\n<li>再看看viewpager_item<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-3ee1618cb7a76f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"viewpager_item\"><br>里面是一层NestedScrollView，里面包含几个子Linear, Linear里面包裹横向的RecyclerView</li>\n<li>最终层级图</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1311457-cd62403cdca36fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果希望滚动里面的nestedscrollView然后显示和隐藏bottomView\"><br>这个层级还是简化后的demo的，实际开发中我们遇到的情况比这个更加复杂，但是就算层级再多再复杂，只要符合behavior的使用规则，那么一切皆可以实现。</p>\n<ul>\n<li>再看看behavior<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class=\"line\">    private boolean isHide = false;</span><br><span class=\"line\">    public MyBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type) &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type) &#123;</span><br><span class=\"line\">        Log.e(&quot;test&quot;, &quot;onNS&quot;);</span><br><span class=\"line\">        if(dyConsumed &gt;0 ) &#123;</span><br><span class=\"line\">            if (!isHide) &#123;</span><br><span class=\"line\">                child.offsetTopAndBottom(child.getHeight());</span><br><span class=\"line\">                isHide = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            if(isHide)&#123;</span><br><span class=\"line\">                child.offsetTopAndBottom(-child.getHeight());</span><br><span class=\"line\">                isHide = false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>也超级简单就是判断一下滚动方向，然后显示和隐藏bottomView而已。</p>\n<h3 id=\"但是\"><a href=\"#但是\" class=\"headerlink\" title=\"但是\"></a>但是</h3><p>我们这样简单的代码却有着问题，我们实际运行发现，貌似滚动的关联“不太灵敏”，打log发现，有时候onNestedScroll方法不会调用。这是为什么呢？</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>于是提出两个问题：<br><strong>1、为什么onNestedScroll方法不会调用？<br>2、为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？</strong></p>\n<p>另外后面会进行更深层次的源码分析，附加几个问题：<br><strong>1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？<br>2、判断子View是否能够接收事件从哪里体现？<br>3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？<br>4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？<br>5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？</strong></p>\n<h3 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h3><h6 id=\"首先我们解决第一个问题，“为什么onNestedScroll没有调用？”\"><a href=\"#首先我们解决第一个问题，“为什么onNestedScroll没有调用？”\" class=\"headerlink\" title=\"首先我们解决第一个问题，“为什么onNestedScroll没有调用？”\"></a>首先我们解决第一个问题，<strong>“为什么onNestedScroll没有调用？”</strong></h6><p>这需要大家对behavior有一定的了解，我们都知道coordinatorLayout和behavior联合使用可以实现许多花哨的效果，很牛逼。</p>\n<p>behavior的工作原理就是:<br>1、coordinatorLayout下面的所有子view(包含子孙view),实现了滚动接口(包括NestedScrollingChild、NestedScrollingParent等等)的view, 如果有滑动事件的消耗，就会一层一层向上传递，直到coordinatorLayout<br>2、然后coordinatorLayout再对注入了behavior的子View传递滚动回调事件，这样，behavior就能拿到滚动的值，进而进行对View的一些关联滚动操作<br>如果用最通俗的例子来讲就是：<br>父亲是CoordinatorLayout，它有两个儿子，一个是NestedScrollView，一个是BottomView，behavior绑在BottomView身上（父亲比较偏爱他）。NestedScrollView发年终奖了（滚动了），发了红包给父亲（通知给了父亲），然后父亲又把钱分给了喜爱的儿子BottomView（父亲又通知了BottomView）<br>贴点重要代码<br>recycler-&gt;linear-&gt;nestedScroll-&gt;coordinator:<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-8a6da7866ef19d91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"传递过程，其他非滚动view“透明”\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-7890bfac9e10c40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"异常中返回false\"></p>\n<p>为什么onNestedScroll没有回调呢？<br><strong><em>PS: 这里的源码是对应26的，support是26.1</em></strong><br>通过在代码里面打断点发现：</p>\n<ul>\n<li><img src=\"http://upload-images.jianshu.io/upload_images/1311457-32e7ccd4255cc480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RecyclerView中自己消费了consumedY\"></li>\n</ul>\n<p>RecyclerView中自己消费了consumedY，uncomsumed = y - consumeY = 0 ，然后<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-8b373d479b685fd3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NestedScrollView中拿到的dyUnConsumed为0\"></p>\n<p>NestedScrollView中拿到的dyUnConsumed为0，调用dispatchNestedScroll方法也就传入0<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-b1f5a63b62fd33e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"NestedScrollingChildHelper中if分支进不去\"><br>这样的话，NestedScrollingChildHelper中if分支进不去，就没法向上层传递消费的y值（相当于它并没有滚动），ViewParentCompat.onNestedScroll没法调用，所以没能传递到顶层的CoordinatorLayout，自然behavior里面也不会收到回调了。</p>\n<p>从源码上来看是这样的，如果从宏观上来讲，其实就是RecyclerView和NestedScrollView的事件处理有冲突，RecyclerView消费了事件，从而NestedScrollView没能把自己消费的事件往上传递。<br>按道理，我们都知道，如果竖向的RecyclerView和NestedScrollView或者ScrollView联合使用的话（虽然，这样联合使用没有意义，也不建议这样做），会出现事件冲突。但是，横向的RecyclerView和NestedScrollView一起使用，在事件处理上面是没有问题的，没有冲突，但是，在使用到behavior，希望nestedScrollView能够把自己滚动消费的事件往上传递的时候就会出问题了。<br>（我们都希望behavior的使用是在没有嵌套滚动冲突的情况下，兄弟滚动，然后父亲知道，父亲通知另外一个兄弟做出相应的行为，而如果是子孙滚动，往上传给父亲，这期间出了问题，就没法正常工作了）</p>\n<h6 id=\"接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable-false-就能够正常使用？”\"><a href=\"#接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable-false-就能够正常使用？”\" class=\"headerlink\" title=\"接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？”\"></a>接着第二个问题，“为什么让RecyclerView设置setNestedScrollingEnable(false)就能够正常使用？”</h6><p>看看效果<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-9ffc92ff78aa70cd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"OK,可能转gif帧率不够有点卡\"></p>\n<p>第二个问题就需要大家对于事件分发机制有一定的了解，这里就大致贴张图。<br><img src=\"http://upload-images.jianshu.io/upload_images/1311457-e3d5fe3ad2c86848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"事件分发机制\"><br>另外，贴几个认为比较不错的链接：<br>1、<a href=\"http://www.jianshu.com/p/e99b5e8bd67b\" target=\"_blank\" rel=\"noopener\">图解 Android 事件分发机制</a><br>2、<a href=\"http://www.jianshu.com/p/38015afcdb58\" target=\"_blank\" rel=\"noopener\">Android事件分发机制详解：史上最全面、最易懂</a><br>3、<a href=\"http://blog.csdn.net/mynameishuangshuai/article/details/52912641\" target=\"_blank\" rel=\"noopener\">Android6.0源码解读之View点击事件分发机制</a><br>4、<a href=\"http://www.jianshu.com/p/383bae6b6487\" target=\"_blank\" rel=\"noopener\">Android 事件分发机制-试着读懂每一行源码-View</a><br>5、<a href=\"http://www.jianshu.com/p/7e17e48e6baf\" target=\"_blank\" rel=\"noopener\">ScrollView与头+RecycleView嵌套冲突源码分析</a></p>\n<p>我们看看setNestedScrollingEnabled<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RecyclerView</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">    public void setNestedScrollingEnabled(boolean enabled) &#123;</span><br><span class=\"line\">        getScrollingChildHelper().setNestedScrollingEnabled(enabled);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了辅助类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NestedScrollingChildHelper</span><br><span class=\"line\">   public void setNestedScrollingEnabled(boolean enabled) &#123;</span><br><span class=\"line\">        if (mIsNestedScrollingEnabled) &#123;</span><br><span class=\"line\">            ViewCompat.stopNestedScroll(mView);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mIsNestedScrollingEnabled = enabled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>辅助类设置mIsNestedScrollingEnabled为false，并且调用了 ViewCompat.stopNestedScroll(mView);传入了自己<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NestedScrollingChildHelper</span><br><span class=\"line\"> public boolean isNestedScrollingEnabled() &#123;</span><br><span class=\"line\">        return mIsNestedScrollingEnabled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样isNestedScrollingEnabled返回false了，以后behavior的回调方法里面的if(isNestedScrollingEnabled())就进不去了<br>接着：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewCompat</span><br><span class=\"line\"> public static void stopNestedScroll(@NonNull View view) &#123;</span><br><span class=\"line\">        IMPL.stopNestedScroll(view);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里，ViewCompat就是一个兼容类，兼容各个版本api的使用，因为有一些新版本的api，实现的是NestedScrollingParent2等方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewCompat</span><br><span class=\"line\"> public void stopNestedScroll(View view) &#123;</span><br><span class=\"line\">            if (view instanceof NestedScrollingChild) &#123;</span><br><span class=\"line\">                ((NestedScrollingChild) view).stopNestedScroll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里是相当于调用view的stopNestedScroll，也就是RecyclerView的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//RecyclerView</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">    public void stopNestedScroll() &#123;</span><br><span class=\"line\">        getScrollingChildHelper().stopNestedScroll();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestedScrollingChildHelper</span><br><span class=\"line\">   public void stopNestedScroll() &#123;</span><br><span class=\"line\">        stopNestedScroll(TYPE_TOUCH);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestedScrollingChildHelper</span><br><span class=\"line\"> public void stopNestedScroll(@NestedScrollType int type) &#123;</span><br><span class=\"line\">        ViewParent parent = getNestedScrollingParentForType(type);</span><br><span class=\"line\">        if (parent != null) &#123;</span><br><span class=\"line\">            ViewParentCompat.onStopNestedScroll(parent, mView, type);</span><br><span class=\"line\">            setNestedScrollingParentForType(type, null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里就比较重要了，这里通过getNestedScrollingParenForType获得了parent，然后调用了ViewParentCompat.onStopNestedScroll(parent, mView, type);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//viewParentCompat</span><br><span class=\"line\">  public static void onStopNestedScroll(ViewParent parent, View target, int type) &#123;</span><br><span class=\"line\">        if (parent instanceof NestedScrollingParent2) &#123;</span><br><span class=\"line\">            // First try the NestedScrollingParent2 API</span><br><span class=\"line\">            ((NestedScrollingParent2) parent).onStopNestedScroll(target, type);</span><br><span class=\"line\">        &#125; else if (type == ViewCompat.TYPE_TOUCH) &#123;</span><br><span class=\"line\">            // Else if the type is the default (touch), try the NestedScrollingParent API</span><br><span class=\"line\">            IMPL.onStopNestedScroll(parent, target);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法会又调用IMPL.onStopNestedScroll(parent, target);这样类似的方法其实就是把事件一层一层往上传，当然，其他onPreNestedScroll、onNestedScroll这些也都是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestesScrollView</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">    public void onStopNestedScroll(View target) &#123;</span><br><span class=\"line\">        mParentHelper.onStopNestedScroll(target);</span><br><span class=\"line\">        stopNestedScroll();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们又看NestedScrollView里面的onStopNestedScroll<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">``` mParentHelper.onStopNestedScroll(target);```就比较关键了</span><br></pre></td></tr></table></figure></p>\n<p>//NestedScrollingParentHelper<br>  public void onStopNestedScroll(@NonNull View target) {<br>        onStopNestedScroll(target, ViewCompat.TYPE_TOUCH);<br>    }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"> public void onStopNestedScroll(@NonNull View target, @NestedScrollType int type) &#123;</span><br><span class=\"line\">        mNestedScrollAxes = 0;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个就关键了，mNestedScrollAxes = 0<br><figure class=\"highlight plain\"><figcaption><span>int getNestedScrollAxes() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    return mNestedScrollAxes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法返回0了，看看它在哪被调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NestedScrollVIew#onIntercept#move</span><br><span class=\"line\">    final int yDiff = Math.abs(y - mLastMotionY);</span><br><span class=\"line\">                if (yDiff &gt; mTouchSlop</span><br><span class=\"line\">                        &amp;&amp; (getNestedScrollAxes() &amp; ViewCompat.SCROLL_AXIS_VERTICAL) == 0) &#123;</span><br><span class=\"line\">                    mIsBeingDragged = true;</span><br><span class=\"line\">                    mLastMotionY = y;</span><br><span class=\"line\">                    initVelocityTrackerIfNotExists();</span><br><span class=\"line\">                    mVelocityTracker.addMovement(ev);</span><br><span class=\"line\">                    mNestedYOffset = 0;</span><br><span class=\"line\">                    final ViewParent parent = getParent();</span><br><span class=\"line\">                    if (parent != null) &#123;</span><br><span class=\"line\">                        parent.requestDisallowInterceptTouchEvent(true);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                break;</span><br></pre></td></tr></table></figure></p>\n<p>在move的时候，它返回为0，那么走入分支的话，mIsBeingDragged =true<br>onInterceptTouchEvent就返回true, 就会拦截了。<br>这就说明，在move的时候，nestedScrollView就完全拦截了事件，里面的子孙view（包括横向的RecyclerView就不会有事件了，更不用谈什么它自己消费掉了consumeY，NestedScrollView自己全权处理了），这样的话它自己的滚动事件就能够再往上一直传递到coordinatorLayout，然后behavior也就肯定能够执行回到方法了！<br>啊，原来如此，恍然大悟！</p>\n<h3 id=\"5个小问题\"><a href=\"#5个小问题\" class=\"headerlink\" title=\"5个小问题\"></a>5个小问题</h3><p>前面两个大问题终于解决了，下面来搞清楚后面提的那5个小问题。<br><strong>1、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？<br>2、判断子View是否能够接收事件从哪里体现？<br>3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？<br>4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？<br>5、viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？</strong><br>这几个问题全是关于事件分发的，大家可以把那几个链接的文章都看了，如果还不能解决，那么再往下看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewGroup#dispatchTouchEvent  代码有省略</span><br><span class=\"line\"> @Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">      boolean handled = false;</span><br><span class=\"line\">            // Handle an initial down.</span><br><span class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">              // 这里mFirstTouchTarget置为null</span><br><span class=\"line\">                cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">                resetTouchState();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Check for interception.</span><br><span class=\"line\">            final boolean intercepted;</span><br><span class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">                    || mFirstTouchTarget != null) &#123;</span><br><span class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class=\"line\">                if (!disallowIntercept) &#123;</span><br><span class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class=\"line\">                    ev.setAction(action); // restore action in case it was changed</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    intercepted = false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                // There are no touch targets and this action is not an initial down</span><br><span class=\"line\">                // so this view group continues to intercept touches.</span><br><span class=\"line\">                intercepted = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class=\"line\">            TouchTarget newTouchTarget = null;</span><br><span class=\"line\">            boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class=\"line\">   ##### 重要 if分支1</span><br><span class=\"line\">            if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">                        final View[] children = mChildren;</span><br><span class=\"line\">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">                            final int childIndex = getAndVerifyPreorderedIndex(</span><br><span class=\"line\">                                    childrenCount, i, customOrder);</span><br><span class=\"line\">                            final View child = getAndVerifyPreorderedView(</span><br><span class=\"line\">                                    preorderedList, children, childIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">                            // If there is a view that has accessibility focus we want it</span><br><span class=\"line\">                            // to get the event first and if not handled we will perform a</span><br><span class=\"line\">                            // normal dispatch. We may do a double iteration but this is</span><br><span class=\"line\">                            // safer given the timeframe.</span><br><span class=\"line\">                            if (childWithAccessibilityFocus != null) &#123;</span><br><span class=\"line\">                                if (childWithAccessibilityFocus != child) &#123;</span><br><span class=\"line\">                                    continue;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                childWithAccessibilityFocus = null;</span><br><span class=\"line\">                                i = childrenCount - 1;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                            if (!canViewReceivePointerEvents(child)</span><br><span class=\"line\">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class=\"line\">                                ev.setTargetAccessibilityFocus(false);</span><br><span class=\"line\">                                continue;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            resetCancelNextUpFlag(child);</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">                                // Child wants to receive touch within its bounds.</span><br><span class=\"line\">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class=\"line\">                                if (preorderedList != null) &#123;</span><br><span class=\"line\">                                    // childIndex points into presorted list, find original index</span><br><span class=\"line\">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</span><br><span class=\"line\">                                        if (children[childIndex] == mChildren[j]) &#123;</span><br><span class=\"line\">                                            mLastTouchDownIndex = j;</span><br><span class=\"line\">                                            break;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125; else &#123;</span><br><span class=\"line\">                                    mLastTouchDownIndex = childIndex;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                mLastTouchDownX = ev.getX();</span><br><span class=\"line\">                                mLastTouchDownY = ev.getY();</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">                                alreadyDispatchedToNewTouchTarget = true;</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            // The accessibility focus didn&apos;t handle the event, so clear</span><br><span class=\"line\">                            // the flag and do a normal dispatch to all children.</span><br><span class=\"line\">                            ev.setTargetAccessibilityFocus(false);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (preorderedList != null) preorderedList.clear();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // Dispatch to touch targets.</span><br><span class=\"line\">   ##### 重要 if分支2</span><br><span class=\"line\">            if (mFirstTouchTarget == null) &#123;</span><br><span class=\"line\">                // No touch targets so treat this as an ordinary view.</span><br><span class=\"line\">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class=\"line\">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                // Dispatch to touch targets, excluding the new touch target if we already</span><br><span class=\"line\">                // dispatched to it.  Cancel touch targets if necessary.</span><br><span class=\"line\">                TouchTarget predecessor = null;</span><br><span class=\"line\">                TouchTarget target = mFirstTouchTarget;</span><br><span class=\"line\">                while (target != null) &#123;</span><br><span class=\"line\">                    final TouchTarget next = target.next;</span><br><span class=\"line\">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class=\"line\">                        handled = true;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class=\"line\">                                || intercepted;</span><br><span class=\"line\">    ##### 重点</span><br><span class=\"line\">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class=\"line\">                                target.child, target.pointerIdBits)) &#123;</span><br><span class=\"line\">                            handled = true;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (cancelChild) &#123;</span><br><span class=\"line\">                            if (predecessor == null) &#123;</span><br><span class=\"line\">                                mFirstTouchTarget = next;</span><br><span class=\"line\">                            &#125; else &#123;</span><br><span class=\"line\">                                predecessor.next = next;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            target.recycle();</span><br><span class=\"line\">                            target = next;</span><br><span class=\"line\">                            continue;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    predecessor = target;</span><br><span class=\"line\">                    target = next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">        return handled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ViewGroup#dispatchTransformedTouchEvent  代码有省略</span><br><span class=\"line\"> private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class=\"line\">            View child, int desiredPointerIdBits) &#123;</span><br><span class=\"line\">        final boolean handled;</span><br><span class=\"line\">        final int oldAction = event.getAction();</span><br><span class=\"line\">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class=\"line\">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class=\"line\">            if (child == null) &#123;</span><br><span class=\"line\">                handled = super.dispatchTouchEvent(event);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            event.setAction(oldAction);</span><br><span class=\"line\">            return handled;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        final MotionEvent transformedEvent;</span><br><span class=\"line\">        if (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class=\"line\">            if (child == null || child.hasIdentityMatrix()) &#123;</span><br><span class=\"line\">                if (child == null) &#123;</span><br><span class=\"line\">                    handled = super.dispatchTouchEvent(event);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">              handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return handled;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            transformedEvent = MotionEvent.obtain(event);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            transformedEvent = event.split(newPointerIdBits);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Perform any necessary transformations and dispatch.</span><br><span class=\"line\">        if (child == null) &#123;</span><br><span class=\"line\">            handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">         handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Done.</span><br><span class=\"line\">        transformedEvent.recycle();</span><br><span class=\"line\">        return handled;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\"><a href=\"#1-、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\" class=\"headerlink\" title=\"1 、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？\"></a>1 、对于如果onIntercept返回true拦截了，交给onTouchEvent去处理，具体体现在何处？</h4><p>如果onIntercep返回true，那么interceped变量为true，那么不会走入【重要 if分支1】（里面分发事件，设置mFirstTouchTarget等），mFirstTouchTarget依旧为null, 于是走入【重要 if分支2】的<figure class=\"highlight plain\"><figcaption><span>canceled, null,TouchTarget.ALL_POINTER_IDS)``` 并且传入child为null, </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在dispatchTransformedTouchEvent中如果child为null,就会走super.dispatch, super就是view，这样的话，就会走view的dispatch（view本身的dispatch会调onTouch），就会走到onTouch去了</span><br><span class=\"line\">#### 2、判断子View是否能够接收事件从哪里体现？</span><br><span class=\"line\">在viewgroup的dispatch中的走入if分支之后，里面有个判断</span><br></pre></td></tr></table></figure></p>\n<p>if (!canViewReceivePointerEvents(child)<br>                                    || !isTransformedTouchPointInView(x, y, child, null)) {<br>                                ev.setTargetAccessibilityFocus(false);<br>                                continue;<br>                            }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有个方法canViewReceivePointerEvents，里面主要是判断是否Visible</span><br><span class=\"line\">isTransformedTouchPointInView主要是判断事件的位置是否在子VIew的区域内</span><br><span class=\"line\">如果不行，就continue，后续的事件分发就不进行</span><br><span class=\"line\">#### 3、另外一个比较重要的方法dispatchTransformedTouchEvent干什么用的？</span><br><span class=\"line\">dispatchTransformedTouchEvent主要就是对于事件分发的处理，比如什么时候调用自己的super.dispatch，什么时候调用child.disaptch分发给子View, 这个判断方法的主要根据就是child是否为null, 而这个又跟mFirstTouchTarget有关联</span><br><span class=\"line\">#### 4、viewGroup和view的dispatch返回false，会直接回溯到parent的onTouchEvent，这个又在哪里体现？</span><br><span class=\"line\">这个问题也跟第1个问题有点类似，如果子View的dispatch返回false，那么dispatchTransformedTouchEvent的handled就会是false返回，然后【重要 if分支1】就走不进去，addTouchTarget这个方法也不执行（主要是给mFirstTarget赋值）</span><br></pre></td></tr></table></figure></p>\n<p>  private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {<br>        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);<br>        target.next = mFirstTouchTarget;<br>        mFirstTouchTarget = target;<br>        return target;<br>    }<br>```<br>前面说了，如果mFirstTarget为null, 【重要 if分支2】就会进入dispatchTransformedTouchEvent的时候传入为null的child, 这样就会调用super.dispatch，就是view的dispatch，然后就调用了onTouch咯</p>\n<h4 id=\"viewGroup重写了dispatch但是没有调用super-那么它在哪里调用自己的onTouch的呢？\"><a href=\"#viewGroup重写了dispatch但是没有调用super-那么它在哪里调用自己的onTouch的呢？\" class=\"headerlink\" title=\"viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？\"></a>viewGroup重写了dispatch但是没有调用super, 那么它在哪里调用自己的onTouch的呢？</h4><p>如果看到这，希望第5个问题我已经不用解释了，因为前面4个问题已经把它囊括在内了。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>为了解决这个问题，最近一直在源码的黑洞里遨游，打了N个断点来回跳，梳理逻辑。最后一句，最终想要深刻地理解事件分发机制、behavior机制这些玩意儿，RTFSC。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjcozqjuc00000cuskfuux868","tag_id":"cjcozqjup00020cusdaw38z0o","_id":"cjcozqjv100070cus9dpmxz0f"},{"post_id":"cjcozqjv200080cusb4ij6wb2","tag_id":"cjcozqjv100060cusvoynby8h","_id":"cjcozqjv7000b0cusyf15ddaq"},{"post_id":"cjcozqjui00010cusc98wy1za","tag_id":"cjcozqjv100060cusvoynby8h","_id":"cjcozqjva000d0cusuthz5y0k"},{"post_id":"cjcozqjv400090cusu09ahlyz","tag_id":"cjcozqjv100060cusvoynby8h","_id":"cjcozqjvc000g0cusgag8te7z"},{"post_id":"cjcozqjur00030cusjcvbh5jk","tag_id":"cjcozqjup00020cusdaw38z0o","_id":"cjcozqjvf000i0cus1kcknnhm"},{"post_id":"cjcozqjva000e0cusfluy8gp2","tag_id":"cjcozqjv100060cusvoynby8h","_id":"cjcozqjvj000l0cusu8la3dls"},{"post_id":"cjcozqjuv00040cusq25worfg","tag_id":"cjcozqjv100060cusvoynby8h","_id":"cjcozqjvm000n0cuszg3krn1z"},{"post_id":"cjcozqjv000050cuskjgrh4kv","tag_id":"cjcozqjv100060cusvoynby8h","_id":"cjcozqjvp000q0cus2c542ta4"}],"Tag":[{"name":"kotlin","_id":"cjcozqjup00020cusdaw38z0o"},{"name":"android","_id":"cjcozqjv100060cusvoynby8h"}]}}